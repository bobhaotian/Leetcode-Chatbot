Title,Question,Examples,Solution,Python
Find a Peak Element II,"A peak element in a 2D grid is an element that is strictly greater than all of its adjacent neighbors to the left, right, top, and bottom.
Given a 0-indexed m x n matrix mat where no two adjacent cells are equal, find any peak element mat[i][j] and return the length 2 array [i,j].
You may assume that the entire matrix is surrounded by an outer perimeter with the value -1 in each cell.
You must write an algorithm that runs in O(m log(n)) or O(n log(m)) time.
","Example 1:

Input: mat = [[1,4],[3,2]]
Output: [0,1]
Explanation: Both 3 and 4 are peak elements so [1,0] and [0,1] are both acceptable answers.
Example 2:

Input: mat = [[10,20,15],[21,30,14],[7,16,32]]
Output: [1,1]
Explanation: Both 30 and 32 are peak elements so [1,1] and [2,2] are both acceptable answers.
","class Solution {
public:
    int maxEl(vector<vector<int>>& mat, int n, int m, int col) {
        int maxi = -1;
        int ind = -1;  
        for(int i = 0; i<n; i++) {
            if(mat[i][col]>maxi) {
                maxi = mat[i][col];
                ind = i;
            }
        }
        return ind;
    }
    vector<int> findPeakGrid(vector<vector<int>>& mat) {
        int n = mat.size();
        int m = mat[0].size();
        int low = 0;
        int high = m - 1; 
        while(low<=high) {
            int mid = (low+high)/2;
            int row = maxEl(mat, n, m, mid);
            int left = mid-1>=0 ? mat[row][mid-1] : -1; 
            int right = mid+1<m ? mat[row][mid+1] : -1; 
            if(mat[row][mid]>left && mat[row][mid]>right) return {row, mid};
            else if(mat[row][mid]<left) high = mid-1;
            else low = mid+1;
        }
        return {-1,-1};
    }
};
",False
Build Array from Permutation,"Given a zero-based permutation nums (0-indexed), build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it.
A zero-based permutation nums is an array of distinct integers from 0 to nums.length - 1 (inclusive).
","Example 1:
Input: nums = [0,2,1,5,3,4]
Output: [0,1,2,4,5,3]
Explanation: The array ans is built as follows: 
ans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]
    = [nums[0], nums[2], nums[1], nums[5], nums[3], nums[4]]
    = [0,1,2,4,5,3]
Example 2:
Input: nums = [5,0,1,2,3,4]
Output: [4,5,0,1,2,3]
Explanation: The array ans is built as follows:
ans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]
    = [nums[5], nums[0], nums[1], nums[2], nums[3], nums[4]]
    = [4,5,0,1,2,3]
","class Solution:
    def buildArray(self, nums: List[int]) -> List[int]:
        answer = []
        for i in range(len(nums)):
            answer.append(nums[nums[i]])
        
        return answer",True
Eliminate Maximum Number of Monsters,"You are playing a video game where you are defending your city from a group of n monsters. You are given a 0-indexed integer array dist of size n, where dist[i] is the initial distance in kilometers of the ith monster from the city.
The monsters walk toward the city at a constant speed. The speed of each monster is given to you in an integer array speed of size n, where speed[i] is the speed of the ith monster in kilometers per minute.
You have a weapon that, once fully charged, can eliminate a single monster. However, the weapon takes one minute to charge. The weapon is fully charged at the very start.
You lose when any monster reaches your city. If a monster reaches the city at the exact moment the weapon is fully charged, it counts as a loss, and the game ends before you can use your weapon.
Return the maximum number of monsters that you can eliminate before you lose, or n if you can eliminate all the monsters before they reach the city.
","Example 1:
Input: dist = [1,3,4], speed = [1,1,1]
Output: 3
Explanation:
In the beginning, the distances of the monsters are [1,3,4]. You eliminate the first monster.
After a minute, the distances of the monsters are [X,2,3]. You eliminate the second monster.
After a minute, the distances of the monsters are [X,X,2]. You eliminate the third monster.
All 3 monsters can be eliminated.
Example 2:
Input: dist = [1,1,2,3], speed = [1,1,1,1]
Output: 1
Explanation:
In the beginning, the distances of the monsters are [1,1,2,3]. You eliminate the first monster.
After a minute, the distances of the monsters are [X,0,1,2], so you lose.
You can only eliminate 1 monster.
Example 3:
Input: dist = [3,2,4], speed = [5,3,2]
Output: 1
Explanation:
In the beginning, the distances of the monsters are [3,2,4]. You eliminate the first monster.
After a minute, the distances of the monsters are [X,0,2], so you lose.
You can only eliminate 1 monster.
","class Solution:
    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:
        for a in range(len(dist)) :
            dist[a] = dist[a]/speed[a]
        dist.sort()
        
        if (dist[0] == 0) :
            return 1

        for a in range(1,len(dist)) :
            if (dist[a] <= a) :
                return a

        return len(dist)",True
Concatenation of Array,"Given an integer array nums of length n, you want to create an array ans of length 2n where ans[i] == nums[i] and ans[i + n] == nums[i] for 0 <= i < n (0-indexed).
Specifically, ans is the concatenation of two nums arrays.
Return the array ans.
","Example 1:
Input: nums = [1,2,1]
Output: [1,2,1,1,2,1]
Explanation: The array ans is formed as follows:
- ans = [nums[0],nums[1],nums[2],nums[0],nums[1],nums[2]]
- ans = [1,2,1,1,2,1]
Example 2:
Input: nums = [1,3,2,1]
Output: [1,3,2,1,1,3,2,1]
Explanation: The array ans is formed as follows:
- ans = [nums[0],nums[1],nums[2],nums[3],nums[0],nums[1],nums[2],nums[3]]
- ans = [1,3,2,1,1,3,2,1]
","class Solution {
public:
    vector<int> getConcatenation(vector<int>& nums) {
        vector<int> output(nums);

        for(int i =0 ; i < nums.size(); i++)
        {
            output.push_back(nums[i]);
        }

        return output;
    }
};",False
Check If String Is a Prefix of Array,"Given a string s and an array of strings words, determine whether s is a prefix string of words.
A string s is a prefix string of words if s can be made by concatenating the first k strings in words for some positive k no larger than words.length.
Return true if s is a prefix string of words, or false otherwise.
","Example 1:
Input: s = ""iloveleetcode"", words = [""i"",""love"",""leetcode"",""apples""]
Output: true
Explanation:
s can be made by concatenating ""i"", ""love"", and ""leetcode"" together.
Example 2:
Input: s = ""iloveleetcode"", words = [""apples"",""i"",""love"",""leetcode""]
Output: false
Explanation:
It is impossible to make s using a prefix of arr.
","class Solution:
    def isPrefixString(self, s: str, words: List[str]) -> bool:
        ans = ''
        for i in words:
            ans += i
            if ans == s :
                return True
        return False",True
Remove Stones to Minimize the Total,"You are given a 0-indexed integer array piles, where piles[i] represents the number of stones in the ith pile, and an integer k. You should apply the following operation exactly k times:
Choose any piles[i] and remove floor(piles[i] / 2) stones from it.
Notice that you can apply the operation on the same pile more than once.
Return the minimum possible total number of stones remaining after applying the k operations.
floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).
","Example 1:
Input: piles = [5,4,9], k = 2
Output: 12
Explanation: Steps of a possible scenario are:
- Apply the operation on pile 2. The resulting piles are [5,4,5].
- Apply the operation on pile 0. The resulting piles are [3,4,5].
The total number of stones in [3,4,5] is 12.
Example 2:
Input: piles = [4,3,6,7], k = 3
Output: 12
Explanation: Steps of a possible scenario are:
- Apply the operation on pile 2. The resulting piles are [4,3,3,7].
- Apply the operation on pile 3. The resulting piles are [4,3,3,4].
- Apply the operation on pile 0. The resulting piles are [2,3,3,4].
The total number of stones in [2,3,3,4] is 12.
",,False
Find the Middle Index in Array,"Given a 0-indexed integer array nums, find the leftmost middleIndex (i.e., the smallest amongst all the possible ones).
A middleIndex is an index where nums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1].
If middleIndex == 0, the left side sum is considered to be 0. Similarly, if middleIndex == nums.length - 1, the right side sum is considered to be 0.
Return the leftmost middleIndex that satisfies the condition, or -1 if there is no such index.
","Example 1:
Input: nums = [2,3,-1,8,4]
Output: 3
Explanation: The sum of the numbers before index 3 is: 2 + 3 + -1 = 4
The sum of the numbers after index 3 is: 4 = 4
Example 2:
Input: nums = [1,-1,4]
Output: 2
Explanation: The sum of the numbers before index 2 is: 1 + -1 = 0
The sum of the numbers after index 2 is: 0
Example 3:
Input: nums = [2,5]
Output: -1
Explanation: There is no valid middleIndex.
","class Solution:
    def findMiddleIndex(self, nums: List[int]) -> int:
        
        # find the sum
        right_sum = sum(nums)
        left_sum = 0
        
        for idx in range(len(nums)):
            
            # subtract current num from right sum
            right_sum -= nums[idx]
            
            # compare the sums
            if right_sum == left_sum:
                return idx
            
            # add current value to left sum
            left_sum += nums[idx]
        return -1",True
Find All Groups of Farmland,"You are given a 0-indexed m x n binary matrix land where a 0 represents a hectare of forested land and a 1 represents a hectare of farmland.
To keep the land organized, there are designated rectangular areas of hectares that consist entirely of farmland. These rectangular areas are called groups. No two groups are adjacent, meaning farmland in one group is not four-directionally adjacent to another farmland in a different group.
land can be represented by a coordinate system where the top left corner of land is (0, 0) and the bottom right corner of land is (m-1, n-1). Find the coordinates of the top left and bottom right corner of each group of farmland. A group of farmland with a top left corner at (r1, c1) and a bottom right corner at (r2, c2) is represented by the 4-length array [r1, c1, r2, c2].
Return a 2D array containing the 4-length arrays described above for each group of farmland in land. If there are no groups of farmland, return an empty array. You may return the answer in any order.
","Example 1:

Input: land = [[1,0,0],[0,1,1],[0,1,1]]
Output: [[0,0,0,0],[1,1,2,2]]
Explanation:
The first group has a top left corner at land[0][0] and a bottom right corner at land[0][0].
The second group has a top left corner at land[1][1] and a bottom right corner at land[2][2].
Example 2:

Input: land = [[1,1],[1,1]]
Output: [[0,0,1,1]]
Explanation:
The first group has a top left corner at land[0][0] and a bottom right corner at land[1][1].
Example 3:

Input: land = [[0]]
Output: []
Explanation:
There are no groups of farmland.
",,False
Find Greatest Common Divisor of Array,"Given an integer array nums, return the greatest common divisor of the smallest number and largest number in nums.
The greatest common divisor of two numbers is the largest positive integer that evenly divides both numbers.
","Example 1:
Input: nums = [2,5,6,9,10]
Output: 2
Explanation:
The smallest number in nums is 2.
The largest number in nums is 10.
The greatest common divisor of 2 and 10 is 2.
Example 2:
Input: nums = [7,5,6,8,3]
Output: 1
Explanation:
The smallest number in nums is 3.
The largest number in nums is 8.
The greatest common divisor of 3 and 8 is 1.
Example 3:
Input: nums = [3,3]
Output: 3
Explanation:
The smallest number in nums is 3.
The largest number in nums is 3.
The greatest common divisor of 3 and 3 is 3.
","class Solution {
    public int findGCD(int[] nums) {
        Arrays.sort(nums);
        int GCD = 1;
        for(int i = 1; i <= nums[0]; i++) {
            if(nums[0] % i == 0 && nums[nums.length - 1] % i == 0) {
                GCD = i;
            }
        }
        return GCD;
    }
}",False
Find Unique Binary String,"Given an array of strings nums containing n unique binary strings each of length n, return a binary string of length n that does not appear in nums. If there are multiple answers, you may return any of them.
","Example 1:
Input: nums = [""01"",""10""]
Output: ""11""
Explanation: ""11"" does not appear in nums. ""00"" would also be correct.
Example 2:
Input: nums = [""00"",""01""]
Output: ""11""
Explanation: ""11"" does not appear in nums. ""10"" would also be correct.
Example 3:
Input: nums = [""111"",""011"",""001""]
Output: ""101""
Explanation: ""101"" does not appear in nums. ""000"", ""010"", ""100"", and ""110"" would also be correct.
","class Solution:
    def findDifferentBinaryString(self, nums: List[str]) -> str:
        ans = []

        for i in range(len(nums)):
            ans.append(str(int(nums[i][i]) ^ 1))

        return ''.join(ans)",True
Minimum Difference Between Highest and Lowest of K Scores,"You are given a 0-indexed integer array nums, where nums[i] represents the score of the ith student. You are also given an integer k.
Pick the scores of any k students from the array so that the difference between the highest and the lowest of the k scores is minimized.
Return the minimum possible difference.
","Example 1:
Input: nums = [90], k = 1
Output: 0
Explanation: There is one way to pick score(s) of one student:
- [90]. The difference between the highest and lowest score is 90 - 90 = 0.
The minimum possible difference is 0.
Example 2:
Input: nums = [9,4,1,7], k = 2
Output: 2
Explanation: There are six ways to pick score(s) of two students:
- [9,4,1,7]. The difference between the highest and lowest score is 9 - 4 = 5.
- [9,4,1,7]. The difference between the highest and lowest score is 9 - 1 = 8.
- [9,4,1,7]. The difference between the highest and lowest score is 9 - 7 = 2.
- [9,4,1,7]. The difference between the highest and lowest score is 4 - 1 = 3.
- [9,4,1,7]. The difference between the highest and lowest score is 7 - 4 = 3.
- [9,4,1,7]. The difference between the highest and lowest score is 7 - 1 = 6.
The minimum possible difference is 2.
","class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        nums = sorted(nums)
        return_diff = float('inf')
        for num in range(len(nums)-k + 1):
            current_diff = nums[num+k-1] - nums[num]
            if current_diff < return_diff:
                return_diff = current_diff

        return return_diff

",True
Find the Kth Largest Integer in the Array,"You are given an array of strings nums and an integer k. Each string in nums represents an integer without leading zeros.
Return the string that represents the kth largest integer in nums.
Note: Duplicate numbers should be counted distinctly. For example, if nums is [""1"",""2"",""2""], ""2"" is the first largest integer, ""2"" is the second-largest integer, and ""1"" is the third-largest integer.
","Example 1:
Input: nums = [""3"",""6"",""7"",""10""], k = 4
Output: ""3""
Explanation:
The numbers in nums sorted in non-decreasing order are [""3"",""6"",""7"",""10""].
The 4th largest integer in nums is ""3"".
Example 2:
Input: nums = [""2"",""21"",""12"",""1""], k = 3
Output: ""2""
Explanation:
The numbers in nums sorted in non-decreasing order are [""1"",""2"",""12"",""21""].
The 3rd largest integer in nums is ""2"".
Example 3:
Input: nums = [""0"",""0""], k = 2
Output: ""0""
Explanation:
The numbers in nums sorted in non-decreasing order are [""0"",""0""].
The 2nd largest integer in nums is ""0"".
",,False
Count Number of Pairs With Absolute Difference K,"Given an integer array nums and an integer k, return the number of pairs (i, j) where i < j such that |nums[i] - nums[j]| == k.
The value of |x| is defined as:
x if x >= 0.
-x if x < 0.
","Example 1:
Input: nums = [1,2,2,1], k = 1
Output: 4
Explanation: The pairs with an absolute difference of 1 are:
- [1,2,2,1]
- [1,2,2,1]
- [1,2,2,1]
- [1,2,2,1]
Example 2:
Input: nums = [1,3], k = 3
Output: 0
Explanation: There are no pairs with an absolute difference of 3.
Example 3:
Input: nums = [3,2,1,5,4], k = 2
Output: 3
Explanation: The pairs with an absolute difference of 2 are:
- [3,2,1,5,4]
- [3,2,1,5,4]
- [3,2,1,5,4]
","class Solution {
public:
    int countKDifference(vector<int>& nums, int k) {
        int n=nums.size();
        int ans=0;
        for(int i=0; i<n-1; i++)
        {
            for(int j=i+1; j<n; j++)
            {
                if(abs(nums[i]-nums[j])==k)
                {
                    ans++;
                }
            }
        }
        return ans;
    }
};",False
Convert 1D Array Into 2D Array,"You are given a 0-indexed 1-dimensional (1D) integer array original, and two integers, m and n. You are tasked with creating a 2-dimensional (2D) array with  m rows and n columns using all the elements from original.
The elements from indices 0 to n - 1 (inclusive) of original should form the first row of the constructed 2D array, the elements from indices n to 2 * n - 1 (inclusive) should form the second row of the constructed 2D array, and so on.
Return an m x n 2D array constructed according to the above procedure, or an empty 2D array if it is impossible.
","Example 1:

Input: original = [1,2,3,4], m = 2, n = 2
Output: [[1,2],[3,4]]
Explanation: The constructed 2D array should contain 2 rows and 2 columns.
The first group of n=2 elements in original, [1,2], becomes the first row in the constructed 2D array.
The second group of n=2 elements in original, [3,4], becomes the second row in the constructed 2D array.
Example 2:
Input: original = [1,2,3], m = 1, n = 3
Output: [[1,2,3]]
Explanation: The constructed 2D array should contain 1 row and 3 columns.
Put all three elements in original into the first row of the constructed 2D array.
Example 3:
Input: original = [1,2], m = 1, n = 1
Output: []
Explanation: There are 2 elements in original.
It is impossible to fit 2 elements in a 1x1 2D array, so return an empty 2D array.
","class Solution:
    def construct2DArray(self, original: List[int], m: int, n: int) -> List[List[int]]:
        if m*n != len(original):
            return []
        
        q = []

        for i in range(0, len(original), n):
            q.append(original[i:i+n])
            
        return q
        ",True
Number of Pairs of Strings With Concatenation Equal to Target,"Given an array of digit strings nums and a digit string target, return the number of pairs of indices (i, j) (where i != j) such that the concatenation of nums[i] + nums[j] equals target.
","Example 1:
Input: nums = [""777"",""7"",""77"",""77""], target = ""7777""
Output: 4
Explanation: Valid pairs are:
- (0, 1): ""777"" + ""7""
- (1, 0): ""7"" + ""777""
- (2, 3): ""77"" + ""77""
- (3, 2): ""77"" + ""77""
Example 2:
Input: nums = [""123"",""4"",""12"",""34""], target = ""1234""
Output: 2
Explanation: Valid pairs are:
- (0, 1): ""123"" + ""4""
- (2, 3): ""12"" + ""34""
Example 3:
Input: nums = [""1"",""1"",""1""], target = ""11""
Output: 6
Explanation: Valid pairs are:
- (0, 1): ""1"" + ""1""
- (1, 0): ""1"" + ""1""
- (0, 2): ""1"" + ""1""
- (2, 0): ""1"" + ""1""
- (1, 2): ""1"" + ""1""
- (2, 1): ""1"" + ""1""
",,False
Final Value of Variable After Performing Operations,"There is a programming language with only four operations and one variable X:
++X and X++ increments the value of the variable X by 1.
--X and X-- decrements the value of the variable X by 1.
Initially, the value of X is 0.
Given an array of strings operations containing a list of operations, return the final value of X after performing all the operations.
","Example 1:
Input: operations = [""--X"",""X++"",""X++""]
Output: 1
Explanation: The operations are performed as follows:
Initially, X = 0.
--X: X is decremented by 1, X =  0 - 1 = -1.
X++: X is incremented by 1, X = -1 + 1 =  0.
X++: X is incremented by 1, X =  0 + 1 =  1.
Example 2:
Input: operations = [""++X"",""++X"",""X++""]
Output: 3
Explanation: The operations are performed as follows:
Initially, X = 0.
++X: X is incremented by 1, X = 0 + 1 = 1.
++X: X is incremented by 1, X = 1 + 1 = 2.
X++: X is incremented by 1, X = 2 + 1 = 3.
Example 3:
Input: operations = [""X++"",""++X"",""--X"",""X--""]
Output: 0
Explanation: The operations are performed as follows:
Initially, X = 0.
X++: X is incremented by 1, X = 0 + 1 = 1.
++X: X is incremented by 1, X = 1 + 1 = 2.
--X: X is decremented by 1, X = 2 - 1 = 1.
X--: X is decremented by 1, X = 1 - 1 = 0.
","class Solution:
    def finalValueAfterOperations(self, operations: List[str]) -> int:
        x=0
        for i in operations:
            if i==""--X"" or i==""X--"":
                x=x-1
            else:
                x=x+1
        return x
        ",True
Detect Squares,"You are given a stream of points on the X-Y plane. Design an algorithm that:
Adds new points from the stream into a data structure. Duplicate points are allowed and should be treated as different points.
Given a query point, counts the number of ways to choose three points from the data structure such that the three points and the query point form an axis-aligned square with positive area.
An axis-aligned square is a square whose edges are all the same length and are either parallel or perpendicular to the x-axis and y-axis.
Implement the DetectSquares class:
DetectSquares() Initializes the object with an empty data structure.
void add(int[] point) Adds a new point point = [x, y] to the data structure.
int count(int[] point) Counts the number of ways to form axis-aligned squares with point point = [x, y] as described above.
","Example 1:

Input
[""DetectSquares"", ""add"", ""add"", ""add"", ""count"", ""count"", ""add"", ""count""]
[[], [[3, 10]], [[11, 2]], [[3, 2]], [[11, 10]], [[14, 8]], [[11, 2]], [[11, 10]]]
Output
[null, null, null, null, 1, 0, null, 2]

Explanation
DetectSquares detectSquares = new DetectSquares();
detectSquares.add([3, 10]);
detectSquares.add([11, 2]);
detectSquares.add([3, 2]);
detectSquares.count([11, 10]); // return 1. You can choose:
                               //   - The first, second, and third points
detectSquares.count([14, 8]);  // return 0. The query point cannot form a square with any points in the data structure.
detectSquares.add([11, 2]);    // Adding duplicate points is allowed.
detectSquares.count([11, 10]); // return 2. You can choose:
                               //   - The first, second, and third points
                               //   - The first, third, and fourth points
",,False
Maximum Difference Between Increasing Elements,"Given a 0-indexed integer array nums of size n, find the maximum difference between nums[i] and nums[j] (i.e., nums[j] - nums[i]), such that 0 <= i < j < n and nums[i] < nums[j].
Return the maximum difference. If no such i and j exists, return -1.
","Example 1:
Input: nums = [7,1,5,4]
Output: 4
Explanation:
The maximum difference occurs with i = 1 and j = 2, nums[j] - nums[i] = 5 - 1 = 4.
Note that with i = 1 and j = 0, the difference nums[j] - nums[i] = 7 - 1 = 6, but i > j, so it is not valid.
Example 2:
Input: nums = [9,4,3,2]
Output: -1
Explanation:
There is no i and j such that i < j and nums[i] < nums[j].
Example 3:
Input: nums = [1,5,2,10]
Output: 9
Explanation:
The maximum difference occurs with i = 0 and j = 3, nums[j] - nums[i] = 10 - 1 = 9.
","class Solution:
    def maximumDifference(self, nums: List[int]) -> int:
        ans = -1 
        prefix = inf
        for i, x in enumerate(nums): 
            if i and x > prefix: ans = max(ans, x - prefix)
            prefix = min(prefix, x)
        return ans ",True
Minimum Number of Moves to Seat Everyone,"There are n seats and n students in a room. You are given an array seats of length n, where seats[i] is the position of the ith seat. You are also given the array students of length n, where students[j] is the position of the jth student.
You may perform the following move any number of times:
Increase or decrease the position of the ith student by 1 (i.e., moving the ith student from position x to x + 1 or x - 1)
Return the minimum number of moves required to move each student to a seat such that no two students are in the same seat.
Note that there may be multiple seats or students in the same position at the beginning.
","Example 1:
Input: seats = [3,1,5], students = [2,7,4]
Output: 4
Explanation: The students are moved as follows:
- The first student is moved from from position 2 to position 1 using 1 move.
- The second student is moved from from position 7 to position 5 using 2 moves.
- The third student is moved from from position 4 to position 3 using 1 move.
In total, 1 + 2 + 1 = 4 moves were used.
Example 2:
Input: seats = [4,1,5,9], students = [1,3,2,6]
Output: 7
Explanation: The students are moved as follows:
- The first student is not moved.
- The second student is moved from from position 3 to position 4 using 1 move.
- The third student is moved from from position 2 to position 5 using 3 moves.
- The fourth student is moved from from position 6 to position 9 using 3 moves.
In total, 0 + 1 + 3 + 3 = 7 moves were used.
Example 3:
Input: seats = [2,2,6,6], students = [1,3,2,6]
Output: 4
Explanation: Note that there are two seats at position 2 and two seats at position 6.
The students are moved as follows:
- The first student is moved from from position 1 to position 2 using 1 move.
- The second student is moved from from position 3 to position 6 using 3 moves.
- The third student is not moved.
- The fourth student is not moved.
In total, 1 + 3 + 0 + 0 = 4 moves were used.
","class Solution {
    public int minMovesToSeat(int[] seats, int[] students) {
        Arrays.sort(students);
        Arrays.sort(seats);
        int sum = 0;
        for(int i = 0; i < seats.length; i++) {
            sum += Math.abs(seats[i] - students[i]);
        }
        return sum;
    }
}",False
Two Out of Three,"nums1
nums2
nums3
a distinct array containing all the values that are present in at least two out of the three arrays. You may return the values in any order
","Example 1:
Input: nums1 = [1,1,3,2], nums2 = [2,3], nums3 = [3]
Output: [3,2]
Explanation: The values that are present in at least two arrays are:
- 3, in all three arrays.
- 2, in nums1 and nums2.
Example 2:
Input: nums1 = [3,1], nums2 = [2,3], nums3 = [1,2]
Output: [2,3,1]
Explanation: The values that are present in at least two arrays are:
- 2, in nums2 and nums3.
- 3, in nums1 and nums2.
- 1, in nums1 and nums3.
Example 3:
Input: nums1 = [1,2,2], nums2 = [4,3,3], nums3 = [5]
Output: []
Explanation: No value is present in at least two arrays.
","class Solution:
    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:
        ret = []

        ret += set(nums1).intersection(set(nums2))
        ret += set(nums1).intersection(set(nums3))
        ret += set(nums2).intersection(set(nums3))

        return set(ret)",True
Kth Distinct String in an Array,"A distinct string is a string that is present only once in an array.
Given an array of strings arr, and an integer k, return the kth distinct string present in arr. If there are fewer than k distinct strings, return an empty string """".
Note that the strings are considered in the order in which they appear in the array.
","Example 1:
Input: arr = [""d"",""b"",""c"",""b"",""c"",""a""], k = 2
Output: ""a""
Explanation:
The only distinct strings in arr are ""d"" and ""a"".
""d"" appears 1st, so it is the 1st distinct string.
""a"" appears 2nd, so it is the 2nd distinct string.
Since k == 2, ""a"" is returned. 
Example 2:
Input: arr = [""aaa"",""aa"",""a""], k = 1
Output: ""aaa""
Explanation:
All strings in arr are distinct, so the 1st string ""aaa"" is returned.
Example 3:
Input: arr = [""a"",""b"",""a""], k = 3
Output: """"
Explanation:
The only distinct string is ""b"". Since there are fewer than 3 distinct strings, we return an empty string """".
","class Solution:
    def kthDistinct(self, arr: List[str], k: int) -> str:
        freq = Counter(arr)
        for x in arr: 
            if freq[x] == 1: k -= 1
            if k == 0: return x
        return """"",True
Plates Between Candles,"There is a long table with a line of plates and candles arranged on top of it. You are given a 0-indexed string s consisting of characters '*' and '|' only, where a '*' represents a plate and a '|' represents a candle.
You are also given a 0-indexed 2D integer array queries where queries[i] = [lefti, righti] denotes the substring s[lefti...righti] (inclusive). For each query, you need to find the number of plates between candles that are in the substring. A plate is considered between candles if there is at least one candle to its left and at least one candle to its right in the substring.
For example, s = ""||**||**|*"", and a query [3, 8] denotes the substring ""*||**|"". The number of plates between candles in this substring is 2, as each of the two plates has at least one candle in the substring to its left and right.
Return an integer array answer where answer[i] is the answer to the ith query.
","Example 1:

Input: s = ""**|**|***|"", queries = [[2,5],[5,9]]
Output: [2,3]
Explanation:
- queries[0] has two plates between candles.
- queries[1] has three plates between candles.
Example 2:

Input: s = ""***|**|*****|**||**|*"", queries = [[1,17],[4,5],[14,17],[5,11],[15,16]]
Output: [9,0,0,0,0]
Explanation:
- queries[0] has nine plates between candles.
- The other queries have zero plates between candles.
",,False
Smallest Index With Equal Value,"Given a 0-indexed integer array nums, return the smallest index i of nums such that i mod 10 == nums[i], or -1 if such index does not exist.
x mod y denotes the remainder when x is divided by y.
","Example 1:
Input: nums = [0,1,2]
Output: 0
Explanation: 
i=0: 0 mod 10 = 0 == nums[0].
i=1: 1 mod 10 = 1 == nums[1].
i=2: 2 mod 10 = 2 == nums[2].
All indices have i mod 10 == nums[i], so we return the smallest index 0.
Example 2:
Input: nums = [4,3,2,1]
Output: 2
Explanation: 
i=0: 0 mod 10 = 0 != nums[0].
i=1: 1 mod 10 = 1 != nums[1].
i=2: 2 mod 10 = 2 == nums[2].
i=3: 3 mod 10 = 3 != nums[3].
2 is the only index which has i mod 10 == nums[i].
Example 3:
Input: nums = [1,2,3,4,5,6,7,8,9,0]
Output: -1
Explanation: No index satisfies i mod 10 == nums[i].
","class Solution:
    def smallestEqual(self, nums: List[int]) -> int:
        for i , num in enumerate(nums):
            if i % 10 == num:
                return i
        return -1
        
",True
Minimum Operations to Convert Number,"You are given a 0-indexed integer array nums containing distinct numbers, an integer start, and an integer goal. There is an integer x that is initially set to start, and you want to perform operations on x such that it is converted to goal. You can perform the following operation repeatedly on the number x:
If 0 <= x <= 1000, then for any index i in the array (0 <= i < nums.length), you can set x to any of the following:
x + nums[i]
x - nums[i]
x ^ nums[i] (bitwise-XOR)
Note that you can use each nums[i] any number of times in any order. Operations that set x to be out of the range 0 <= x <= 1000 are valid, but no more operations can be done afterward.
Return the minimum number of operations needed to convert x = start into goal, and -1 if it is not possible.
","Example 1:
Input: nums = [2,4,12], start = 2, goal = 12
Output: 2
Explanation: We can go from 2 → 14 → 12 with the following 2 operations.
- 2 + 12 = 14
- 14 - 2 = 12
Example 2:
Input: nums = [3,5,7], start = 0, goal = -4
Output: 2
Explanation: We can go from 0 → 3 → -4 with the following 2 operations. 
- 0 + 3 = 3
- 3 - 7 = -4
Note that the last operation sets x out of the range 0 <= x <= 1000, which is valid.
Example 3:
Input: nums = [2,8,16], start = 0, goal = 1
Output: -1
Explanation: There is no way to convert 0 into 1.
","class Solution:
    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:
        s1, s2, d, seen = {start}, {goal}, 0, set()
        while s1 and s2:
            if len(s1) < len(s2):
                s1, s2 = s2, s1
            
            new = set()
            for x in s1:
                for num in nums:
                    if x+num in s2:
                        return d+1
                    if x-num in s2:
                        return d+1
                    if x^num in s2:
                        return d+1
                    
                    if 0 <= x+num <= 1000:
                        if not x+num in seen:
                            seen.add(x+num)
                            new.add(x+num)
                    if 0 <= x-num <= 1000:
                        if not x-num in seen:
                            seen.add(x-num)
                            new.add(x-num)
                    if 0 <= x^num <= 1000:
                        if not x^num in seen:
                            seen.add(x^num)
                            new.add(x^num)
            d += 1
            s1 = new
        return -1",True
Count Common Words With One Occurrence,"Given two string arrays words1 and words2, return the number of strings that appear exactly once in each of the two arrays.
","Example 1:
Input: words1 = [""leetcode"",""is"",""amazing"",""as"",""is""], words2 = [""amazing"",""leetcode"",""is""]
Output: 2
Explanation:
- ""leetcode"" appears exactly once in each of the two arrays. We count this string.
- ""amazing"" appears exactly once in each of the two arrays. We count this string.
- ""is"" appears in each of the two arrays, but there are 2 occurrences of it in words1. We do not count this string.
- ""as"" appears once in words1, but does not appear in words2. We do not count this string.
Thus, there are 2 strings that appear exactly once in each of the two arrays.
Example 2:
Input: words1 = [""b"",""bb"",""bbb""], words2 = [""a"",""aa"",""aaa""]
Output: 0
Explanation: There are no strings that appear in each of the two arrays.
Example 3:
Input: words1 = [""a"",""ab""], words2 = [""a"",""a"",""a"",""ab""]
Output: 1
Explanation: The only string that appears exactly once in each of the two arrays is ""ab"".
","class Solution:
    def countWords(self, words1: List[str], words2: List[str]) -> int:
        count=0

        for i in words1:
            if words1.count(i)==1 and words2.count(i)==1:
                count=count+1

        return count",True
Time Needed to Buy Tickets,"There are n people in a line queuing to buy tickets, where the 0th person is at the front of the line and the (n - 1)th person is at the back of the line.
You are given a 0-indexed integer array tickets of length n where the number of tickets that the ith person would like to buy is tickets[i].
Each person takes exactly 1 second to buy a ticket. A person can only buy 1 ticket at a time and has to go back to the end of the line (which happens instantaneously) in order to buy more tickets. If a person does not have any tickets left to buy, the person will leave the line.
Return the time taken for the person at position k (0-indexed) to finish buying tickets.
","Example 1:
Input: tickets = [2,3,2], k = 2
Output: 6
Explanation: 
- In the first pass, everyone in the line buys a ticket and the line becomes [1, 2, 1].
- In the second pass, everyone in the line buys a ticket and the line becomes [0, 1, 0].
The person at position 2 has successfully bought 2 tickets and it took 3 + 3 = 6 seconds.
Example 2:
Input: tickets = [5,1,1,1], k = 0
Output: 8
Explanation:
- In the first pass, everyone in the line buys a ticket and the line becomes [4, 0, 0, 0].
- In the next 4 passes, only the person in position 0 is buying tickets.
The person at position 0 has successfully bought 5 tickets and it took 4 + 1 + 1 + 1 + 1 = 8 seconds.
","class Solution:
    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:
        total = 0

        for i, x in enumerate(tickets):
            if i <= k:
                total += min(tickets[i], tickets[k])
            else:
                total += min(tickets[i], tickets[k] - 1)

        return total",True
Find Subsequence of Length K With the Largest Sum,"You are given an integer array nums and an integer k. You want to find a subsequence of nums of length k that has the largest sum.
Return any such subsequence as an integer array of length k.
A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.
","Example 1:
Input: nums = [2,1,3,3], k = 2
Output: [3,3]
Explanation:
The subsequence has the largest sum of 3 + 3 = 6.
Example 2:
Input: nums = [-1,-2,3,4], k = 3
Output: [-1,3,4]
Explanation: 
The subsequence has the largest sum of -1 + 3 + 4 = 6.
Example 3:
Input: nums = [3,4,3,3], k = 2
Output: [3,4]
Explanation:
The subsequence has the largest sum of 3 + 4 = 7. 
Another possible subsequence is [4, 3].
","class Solution:
    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:
        tuple_heap = [] # Stores (value, index) as min heap
        for i, val in enumerate(nums):
            if len(tuple_heap) == k:
                heappushpop(tuple_heap, (val, i)) # To prevent size of heap growing larger than k
            else:
                heappush(tuple_heap, (val, i))
		# heap now contains only the k largest elements with their indices as well.
        tuple_heap.sort(key=lambda x: x[1]) # To get the original order of values. That is why we sort it by index(x[1]) & not value(x[0])
        ans = []
        for i in tuple_heap:
            ans.append(i[0])
        return ans",True
Detonate the Maximum Bombs,"You are given a list of bombs. The range of a bomb is defined as the area where its effect can be felt. This area is in the shape of a circle with the center as the location of the bomb.
The bombs are represented by a 0-indexed 2D integer array bombs where bombs[i] = [xi, yi, ri]. xi and yi denote the X-coordinate and Y-coordinate of the location of the ith bomb, whereas ri denotes the radius of its range.
You may choose to detonate a single bomb. When a bomb is detonated, it will detonate all bombs that lie in its range. These bombs will further detonate the bombs that lie in their ranges.
Given the list of bombs, return the maximum number of bombs that can be detonated if you are allowed to detonate only one bomb.
","Example 1:

Input: bombs = [[2,1,3],[6,1,4]]
Output: 2
Explanation:
The above figure shows the positions and ranges of the 2 bombs.
If we detonate the left bomb, the right bomb will not be affected.
But if we detonate the right bomb, both bombs will be detonated.
So the maximum bombs that can be detonated is max(1, 2) = 2.
Example 2:

Input: bombs = [[1,1,5],[10,10,5]]
Output: 1
Explanation:
Detonating either bomb will not detonate the other bomb, so the maximum number of bombs that can be detonated is 1.
Example 3:

Input: bombs = [[1,2,3],[2,3,1],[3,4,2],[4,5,3],[5,6,4]]
Output: 5
Explanation:
The best bomb to detonate is bomb 0 because:
- Bomb 0 detonates bombs 1 and 2. The red circle denotes the range of bomb 0.
- Bomb 2 detonates bomb 3. The blue circle denotes the range of bomb 2.
- Bomb 3 detonates bomb 4. The green circle denotes the range of bomb 3.
Thus all 5 bombs are detonated.
","class Solution:
    def maximumDetonation(self, bombs: List[List[int]]) -> int:
        n=len(bombs)
        connected=[ [] for i in range(n)]

        for i in range(n):
            sm=[]
            for j in range(n):
                if j!=i:
                    xi, yi, ri = bombs[i]
                    xj, yj, _ = bombs[j]
                    if ri ** 2 >= (xi - xj) ** 2 + (yi - yj) ** 2:
                        sm.append(j)
            connected[i]=sm
        
        res=[]

        visited=[]
        def dfs(i:int):

            if i not in visited:
                visited.append(i)
                for j in connected[i]:
                    dfs(j)
                

        for i in range(n):
            visited.append(i)
            for j in connected[i]:
                dfs(j)
            res.append(len(visited))
            visited.clear()

        return max(res)
        
 ",True
Find Target Indices After Sorting Array,"You are given a 0-indexed integer array nums and a target element target.
A target index is an index i such that nums[i] == target.
Return a list of the target indices of nums after sorting nums in non-decreasing order. If there are no target indices, return an empty list. The returned list must be sorted in increasing order.
","Example 1:
Input: nums = [1,2,5,2,3], target = 2
Output: [1,2]
Explanation: After sorting, nums is [1,2,2,3,5].
The indices where nums[i] == 2 are 1 and 2.
Example 2:
Input: nums = [1,2,5,2,3], target = 3
Output: [3]
Explanation: After sorting, nums is [1,2,2,3,5].
The index where nums[i] == 3 is 3.
Example 3:
Input: nums = [1,2,5,2,3], target = 5
Output: [4]
Explanation: After sorting, nums is [1,2,2,3,5].
The index where nums[i] == 5 is 4.
","class Solution:
    def targetIndices(self, nums, target):
        idx = sum(num < target  for num in nums)
        cnt = sum(num == target for num in nums)
        return list(range(idx, idx+cnt))",True
K Radius Subarray Averages,"You are given a 0-indexed array nums of n integers, and an integer k.
The k-radius average for a subarray of nums centered at some index i with the radius k is the average of all elements in nums between the indices i - k and i + k (inclusive). If there are less than k elements before or after the index i, then the k-radius average is -1.
Build and return an array avgs of length n where avgs[i] is the k-radius average for the subarray centered at index i.
The average of x elements is the sum of the x elements divided by x, using integer division. The integer division truncates toward zero, which means losing its fractional part.
For example, the average of four elements 2, 3, 1, and 5 is (2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75, which truncates to 2.
","Example 1:

Input: nums = [7,4,3,9,1,8,5,2,6], k = 3
Output: [-1,-1,-1,5,4,4,-1,-1,-1]
Explanation:
- avg[0], avg[1], and avg[2] are -1 because there are less than k elements before each index.
- The sum of the subarray centered at index 3 with radius 3 is: 7 + 4 + 3 + 9 + 1 + 8 + 5 = 37.
  Using integer division, avg[3] = 37 / 7 = 5.
- For the subarray centered at index 4, avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4.
- For the subarray centered at index 5, avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4.
- avg[6], avg[7], and avg[8] are -1 because there are less than k elements after each index.
Example 2:
Input: nums = [100000], k = 0
Output: [100000]
Explanation:
- The sum of the subarray centered at index 0 with radius 0 is: 100000.
  avg[0] = 100000 / 1 = 100000.
Example 3:
Input: nums = [8], k = 100000
Output: [-1]
Explanation: 
- avg[0] is -1 because there are less than k elements before and after index 0.
","class Solution {
public:
    vector<int> getAverages(vector<int>& nums, int k) {
        int n = nums.size(),i;
        long long int s=0;
        vector<int> ans(n,-1);
        for(i=0;i<n;i++){
            if(i<2*k){
                s+= nums[i];
            }else{
                s+=nums[i];
                ans[i-k] = s/(2*k+1);
                s -= nums[i-(2*k)];
            }
        }
        return ans;
    }
};",False
Maximum Number of Words Found in Sentences,"A sentence is a list of words that are separated by a single space with no leading or trailing spaces.
You are given an array of strings sentences, where each sentences[i] represents a single sentence.
Return the maximum number of words that appear in a single sentence.
","Example 1:
Input: sentences = [""alice and bob love leetcode"", ""i think so too"", ""this is great thanks very much""]
Output: 6
Explanation: 
- The first sentence, ""alice and bob love leetcode"", has 5 words in total.
- The second sentence, ""i think so too"", has 4 words in total.
- The third sentence, ""this is great thanks very much"", has 6 words in total.
Thus, the maximum number of words in a single sentence comes from the third sentence, which has 6 words.
Example 2:
Input: sentences = [""please wait"", ""continue to fight"", ""continue to win""]
Output: 3
Explanation: It is possible that multiple sentences contain the same number of words. 
In this example, the second and third sentences (underlined) have the same number of words.
","class Solution:
    def mostWordsFound(self, sentences: List[str]) -> int:
        a=[]
        for i in sentences:
            count=0
            for j in i:
                if(j=="" ""):
                    count+=1
            count+=1
            a.append(count)
        return (max(a))
            ",True
Find All Possible Recipes from Given Supplies,"You have information about n different recipes. You are given a string array recipes and a 2D string array ingredients. The ith recipe has the name recipes[i], and you can create it if you have all the needed ingredients from ingredients[i]. Ingredients to a recipe may need to be created from other recipes, i.e., ingredients[i] may contain a string that is in recipes.
You are also given a string array supplies containing all the ingredients that you initially have, and you have an infinite supply of all of them.
Return a list of all the recipes that you can create. You may return the answer in any order.
Note that two recipes may contain each other in their ingredients.
","Example 1:
Input: recipes = [""bread""], ingredients = [[""yeast"",""flour""]], supplies = [""yeast"",""flour"",""corn""]
Output: [""bread""]
Explanation:
We can create ""bread"" since we have the ingredients ""yeast"" and ""flour"".
Example 2:
Input: recipes = [""bread"",""sandwich""], ingredients = [[""yeast"",""flour""],[""bread"",""meat""]], supplies = [""yeast"",""flour"",""meat""]
Output: [""bread"",""sandwich""]
Explanation:
We can create ""bread"" since we have the ingredients ""yeast"" and ""flour"".
We can create ""sandwich"" since we have the ingredient ""meat"" and can create the ingredient ""bread"".
Example 3:
Input: recipes = [""bread"",""sandwich"",""burger""], ingredients = [[""yeast"",""flour""],[""bread"",""meat""],[""sandwich"",""meat"",""bread""]], supplies = [""yeast"",""flour"",""meat""]
Output: [""bread"",""sandwich"",""burger""]
Explanation:
We can create ""bread"" since we have the ingredients ""yeast"" and ""flour"".
We can create ""sandwich"" since we have the ingredient ""meat"" and can create the ingredient ""bread"".
We can create ""burger"" since we have the ingredient ""meat"" and can create the ingredients ""bread"" and ""sandwich"".
","class Solution:
    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:
        # indegree = {""bread"" : 2}
        indegree = defaultdict(int)
        # graph = {""flour"" : [""bread"", "" "", """"]}
        graph = defaultdict(list)
        for recipe, ing in zip(recipes, ingredients):
            for i in ing:
                indegree[recipe] += 1
                graph[i].append(recipe)
        
        answer = []
        queue = deque(supplies)
        recipes = set(recipes)
        while queue:
            x = queue.popleft()
            if x in recipes:
                answer.append(x)
            for i in graph[x]:
                indegree[i] -= 1
                if indegree[i] == 0:
                    queue.append(i)
        return answer",True
Find First Palindromic String in the Array,"Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string """".
A string is palindromic if it reads the same forward and backward.
","Example 1:
Input: words = [""abc"",""car"",""ada"",""racecar"",""cool""]
Output: ""ada""
Explanation: The first string that is palindromic is ""ada"".
Note that ""racecar"" is also palindromic, but it is not the first.
Example 2:
Input: words = [""notapalindrome"",""racecar""]
Output: ""racecar""
Explanation: The first and only string that is palindromic is ""racecar"".
Example 3:
Input: words = [""def"",""ghi""]
Output: """"
Explanation: There are no palindromic strings, so the empty string is returned.
",,False
Adding Spaces to a String,"You are given a 0-indexed string s and a 0-indexed integer array spaces that describes the indices in the original string where spaces will be added. Each space should be inserted before the character at the given index.
For example, given s = ""EnjoyYourCoffee"" and spaces = [5, 9], we place spaces before 'Y' and 'C', which are at indices 5 and 9 respectively. Thus, we obtain ""Enjoy Your Coffee"".
Return the modified string after the spaces have been added.
","Example 1:
Input: s = ""LeetcodeHelpsMeLearn"", spaces = [8,13,15]
Output: ""Leetcode Helps Me Learn""
Explanation: 
The indices 8, 13, and 15 correspond to the underlined characters in ""LeetcodeHelpsMeLearn"".
We then place spaces before those characters.
Example 2:
Input: s = ""icodeinpython"", spaces = [1,5,7,9]
Output: ""i code in py thon""
Explanation:
The indices 1, 5, 7, and 9 correspond to the underlined characters in ""icodeinpython"".
We then place spaces before those characters.
Example 3:
Input: s = ""spacing"", spaces = [0,1,2,3,4,5,6]
Output: "" s p a c i n g""
Explanation:
We are also able to place spaces before the first character of the string.
","class Solution:
    def addSpaces(self, s: str, spaces: List[int]) -> str:
        
        arr = []
        prev = 0
        for space in spaces:
            arr.append(s[prev:space])
            prev = space
        arr.append(s[space:])
       
        return "" "".join(arr)",True
Number of Laser Beams in a Bank,"Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.
There is one laser beam between any two security devices if both conditions are met:
The two devices are located on two different rows: r1 and r2, where r1 < r2.
For each row i where r1 < i < r2, there are no security devices in the ith row.
Laser beams are independent, i.e., one beam does not interfere nor join with another.
Return the total number of laser beams in the bank.
","Example 1:

Input: bank = [""011001"",""000000"",""010100"",""001000""]
Output: 8
Explanation: Between each of the following device pairs, there is one beam. In total, there are 8 beams:
 * bank[0][1] -- bank[2][1]
 * bank[0][1] -- bank[2][3]
 * bank[0][2] -- bank[2][1]
 * bank[0][2] -- bank[2][3]
 * bank[0][5] -- bank[2][1]
 * bank[0][5] -- bank[2][3]
 * bank[2][1] -- bank[3][2]
 * bank[2][3] -- bank[3][2]
Note that there is no beam between any device on the 0th row with any on the 3rd row.
This is because the 2nd row contains security devices, which breaks the second condition.
Example 2:

Input: bank = [""000"",""111"",""000""]
Output: 0
Explanation: There does not exist two devices located on two different rows.
","class Solution {
public:
    int numberOfBeams(vector<string>& bank) {
        vector<int>beams;
        for(auto i:bank){
            int sum=0;
            for(auto j:i)
                sum+=j-'0';
            if(sum)
                beams.push_back(sum);
        }    
        int n=beams.size();
        if(n<2) 
            return 0;
        int prev=beams[0];
        int ans=0;
        for(int i=1;i<n;i++){
            ans+=prev*beams[i];
            prev=beams[i];
        }
        return ans;
    }
};",False
Check if Every Row and Column Contains All Numbers,"An n x n matrix is valid if every row and every column contains all the integers from 1 to n (inclusive).
Given an n x n integer matrix matrix, return true if the matrix is valid. Otherwise, return false.
","Example 1:

Input: matrix = [[1,2,3],[3,1,2],[2,3,1]]
Output: true
Explanation: In this case, n = 3, and every row and column contains the numbers 1, 2, and 3.
Hence, we return true.
Example 2:

Input: matrix = [[1,1,1],[1,2,3],[1,2,3]]
Output: false
Explanation: In this case, n = 3, but the first row and the first column do not contain the numbers 2 or 3.
Hence, we return false.
","class Solution:
    def checkValid(self, matrix: List[List[int]]) -> bool:
        for r in range(len(matrix)):
            colSet = set()
            rowSet = set()
            for c in range(len(matrix)):
                if matrix[r][c] in colSet or matrix[c][r] in rowSet:
                    return False
                colSet.add(matrix[r][c])
                rowSet.add(matrix[c][r])
            
        return True",True
Solving Questions With Brainpower,"You are given a 0-indexed 2D integer array questions where questions[i] = [pointsi, brainpoweri].
The array describes the questions of an exam, where you have to process the questions in order (i.e., starting from question 0) and make a decision whether to solve or skip each question. Solving question i will earn you pointsi points but you will be unable to solve each of the next brainpoweri questions. If you skip question i, you get to make the decision on the next question.
For example, given questions = [[3, 2], [4, 3], [4, 4], [2, 5]]:
If question 0 is solved, you will earn 3 points but you will be unable to solve questions 1 and 2.
If instead, question 0 is skipped and question 1 is solved, you will earn 4 points but you will be unable to solve questions 2 and 3.
Return the maximum points you can earn for the exam.
","Example 1:
Input: questions = [[3,2],[4,3],[4,4],[2,5]]
Output: 5
Explanation: The maximum points can be earned by solving questions 0 and 3.
- Solve question 0: Earn 3 points, will be unable to solve the next 2 questions
- Unable to solve questions 1 and 2
- Solve question 3: Earn 2 points
Total points earned: 3 + 2 = 5. There is no other way to earn 5 or more points.
Example 2:
Input: questions = [[1,1],[2,2],[3,3],[4,4],[5,5]]
Output: 7
Explanation: The maximum points can be earned by solving questions 1 and 4.
- Skip question 0
- Solve question 1: Earn 2 points, will be unable to solve the next 2 questions
- Unable to solve questions 2 and 3
- Solve question 4: Earn 5 points
Total points earned: 2 + 5 = 7. There is no other way to earn 7 or more points.
","class Solution:
    def mostPoints(self, q: List[List[int]]) -> int:
        @cache
        def dfs(i: int) -> int:
            return 0 if i >= len(q) else max(dfs(i + 1), q[i][0] + dfs(i + 1 + q[i][1]))
        return dfs(0)",True
Partition Array According to Given Pivot,"You are given a 0-indexed integer array nums and an integer pivot. Rearrange nums such that the following conditions are satisfied:
Every element less than pivot appears before every element greater than pivot.
Every element equal to pivot appears in between the elements less than and greater than pivot.
The relative order of the elements less than pivot and the elements greater than pivot is maintained.
More formally, consider every pi, pj where pi is the new position of the ith element and pj is the new position of the jth element. For elements less than pivot, if i < j and nums[i] < pivot and nums[j] < pivot, then pi < pj. Similarly for elements greater than pivot, if i < j and nums[i] > pivot and nums[j] > pivot, then pi < pj.
Return nums after the rearrangement.
","Example 1:
Input: nums = [9,12,5,10,14,3,10], pivot = 10
Output: [9,5,3,10,10,12,14]
Explanation: 
The elements 9, 5, and 3 are less than the pivot so they are on the left side of the array.
The elements 12 and 14 are greater than the pivot so they are on the right side of the array.
The relative ordering of the elements less than and greater than pivot is also maintained. [9, 5, 3] and [12, 14] are the respective orderings.
Example 2:
Input: nums = [-3,4,3,2], pivot = 2
Output: [-3,2,4,3]
Explanation: 
The element -3 is less than the pivot so it is on the left side of the array.
The elements 4 and 3 are greater than the pivot so they are on the right side of the array.
The relative ordering of the elements less than and greater than pivot is also maintained. [-3] and [4, 3] are the respective orderings.
","class Solution:
    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:
        lst,val,tmp=[],[],[]
        for i in nums:
            if i==pivot:val.append(i)
            elif i<pivot:lst.append(i)
            else:tmp.append(i)
        return lst+val+tmp",True
Count Elements With Strictly Smaller and Greater Elements ,"Given an integer array nums, return the number of elements that have both a strictly smaller and a strictly greater element appear in nums.
","Example 1:
Input: nums = [11,7,2,15]
Output: 2
Explanation: The element 7 has the element 2 strictly smaller than it and the element 11 strictly greater than it.
Element 11 has element 7 strictly smaller than it and element 15 strictly greater than it.
In total there are 2 elements having both a strictly smaller and a strictly greater element appear in nums.
Example 2:
Input: nums = [-3,3,3,90]
Output: 2
Explanation: The element 3 has the element -3 strictly smaller than it and the element 90 strictly greater than it.
Since there are two elements with the value 3, in total there are 2 elements having both a strictly smaller and a strictly greater element appear in nums.
","class Solution:
    def countElements(self, nums: List[int]) -> int:
        maxval=max(nums)
        minval=min(nums)
        while maxval in nums:
            nums.remove(maxval)
        while minval in nums:
            nums.remove(minval)
        return len(nums)
        #please do upvote it would be encouraging to post more solutions.
",True
Rearrange Array Elements by Sign,"You are given a 0-indexed integer array nums of even length consisting of an equal number of positive and negative integers.
You should return the array of nums such that the the array follows the given conditions:
Every consecutive pair of integers have opposite signs.
For all integers with the same sign, the order in which they were present in nums is preserved.
The rearranged array begins with a positive integer.
Return the modified array after rearranging the elements to satisfy the aforementioned conditions.
","Example 1:
Input: nums = [3,1,-2,-5,2,-4]
Output: [3,-2,1,-5,2,-4]
Explanation:
The positive integers in nums are [3,1,2]. The negative integers are [-2,-5,-4].
The only possible way to rearrange them such that they satisfy all conditions is [3,-2,1,-5,2,-4].
Other ways such as [1,-2,2,-5,3,-4], [3,1,2,-2,-5,-4], [-2,3,-5,1,-4,2] are incorrect because they do not satisfy one or more conditions.  
Example 2:
Input: nums = [-1,1]
Output: [1,-1]
Explanation:
1 is the only positive integer and -1 the only negative integer in nums.
So nums is rearranged to [1,-1].
","class Solution:
    def rearrangeArray(self, nums: List[int]) -> List[int]:
        pos, neg = [], []

        for n in nums:
            if n > 0:
                pos.append(n)
            else:
                neg.append(n)
        
        res = [0] * len(nums)
        res[0 : len(pos) * 2 : 2] = pos
        res[1 : len(neg) * 2 : 2] = neg

        return res",True
Keep Multiplying Found Values by Two,"You are given an array of integers nums. You are also given an integer original which is the first number that needs to be searched for in nums.
You then do the following steps:
If original is found in nums, multiply it by two (i.e., set original = 2 * original).
Otherwise, stop the process.
Repeat this process with the new number as long as you keep finding the number.
Return the final value of original.
","Example 1:
Input: nums = [5,3,6,1,12], original = 3
Output: 24
Explanation: 
- 3 is found in nums. 3 is multiplied by 2 to obtain 6.
- 6 is found in nums. 6 is multiplied by 2 to obtain 12.
- 12 is found in nums. 12 is multiplied by 2 to obtain 24.
- 24 is not found in nums. Thus, 24 is returned.
Example 2:
Input: nums = [2,7,9], original = 4
Output: 4
Explanation:
- 4 is not found in nums. Thus, 4 is returned.
",,False
Count Equal and Divisible Pairs in an Array,"0-indexed
nums
n
k
the number of pairs
(i, j)
where
0 <= i < j < n
such that
nums[i] == nums[j]
and
(i * j)
is divisible by
k
","Example 1:
Input: nums = [3,1,2,2,2,1,3], k = 2
Output: 4
Explanation:
There are 4 pairs that meet all the requirements:
- nums[0] == nums[6], and 0 * 6 == 0, which is divisible by 2.
- nums[2] == nums[3], and 2 * 3 == 6, which is divisible by 2.
- nums[2] == nums[4], and 2 * 4 == 8, which is divisible by 2.
- nums[3] == nums[4], and 3 * 4 == 12, which is divisible by 2.
Example 2:
Input: nums = [1,2,3,4], k = 1
Output: 0
Explanation: Since no value in nums is repeated, there are no pairs (i,j) that meet all the requirements.
","class Solution:
    def countPairs(self, nums: List[int], k: int) -> int:
        c=0
        for i in range(len(nums)):
            for j in range(i+1,len(nums)):
                if nums[i]==nums[j] and (i*j)%k==0:
                    c+=1
        return c",True
Sort Even and Odd Indices Independently,"You are given a 0-indexed integer array nums. Rearrange the values of nums according to the following rules:
Sort the values at odd indices of nums in non-increasing order.
For example, if nums = [4,1,2,3] before this step, it becomes [4,3,2,1] after. The values at odd indices 1 and 3 are sorted in non-increasing order.
Sort the values at even indices of nums in non-decreasing order.
For example, if nums = [4,1,2,3] before this step, it becomes [2,1,4,3] after. The values at even indices 0 and 2 are sorted in non-decreasing order.
Return the array formed after rearranging the values of nums.
","Example 1:
Input: nums = [4,1,2,3]
Output: [2,3,4,1]
Explanation: 
First, we sort the values present at odd indices (1 and 3) in non-increasing order.
So, nums changes from [4,1,2,3] to [4,3,2,1].
Next, we sort the values present at even indices (0 and 2) in non-decreasing order.
So, nums changes from [4,1,2,3] to [2,3,4,1].
Thus, the array formed after rearranging the values is [2,3,4,1].
Example 2:
Input: nums = [2,1]
Output: [2,1]
Explanation: 
Since there is exactly one odd index and one even index, no rearrangement of values takes place.
The resultant array formed is [2,1], which is the same as the initial array. 
",,False
Counting Words With a Given Prefix,"You are given an array of strings words and a string pref.
Return the number of strings in words that contain pref as a prefix.
A prefix of a string s is any leading contiguous substring of s.
","Example 1:
Input: words = [""pay"",""attention"",""practice"",""attend""], pref = ""at""
Output: 2
Explanation: The 2 strings that contain ""at"" as a prefix are: ""attention"" and ""attend"".
Example 2:
Input: words = [""leetcode"",""win"",""loops"",""success""], pref = ""code""
Output: 0
Explanation: There are no strings that contain ""code"" as a prefix.
",,False
Minimum Time to Complete Trips,"You are given an array time where time[i] denotes the time taken by the ith bus to complete one trip.
Each bus can make multiple trips successively; that is, the next trip can start immediately after completing the current trip. Also, each bus operates independently; that is, the trips of one bus do not influence the trips of any other bus.
You are also given an integer totalTrips, which denotes the number of trips all buses should make in total. Return the minimum time required for all buses to complete at least totalTrips trips.
","Example 1:
Input: time = [1,2,3], totalTrips = 5
Output: 3
Explanation:
- At time t = 1, the number of trips completed by each bus are [1,0,0]. 
  The total number of trips completed is 1 + 0 + 0 = 1.
- At time t = 2, the number of trips completed by each bus are [2,1,0]. 
  The total number of trips completed is 2 + 1 + 0 = 3.
- At time t = 3, the number of trips completed by each bus are [3,1,1]. 
  The total number of trips completed is 3 + 1 + 1 = 5.
So the minimum time needed for all buses to complete at least 5 trips is 3.
Example 2:
Input: time = [2], totalTrips = 1
Output: 2
Explanation:
There is only one bus, and it will complete its first trip at t = 2.
So the minimum time needed to complete 1 trip is 2.
","class Solution:
    def minimumTime(self, time: List[int], totalTrips: int) -> int:
        #binary search
        def checkIfTotalTripsCanHappen(timee):
            trips=0
            for i in time:
                trips+=(timee//i)
            return trips>=totalTrips
        #print(checkIfTotalTripsCanHappen(3))
        #print(checkIfTotalTripsCanHappen(2))
        #print(checkIfTotalTripsCanHappen(4))

        left=1
        right=max(time)*totalTrips
        while(left<right):
            mid=left+(right-left)//2
            if(checkIfTotalTripsCanHappen(mid)):
                right=mid
            else:
                left=mid+1
        return left",True
Divide Array Into Equal Pairs,"You are given an integer array nums consisting of 2 * n integers.
You need to divide nums into n pairs such that:
Each element belongs to exactly one pair.
The elements present in a pair are equal.
Return true if nums can be divided into n pairs, otherwise return false.
","Example 1:
Input: nums = [3,2,3,2,2,2]
Output: true
Explanation: 
There are 6 elements in nums, so they should be divided into 6 / 2 = 3 pairs.
If nums is divided into the pairs (2, 2), (3, 3), and (2, 2), it will satisfy all the conditions.
Example 2:
Input: nums = [1,2,3,4]
Output: false
Explanation: 
There is no way to divide nums into 4 / 2 = 2 pairs such that the pairs satisfy every condition.
",,False
Most Frequent Number Following Key In an Array,"You are given a 0-indexed integer array nums. You are also given an integer key, which is present in nums.
For every unique integer target in nums, count the number of times target immediately follows an occurrence of key in nums. In other words, count the number of indices i such that:
0 <= i <= nums.length - 2,
nums[i] == key and,
nums[i + 1] == target.
Return the target with the maximum count. The test cases will be generated such that the target with maximum count is unique.
","Example 1:
Input: nums = [1,100,200,1,100], key = 1
Output: 100
Explanation: For target = 100, there are 2 occurrences at indices 1 and 4 which follow an occurrence of key.
No other integers follow an occurrence of key, so we return 100.
Example 2:
Input: nums = [2,2,2,2,3], key = 2
Output: 2
Explanation: For target = 2, there are 3 occurrences at indices 1, 2, and 3 which follow an occurrence of key.
For target = 3, there is only one occurrence at index 4 which follows an occurrence of key.
target = 2 has the maximum number of occurrences following an occurrence of key, so we return 2.
","class Solution:
    def mostFrequent(self, nums: list[int], key: int) -> int:
        hash = { }
        l = len(nums)
        res = [float('-inf'), float('-inf')]
        for n in range(l - 1):
            if nums[n] == key:
                if nums[n + 1] in hash:
                    hash[nums[n + 1]] += 1
                else:
                    hash[nums[n + 1]] = 1
        for n in hash:
            if hash[n] > res[1]:
                res[1] = hash[n]
                res[0] = n

        return res[0]
        ",True
Count Hills and Valleys in an Array,"You are given a 0-indexed integer array nums. An index i is part of a hill in nums if the closest non-equal neighbors of i are smaller than nums[i]. Similarly, an index i is part of a valley in nums if the closest non-equal neighbors of i are larger than nums[i]. Adjacent indices i and j are part of the same hill or valley if nums[i] == nums[j].
Note that for an index to be part of a hill or valley, it must have a non-equal neighbor on both the left and right of the index.
Return the number of hills and valleys in nums.
","Example 1:
Input: nums = [2,4,1,1,6,5]
Output: 3
Explanation:
At index 0: There is no non-equal neighbor of 2 on the left, so index 0 is neither a hill nor a valley.
At index 1: The closest non-equal neighbors of 4 are 2 and 1. Since 4 > 2 and 4 > 1, index 1 is a hill. 
At index 2: The closest non-equal neighbors of 1 are 4 and 6. Since 1 < 4 and 1 < 6, index 2 is a valley.
At index 3: The closest non-equal neighbors of 1 are 4 and 6. Since 1 < 4 and 1 < 6, index 3 is a valley, but note that it is part of the same valley as index 2.
At index 4: The closest non-equal neighbors of 6 are 1 and 5. Since 6 > 1 and 6 > 5, index 4 is a hill.
At index 5: There is no non-equal neighbor of 5 on the right, so index 5 is neither a hill nor a valley. 
There are 3 hills and valleys so we return 3.
Example 2:
Input: nums = [6,6,5,5,4,1]
Output: 0
Explanation:
At index 0: There is no non-equal neighbor of 6 on the left, so index 0 is neither a hill nor a valley.
At index 1: There is no non-equal neighbor of 6 on the left, so index 1 is neither a hill nor a valley.
At index 2: The closest non-equal neighbors of 5 are 6 and 4. Since 5 < 6 and 5 > 4, index 2 is neither a hill nor a valley.
At index 3: The closest non-equal neighbors of 5 are 6 and 4. Since 5 < 6 and 5 > 4, index 3 is neither a hill nor a valley.
At index 4: The closest non-equal neighbors of 4 are 5 and 1. Since 4 < 5 and 4 > 1, index 4 is neither a hill nor a valley.
At index 5: There is no non-equal neighbor of 1 on the right, so index 5 is neither a hill nor a valley.
There are 0 hills and valleys so we return 0.
","class Solution:
    def countHillValley(self, nums: List[int]) -> int:
        hill_or_valleys = 0
        last_dir = ''
        for i in range(1, len(nums)):
            diff = nums[i] - nums[i-1]
            if diff == 0:
                continue
            elif diff > 0: # increasing
                if not last_dir or last_dir != 'UP':
                    hill_or_valleys += 1
                    last_dir = 'UP'
            else: # descreasing
                if not last_dir or last_dir != 'DOWN':
                    hill_or_valleys += 1
                    last_dir = 'DOWN'
        return max(0, hill_or_valleys - 1)",True
Find All K-Distant Indices in an Array,"You are given a 0-indexed integer array nums and two integers key and k. A k-distant index is an index i of nums for which there exists at least one index j such that |i - j| <= k and nums[j] == key.
Return a list of all k-distant indices sorted in increasing order.
","Example 1:
Input: nums = [3,4,9,1,3,9,5], key = 9, k = 1
Output: [1,2,3,4,5,6]
Explanation: Here, nums[2] == key and nums[5] == key.
- For index 0, |0 - 2| > k and |0 - 5| > k, so there is no j where |0 - j| <= k and nums[j] == key. Thus, 0 is not a k-distant index.
- For index 1, |1 - 2| <= k and nums[2] == key, so 1 is a k-distant index.
- For index 2, |2 - 2| <= k and nums[2] == key, so 2 is a k-distant index.
- For index 3, |3 - 2| <= k and nums[2] == key, so 3 is a k-distant index.
- For index 4, |4 - 5| <= k and nums[5] == key, so 4 is a k-distant index.
- For index 5, |5 - 5| <= k and nums[5] == key, so 5 is a k-distant index.
- For index 6, |6 - 5| <= k and nums[5] == key, so 6 is a k-distant index.
Thus, we return [1,2,3,4,5,6] which is sorted in increasing order. 
Example 2:
Input: nums = [2,2,2,2,2], key = 2, k = 2
Output: [0,1,2,3,4]
Explanation: For all indices i in nums, there exists some index j such that |i - j| <= k and nums[j] == key, so every index is a k-distant index. 
Hence, we return [0,1,2,3,4].
","class Solution:
    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:
        ans = set()
        for i, num in enumerate(nums):
            if num == key:
                ans.update(range(max(0, i-k), min(i+k+1, len(nums))))
        return sorted(list(res))",True
Intersection of Multiple Arrays,"nums
nums[i]
distinct
the list of integers that are present in each array of
nums
sorted in ascending order
","Example 1:
Input: nums = [[3,1,2,4,5],[1,2,3,4],[3,4,5,6]]
Output: [3,4]
Explanation: 
The only integers present in each of nums[0] = [3,1,2,4,5], nums[1] = [1,2,3,4], and nums[2] = [3,4,5,6] are 3 and 4, so we return [3,4].
Example 2:
Input: nums = [[1,2,3],[4,5,6]]
Output: []
Explanation: 
There does not exist any integer present both in nums[0] and nums[1], so we return an empty list [].
","class Solution {
public:
    vector<int> intersection(vector<vector<int>>& nums) {
      unordered_map<int,int>mp;
      for(auto it:nums)
      {
        for(auto i:it)
        {
            mp[i]++;
        }
      }
      int n= nums.size();
      vector<int>ans;
      for(auto it:mp)
      {
        if(it.second==n)
        {
            ans.push_back(it.first);
        }
      }
      sort(ans.begin(),ans.end());
      return ans;
    }
};",False
Count Prefixes of a Given String,"You are given a string array words and a string s, where words[i] and s comprise only of lowercase English letters.
Return the number of strings in words that are a prefix of s.
A prefix of a string is a substring that occurs at the beginning of the string. A substring is a contiguous sequence of characters within a string.
","Example 1:
Input: words = [""a"",""b"",""c"",""ab"",""bc"",""abc""], s = ""abc""
Output: 3
Explanation:
The strings in words which are a prefix of s = ""abc"" are:
""a"", ""ab"", and ""abc"".
Thus the number of strings in words which are a prefix of s is 3.
Example 2:
Input: words = [""a"",""a""], s = ""aa""
Output: 2
Explanation:
Both of the strings are a prefix of s. 
Note that the same string can occur multiple times in words, and it should be counted each time.
","class Solution:
    def countPrefixes(self, words: List[str], s: str) -> int:
        count = 0
        for i in words:
            if s.startswith(i):
                count += 1
        return count

        #One Liner

        return sum(1 for i in words if s.startswith(i))",True
Minimum Rounds to Complete All Tasks,"You are given a 0-indexed integer array tasks, where tasks[i] represents the difficulty level of a task. In each round, you can complete either 2 or 3 tasks of the same difficulty level.
Return the minimum rounds required to complete all the tasks, or -1 if it is not possible to complete all the tasks.
","Example 1:
Input: tasks = [2,2,3,3,2,4,4,4,4,4]
Output: 4
Explanation: To complete all the tasks, a possible plan is:
- In the first round, you complete 3 tasks of difficulty level 2. 
- In the second round, you complete 2 tasks of difficulty level 3. 
- In the third round, you complete 3 tasks of difficulty level 4. 
- In the fourth round, you complete 2 tasks of difficulty level 4.  
It can be shown that all the tasks cannot be completed in fewer than 4 rounds, so the answer is 4.
Example 2:
Input: tasks = [2,3,3]
Output: -1
Explanation: There is only 1 task of difficulty level 2, but in each round, you can only complete either 2 or 3 tasks of the same difficulty level. Hence, you cannot complete all the tasks, and the answer is -1.
","class Solution {
public:
    int minimumRounds(vector<int>& tasks) {
        unordered_map<int, int> mp;
        for(auto x: tasks) mp[x]++;
        int ans = 0;
        for(auto x: mp) {
            if(x.second < 2) return -1;
            ans += ceil(1.0 * x.second / 3);
        }
        return ans;
    }
};",False
Maximum Bags With Full Capacity of Rocks,"You have n bags numbered from 0 to n - 1. You are given two 0-indexed integer arrays capacity and rocks. The ith bag can hold a maximum of capacity[i] rocks and currently contains rocks[i] rocks. You are also given an integer additionalRocks, the number of additional rocks you can place in any of the bags.
Return the maximum number of bags that could have full capacity after placing the additional rocks in some bags.
","Example 1:
Input: capacity = [2,3,4,5], rocks = [1,2,4,4], additionalRocks = 2
Output: 3
Explanation:
Place 1 rock in bag 0 and 1 rock in bag 1.
The number of rocks in each bag are now [2,3,4,4].
Bags 0, 1, and 2 have full capacity.
There are 3 bags at full capacity, so we return 3.
It can be shown that it is not possible to have more than 3 bags at full capacity.
Note that there may be other ways of placing the rocks that result in an answer of 3.
Example 2:
Input: capacity = [10,2,2], rocks = [2,2,0], additionalRocks = 100
Output: 3
Explanation:
Place 8 rocks in bag 0 and 2 rocks in bag 2.
The number of rocks in each bag are now [10,2,2].
Bags 0, 1, and 2 have full capacity.
There are 3 bags at full capacity, so we return 3.
It can be shown that it is not possible to have more than 3 bags at full capacity.
Note that we did not use all of the additional rocks.
","class Solution {
public:
    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {
        vector<int>ans;
        int cnt=0;
        for(int i=0;i<capacity.size();i++){
            ans.push_back(capacity[i]-rocks[i]);
        }
        sort(ans.begin(),ans.end());
        for(auto it:ans){
            if(it==0) cnt++;
            else if(it<=additionalRocks){
                cnt++;
                additionalRocks-=it;
            }
        }
        return cnt;
    }
};",False
Successful Pairs of Spells and Potions,"You are given two positive integer arrays spells and potions, of length n and m respectively, where spells[i] represents the strength of the ith spell and potions[j] represents the strength of the jth potion.
You are also given an integer success. A spell and potion pair is considered successful if the product of their strengths is at least success.
Return an integer array pairs of length n where pairs[i] is the number of potions that will form a successful pair with the ith spell.
","Example 1:
Input: spells = [5,1,3], potions = [1,2,3,4,5], success = 7
Output: [4,0,3]
Explanation:
- 0th spell: 5 * [1,2,3,4,5] = [5,10,15,20,25]. 4 pairs are successful.
- 1st spell: 1 * [1,2,3,4,5] = [1,2,3,4,5]. 0 pairs are successful.
- 2nd spell: 3 * [1,2,3,4,5] = [3,6,9,12,15]. 3 pairs are successful.
Thus, [4,0,3] is returned.
Example 2:
Input: spells = [3,1,2], potions = [8,5,8], success = 16
Output: [2,0,2]
Explanation:
- 0th spell: 3 * [8,5,8] = [24,15,24]. 2 pairs are successful.
- 1st spell: 1 * [8,5,8] = [8,5,8]. 0 pairs are successful. 
- 2nd spell: 2 * [8,5,8] = [16,10,16]. 2 pairs are successful. 
Thus, [2,0,2] is returned.
",,False
Equal Row and Column Pairs,"Given a 0-indexed n x n integer matrix grid, return the number of pairs (ri, cj) such that row ri and column cj are equal.
A row and column pair is considered equal if they contain the same elements in the same order (i.e., an equal array).
","Example 1:

Input: grid = [[3,2,1],[1,7,6],[2,7,7]]
Output: 1
Explanation: There is 1 equal row and column pair:
- (Row 2, Column 1): [2,7,7]
Example 2:

Input: grid = [[3,1,2,2],[1,4,4,5],[2,4,2,2],[2,4,2,2]]
Output: 3
Explanation: There are 3 equal row and column pairs:
- (Row 0, Column 0): [3,1,2,2]
- (Row 2, Column 2): [2,4,2,2]
- (Row 3, Column 2): [2,4,2,2]
","class Solution:
    def equalPairs(self, grid: List[List[int]]) -> int:
        gridset = defaultdict(int)
        rotatedgrid = list(zip(*grid))
        ans = 0
        for row in grid :
            gridset[tuple(row)] += 1
        for column in rotatedgrid :
            if column in gridset :
                ans += gridset[tuple(column)]
        return ans",True
Number of Zero-Filled Subarrays,"Given an integer array nums, return the number of subarrays filled with 0.
A subarray is a contiguous non-empty sequence of elements within an array.
","Example 1:
Input: nums = [1,3,0,0,2,0,0,4]
Output: 6
Explanation: 
There are 4 occurrences of [0] as a subarray.
There are 2 occurrences of [0,0] as a subarray.
There is no occurrence of a subarray with a size more than 2 filled with 0. Therefore, we return 6.
Example 2:
Input: nums = [0,0,0,2,0,0]
Output: 9
Explanation:
There are 5 occurrences of [0] as a subarray.
There are 3 occurrences of [0,0] as a subarray.
There is 1 occurrence of [0,0,0] as a subarray.
There is no occurrence of a subarray with a size more than 3 filled with 0. Therefore, we return 9.
Example 3:
Input: nums = [2,10,2019]
Output: 0
Explanation: There is no subarray filled with 0. Therefore, we return 0.
","class Solution:
    def zeroFilledSubarray(self, nums: List[int]) -> int:       
        number_of_zerosubs = 0
        counter = 0
        for i in nums:
            if not i:
                counter += 1
            elif counter:
                number_of_zerosubs += sum(range(1, counter+1))
                counter = 0
        if not nums[-1]:
            number_of_zerosubs += sum(range(1, counter+1))
        return number_of_zerosubs",True
Make Array Zero by Subtracting Equal Amounts,"You are given a non-negative integer array nums. In one operation, you must:
Choose a positive integer x such that x is less than or equal to the smallest non-zero element in nums.
Subtract x from every positive element in nums.
Return the minimum number of operations to make every element in nums equal to 0.
","Example 1:
Input: nums = [1,5,0,3,5]
Output: 3
Explanation:
In the first operation, choose x = 1. Now, nums = [0,4,0,2,4].
In the second operation, choose x = 2. Now, nums = [0,2,0,0,2].
In the third operation, choose x = 2. Now, nums = [0,0,0,0,0].
Example 2:
Input: nums = [0]
Output: 0
Explanation: Each element in nums is already 0 so no operations are needed.
",,False
Number of Arithmetic Triplets,"You are given a 0-indexed, strictly increasing integer array nums and a positive integer diff. A triplet (i, j, k) is an arithmetic triplet if the following conditions are met:
i < j < k,
nums[j] - nums[i] == diff, and
nums[k] - nums[j] == diff.
Return the number of unique arithmetic triplets.
","Example 1:
Input: nums = [0,1,4,6,7,10], diff = 3
Output: 2
Explanation:
(1, 2, 4) is an arithmetic triplet because both 7 - 4 == 3 and 4 - 1 == 3.
(2, 4, 5) is an arithmetic triplet because both 10 - 7 == 3 and 7 - 4 == 3. 
Example 2:
Input: nums = [4,5,6,7,8,9], diff = 2
Output: 2
Explanation:
(0, 2, 4) is an arithmetic triplet because both 8 - 6 == 2 and 6 - 4 == 2.
(1, 3, 5) is an arithmetic triplet because both 9 - 7 == 2 and 7 - 5 == 2.
","class Solution:
    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:
        dict_ = {}
        for num in nums:
            dict_[num] = dict_.get(num,0) + 1 ##To keep the count of each num's occurence
        
        count = 0
        for num in nums:
            if dict_.get(num+diff) and dict_.get(num+diff*2): #Check if any number with 3 and 6 more than present in dictionary
                count += 1
        return count",True
Check if There is a Valid Partition For The Array,"You are given a 0-indexed integer array nums. You have to partition the array into one or more contiguous subarrays.
We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions:
The subarray consists of exactly 2, equal elements. For example, the subarray [2,2] is good.
The subarray consists of exactly 3, equal elements. For example, the subarray [4,4,4] is good.
The subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1. For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not.
Return true if the array has at least one valid partition. Otherwise, return false.
","Example 1:
Input: nums = [4,4,4,5,6]
Output: true
Explanation: The array can be partitioned into the subarrays [4,4] and [4,5,6].
This partition is valid, so we return true.
Example 2:
Input: nums = [1,1,1,2]
Output: false
Explanation: There is no valid partition for this array.
","class Solution {
public:
    bool chk(int i, int j, vector<int> &a) {
        if (j - i == 1) {
            return a[i] == a[j];
        }
        else {
            if (a[i] == a[i + 1] && a[i + 1] == a[i + 2]) return 1;
            return a[i + 1] - a[i] == 1 && a[i + 2] - a[i + 1] == 1;
        }
        return 0;
    }

    bool f(int i, vector<int> &a, vector<int> &dp) {
        if (i > a.size()) return 0;
        if (i == a.size()) return 1;

        if (dp[i] != -1) return dp[idx];
        bool two = 0, three = 0;
        if(i < a.size() - 1 && chk(i, i + 1, a)) two = f(i + 2, a, dp);
        if(i < a.size() - 2 && chk(i, i + 2, a)) three = f(i + 3, a, dp);

        return dp[i] = aa || b;
    }
    
    bool validPartition(vector<int>& nums) {
        vector<int> dp(nums.size(), -1);
        return f(0, nums, dp);
    }
};",False
Merge Similar Items,"You are given two 2D integer arrays, items1 and items2, representing two sets of items. Each array items has the following properties:
items[i] = [valuei, weighti] where valuei represents the value and weighti represents the weight of the ith item.
The value of each item in items is unique.
Return a 2D integer array ret where ret[i] = [valuei, weighti], with weighti being the sum of weights of all items with value valuei.
Note: ret should be returned in ascending order by value.
","Example 1:
Input: items1 = [[1,1],[4,5],[3,8]], items2 = [[3,1],[1,5]]
Output: [[1,6],[3,9],[4,5]]
Explanation: 
The item with value = 1 occurs in items1 with weight = 1 and in items2 with weight = 5, total weight = 1 + 5 = 6.
The item with value = 3 occurs in items1 with weight = 8 and in items2 with weight = 1, total weight = 8 + 1 = 9.
The item with value = 4 occurs in items1 with weight = 5, total weight = 5.  
Therefore, we return [[1,6],[3,9],[4,5]].
Example 2:
Input: items1 = [[1,1],[3,2],[2,3]], items2 = [[2,1],[3,2],[1,3]]
Output: [[1,4],[2,4],[3,4]]
Explanation: 
The item with value = 1 occurs in items1 with weight = 1 and in items2 with weight = 3, total weight = 1 + 3 = 4.
The item with value = 2 occurs in items1 with weight = 3 and in items2 with weight = 1, total weight = 3 + 1 = 4.
The item with value = 3 occurs in items1 with weight = 2 and in items2 with weight = 2, total weight = 2 + 2 = 4.
Therefore, we return [[1,4],[2,4],[3,4]].
Example 3:
Input: items1 = [[1,3],[2,2]], items2 = [[7,1],[2,2],[1,4]]
Output: [[1,7],[2,4],[7,1]]
Explanation:
The item with value = 1 occurs in items1 with weight = 3 and in items2 with weight = 4, total weight = 3 + 4 = 7. 
The item with value = 2 occurs in items1 with weight = 2 and in items2 with weight = 2, total weight = 2 + 2 = 4. 
The item with value = 7 occurs in items2 with weight = 1, total weight = 1.
Therefore, we return [[1,7],[2,4],[7,1]].
","class Solution:
    def mergeSimilarItems(self, i1: List[List[int]], i2: List[List[int]]) -> List[List[int]]:
        return sorted((Counter({i[0] : i[1] for i in i1}) + Counter({i[0] : i[1] for i in i2})).items())",True
Largest Local Values in a Matrix,"You are given an n x n integer matrix grid.
Generate an integer matrix maxLocal of size (n - 2) x (n - 2) such that:
maxLocal[i][j] is equal to the largest value of the 3 x 3 matrix in grid centered around row i + 1 and column j + 1.
In other words, we want to find the largest value in every contiguous 3 x 3 matrix in grid.
Return the generated matrix.
","Example 1:

Input: grid = [[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]]
Output: [[9,9],[8,6]]
Explanation: The diagram above shows the original matrix and the generated matrix.
Notice that each value in the generated matrix corresponds to the largest value of a contiguous 3 x 3 matrix in grid.
Example 2:

Input: grid = [[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]]
Output: [[2,2,2],[2,2,2],[2,2,2]]
Explanation: Notice that the 2 is contained within every contiguous 3 x 3 matrix in grid.
","class Solution:
    def largestLocal(self, g: List[List[int]]) -> List[List[int]]:
        return [[max(g[i+p][j+q] for p,q in product(*[(0,1,2)]*2)) for j in range(len(g)-2)] for i in range(len(g)-2)]",True
Shifting Letters II,"You are given a string s of lowercase English letters and a 2D integer array shifts where shifts[i] = [starti, endi, directioni]. For every i, shift the characters in s from the index starti to the index endi (inclusive) forward if directioni = 1, or shift the characters backward if directioni = 0.
Shifting a character forward means replacing it with the next letter in the alphabet (wrapping around so that 'z' becomes 'a'). Similarly, shifting a character backward means replacing it with the previous letter in the alphabet (wrapping around so that 'a' becomes 'z').
Return the final string after all such shifts to s are applied.
","Example 1:
Input: s = ""abc"", shifts = [[0,1,0],[1,2,1],[0,2,1]]
Output: ""ace""
Explanation: Firstly, shift the characters from index 0 to index 1 backward. Now s = ""zac"".
Secondly, shift the characters from index 1 to index 2 forward. Now s = ""zbd"".
Finally, shift the characters from index 0 to index 2 forward. Now s = ""ace"".
Example 2:
Input: s = ""dztz"", shifts = [[0,0,0],[1,1,1]]
Output: ""catz""
Explanation: Firstly, shift the characters from index 0 to index 0 backward. Now s = ""cztz"".
Finally, shift the characters from index 1 to index 1 forward. Now s = ""catz"".
","class Solution:
    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:
        def update(a, x, y, p, v, l, r):
            """"""
            update at position p
            """"""
            if x>=r or l>=y:
                return             
            if x<=l and r<=y:
                tree[v][""full""] += p
                tree[v][""value""] += p * (r - l)
                return
      
            v1, v2 = (v<<1), (v<<1) +1
            m = (l + r)//2
            update(a, x, y, p, v1, l, m)
            update(a, x, y, p, v2, m, r)
            tree[v][""value""] = tree[v1][""value""] + tree[v2][""value""]
            pass # update      

        def query(a, x, y, p, v, l, r):
            """"""
            query on [x, y) in [0,n) of arr
            """"""
            if x>=r or l>=y:  # [x, y) intersection [l,r) = empty
                return 0
            if x<=l and r <= y: # // [l,r) is a subset of [x,y)
                return a[v][""value""] + p * (r - l)
            
            v1, v2 = (v<<1), (v<<1) +1
            p += a[v][""full""]
            m = (l + r) // 2
            q1 = query(a, x, y, p, v1, l, m)
            q2 = query(a, x, y, p, v2, m, r)
            return q1 + q2
            pass # query        
        
        n = len(s)
        tree = [{""value"": 0, ""full"": 0} for _ in range(4*n)]  # 
        shifts = sorted(shifts)
        s0, e0, d0 = shifts[0]
        p0 = 1 if d0==1 else -1
        for si, ei, di in shifts[1:]:
            pi = 1 if di==1 else -1
            if s0==si and e0==ei:
                p0 += pi
            elif e0+1==si and p0==pi:
                e0 = ei
            else:
                update(tree, s0, e0+1, p0, 1, 0, n)
                s0, e0, p0 = si, ei, pi
        update(tree, s0, e0+1, p0, 1, 0, n)

        ans = []
        for i in range(0, n):
            di = query(tree, i, i+1, 0, 1, 0, n)
            pi = (ord(s[i]) - ord('a') + di)%26 # (ord('z') - ord('a') + 1)
            ans.append(chr(ord('a') + pi))
        
        ans = """".join(ans)
        # print(ans)
        # print(""=""*20)
        return ans

print = lambda *a, **aa: ()",True
Longest Subsequence With Limited Sum,"You are given an integer array nums of length n, and an integer array queries of length m.
Return an array answer of length m where answer[i] is the maximum size of a subsequence that you can take from nums such that the sum of its elements is less than or equal to queries[i].
A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.
","Example 1:
Input: nums = [4,5,2,1], queries = [3,10,21]
Output: [2,3,4]
Explanation: We answer the queries as follows:
- The subsequence [2,1] has a sum less than or equal to 3. It can be proven that 2 is the maximum size of such a subsequence, so answer[0] = 2.
- The subsequence [4,5,1] has a sum less than or equal to 10. It can be proven that 3 is the maximum size of such a subsequence, so answer[1] = 3.
- The subsequence [4,5,2,1] has a sum less than or equal to 21. It can be proven that 4 is the maximum size of such a subsequence, so answer[2] = 4.
Example 2:
Input: nums = [2,3,4,5], queries = [1]
Output: [0]
Explanation: The empty subsequence is the only subsequence that has a sum less than or equal to 1, so answer[0] = 0.
",,False
Minimum Amount of Time to Collect Garbage,"You are given a 0-indexed array of strings garbage where garbage[i] represents the assortment of garbage at the ith house. garbage[i] consists only of the characters 'M', 'P' and 'G' representing one unit of metal, paper and glass garbage respectively. Picking up one unit of any type of garbage takes 1 minute.
You are also given a 0-indexed integer array travel where travel[i] is the number of minutes needed to go from house i to house i + 1.
There are three garbage trucks in the city, each responsible for picking up one type of garbage. Each garbage truck starts at house 0 and must visit each house in order; however, they do not need to visit every house.
Only one garbage truck may be used at any given moment. While one truck is driving or picking up garbage, the other two trucks cannot do anything.
Return the minimum number of minutes needed to pick up all the garbage.
","Example 1:
Input: garbage = [""G"",""P"",""GP"",""GG""], travel = [2,4,3]
Output: 21
Explanation:
The paper garbage truck:
1. Travels from house 0 to house 1
2. Collects the paper garbage at house 1
3. Travels from house 1 to house 2
4. Collects the paper garbage at house 2
Altogether, it takes 8 minutes to pick up all the paper garbage.
The glass garbage truck:
1. Collects the glass garbage at house 0
2. Travels from house 0 to house 1
3. Travels from house 1 to house 2
4. Collects the glass garbage at house 2
5. Travels from house 2 to house 3
6. Collects the glass garbage at house 3
Altogether, it takes 13 minutes to pick up all the glass garbage.
Since there is no metal garbage, we do not need to consider the metal garbage truck.
Therefore, it takes a total of 8 + 13 = 21 minutes to collect all the garbage.
Example 2:
Input: garbage = [""MMM"",""PGM"",""GP""], travel = [3,10]
Output: 37
Explanation:
The metal garbage truck takes 7 minutes to pick up all the metal garbage.
The paper garbage truck takes 15 minutes to pick up all the paper garbage.
The glass garbage truck takes 15 minutes to pick up all the glass garbage.
It takes a total of 7 + 15 + 15 = 37 minutes to collect all the garbage.
","class Solution:
    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:
        G = P = M = 0
        n = len(garbage)
        for i in range(n-1,0,-1):
            if ""G"" in garbage[i]:
                G = i
                break
        for i in range(n-1,0,-1):
            if ""P"" in garbage[i]:
                P = i
                break
        for i in range(n-1,0,-1):
            if ""M"" in garbage[i]:
                M = i
                break

        sum = 0
        #calculate distance:
        for i in travel[0:G]:
            sum+=i
        for i in travel[0:P]:
            sum+=i
        for i in travel[0:M]:
            sum+=i
        for i in garbage:
            sum+=len(i)
        return sum",True
Check Distances Between Same Letters,"You are given a 0-indexed string s consisting of only lowercase English letters, where each letter in s appears exactly twice. You are also given a 0-indexed integer array distance of length 26.
Each letter in the alphabet is numbered from 0 to 25 (i.e. 'a' -> 0, 'b' -> 1, 'c' -> 2, ... , 'z' -> 25).
In a well-spaced string, the number of letters between the two occurrences of the ith letter is distance[i]. If the ith letter does not appear in s, then distance[i] can be ignored.
Return true if s is a well-spaced string, otherwise return false.
","Example 1:
Input: s = ""abaccb"", distance = [1,3,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Output: true
Explanation:
- 'a' appears at indices 0 and 2 so it satisfies distance[0] = 1.
- 'b' appears at indices 1 and 5 so it satisfies distance[1] = 3.
- 'c' appears at indices 3 and 4 so it satisfies distance[2] = 0.
Note that distance[3] = 5, but since 'd' does not appear in s, it can be ignored.
Return true because s is a well-spaced string.
Example 2:
Input: s = ""aa"", distance = [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Output: false
Explanation:
- 'a' appears at indices 0 and 1 so there are zero letters between them.
Because distance[0] = 1, s is not a well-spaced string.
","class Solution:
    def checkDistances(self, s: str, distance: List[int]) -> bool:        
        hashmap = {}
        for i in range(len(s)):
            if s[i] in hashmap and i - hashmap[s[i]] - 1 != distance[ord(s[i]) - ord('a')]:
                return False
            hashmap[s[i]] = i                           
        return True",True
Most Frequent Even Element,"Given an integer array nums, return the most frequent even element.
If there is a tie, return the smallest one. If there is no such element, return -1.
","Example 1:
Input: nums = [0,1,2,2,4,4,1]
Output: 2
Explanation:
The even elements are 0, 2, and 4. Of these, 2 and 4 appear the most.
We return the smallest one, which is 2.
Example 2:
Input: nums = [4,4,4,9,2,4]
Output: 4
Explanation: 4 is the even element appears the most.
Example 3:
Input: nums = [29,47,21,41,13,37,25,7]
Output: -1
Explanation: There is no even element.
","class Solution:
    def mostFrequentEven(self, nums: List[int]) -> int:
        d = {}
        for ele in nums:
            if ele%2 == 0:
                d[ele] = d.get(ele,0) + 1

        if not d:
            return -1

        maxv = max(d.values())

        return min([ele for ele in d if d[ele] == maxv])
        # Or
        maxe = [ele for ele in d if d[ele] == maxv]
        return min(maxe)

",True
Sort the People,"You are given an array of strings names, and an array heights that consists of distinct positive integers. Both arrays are of length n.
For each index i, names[i] and heights[i] denote the name and height of the ith person.
Return names sorted in descending order by the people's heights.
","Example 1:
Input: names = [""Mary"",""John"",""Emma""], heights = [180,165,170]
Output: [""Mary"",""Emma"",""John""]
Explanation: Mary is the tallest, followed by Emma and John.
Example 2:
Input: names = [""Alice"",""Bob"",""Bob""], heights = [155,185,150]
Output: [""Bob"",""Alice"",""Bob""]
Explanation: The first Bob is the tallest, followed by Alice and the second Bob.
","class Solution:
    def sortPeople(self, n: List[str], h: List[int]) -> List[str]:
        d=dict(zip(h,n))
        c=[]
        h.sort(reverse=True)
        for i in h:
            c.append(d[i])
        return c",True
Find The Original Array of Prefix Xor,"You are given an integer array pref of size n. Find and return the array arr of size n that satisfies:
pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i].
Note that ^ denotes the bitwise-xor operation.
It can be proven that the answer is unique.
","Example 1:
Input: pref = [5,2,0,3,1]
Output: [5,7,2,3,2]
Explanation: From the array [5,7,2,3,2] we have the following:
- pref[0] = 5.
- pref[1] = 5 ^ 7 = 2.
- pref[2] = 5 ^ 7 ^ 2 = 0.
- pref[3] = 5 ^ 7 ^ 2 ^ 3 = 3.
- pref[4] = 5 ^ 7 ^ 2 ^ 3 ^ 2 = 1.
Example 2:
Input: pref = [13]
Output: [13]
Explanation: We have pref[0] = arr[0] = 13.
","class Solution:
    def findArray(self, pref: List[int]) -> List[int]:
        arr = [pref[0]]
        for i in range(1, len(pref)):
            arr.append(pref[i] ^ pref[i - 1])
        return arr",True
Largest Positive Integer That Exists With Its Negative,"Given an integer array nums that does not contain any zeros, find the largest positive integer k such that -k also exists in the array.
Return the positive integer k. If there is no such integer, return -1.
","Example 1:
Input: nums = [-1,2,-3,3]
Output: 3
Explanation: 3 is the only valid k we can find in the array.
Example 2:
Input: nums = [-1,10,6,7,-7,1]
Output: 7
Explanation: Both 1 and 7 have their corresponding negative values in the array. 7 has a larger value.
Example 3:
Input: nums = [-10,8,6,7,-2,-3]
Output: -1
Explanation: There is no a single valid k, we return -1.
","class Solution:
    def findMaxK(self, nums: List[int]) -> int:
        nums.sort()
        l, r = 0, len(nums)-1
        
        while(nums[l]<0 and l<r):
            if nums[l]*(-1) == nums[r]:
                return nums[r]
            if nums[l]*(-1) > nums[r]:
                l += 1
            else:
                r -= 1
        
        return -1",True
Count Number of Distinct Integers After Reverse Operations,"You are given an array nums consisting of positive integers.
You have to take each integer in the array, reverse its digits, and add it to the end of the array. You should apply this operation to the original integers in nums.
Return the number of distinct integers in the final array.
","Example 1:
Input: nums = [1,13,10,12,31]
Output: 6
Explanation: After including the reverse of each number, the resulting array is [1,13,10,12,31,1,31,1,21,13].
The reversed integers that were added to the end of the array are underlined. Note that for the integer 10, after reversing it, it becomes 01 which is just 1.
The number of distinct integers in this array is 6 (The numbers 1, 10, 12, 13, 21, and 31).
Example 2:
Input: nums = [2,2,2]
Output: 1
Explanation: After including the reverse of each number, the resulting array is [2,2,2,2,2,2].
The number of distinct integers in this array is 1 (The number 2).
","class Solution:
    def countDistinctIntegers(self, nums: List[int]) -> int:
        D=nums[:]
        for i in range(len(nums)):
            T=str(nums[i])
            T=T[::-1]
            D.append(int(T))
        return len(set(D))
        ",True
Minimize Maximum of Array,"You are given a 0-indexed array nums comprising of n non-negative integers.
In one operation, you must:
Choose an integer i such that 1 <= i < n and nums[i] > 0.
Decrease nums[i] by 1.
Increase nums[i - 1] by 1.
Return the minimum possible value of the maximum integer of nums after performing any number of operations.
","Example 1:
Input: nums = [3,7,1,6]
Output: 5
Explanation:
One set of optimal operations is as follows:
1. Choose i = 1, and nums becomes [4,6,1,6].
2. Choose i = 3, and nums becomes [4,6,2,5].
3. Choose i = 1, and nums becomes [5,5,2,5].
The maximum integer of nums is 5. It can be shown that the maximum number cannot be less than 5.
Therefore, we return 5.
Example 2:
Input: nums = [10,1]
Output: 10
Explanation:
It is optimal to leave nums as is, and since 10 is the maximum value, we return 10.
","class Solution:
    def minimizeArrayValue(self, nums: List[int]) -> int:
        start, end = 0, max(nums)
        while start + 1 < end:
            mid = (start + end) // 2
            if self.check(nums, mid):
                end = mid
            else:
                start = mid
        if self.check(nums, start):
            return start
        else:
            return end
        
    def check(self, nums, k):
        n = len(nums)
        temp = 0
        for i in range(n - 1, 0, -1):
            if temp + nums[i] > k:
                temp += nums[i] - k
            else:
                temp = 0
        return False if temp + nums[0] > k else True",True
Determine if Two Events Have Conflict,"You are given two arrays of strings that represent two inclusive events that happened on the same day, event1 and event2, where:
event1 = [startTime1, endTime1] and
event2 = [startTime2, endTime2].
Event times are valid 24 hours format in the form of HH:MM.
A conflict happens when two events have some non-empty intersection (i.e., some moment is common to both events).
Return true if there is a conflict between two events. Otherwise, return false.
","Example 1:
Input: event1 = [""01:15"",""02:00""], event2 = [""02:00"",""03:00""]
Output: true
Explanation: The two events intersect at time 2:00.
Example 2:
Input: event1 = [""01:00"",""02:00""], event2 = [""01:20"",""03:00""]
Output: true
Explanation: The two events intersect starting from 01:20 to 02:00.
Example 3:
Input: event1 = [""10:00"",""11:00""], event2 = [""14:00"",""15:00""]
Output: false
Explanation: The two events do not intersect.
","class Solution:
    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:
        e1s=int(event1[0][:2])*60 + int(event1[0][3:])
        e1e=int(event1[1][:2])*60 + int(event1[1][3:])
        e2s=int(event2[0][:2])*60 + int(event2[0][3:])
        e2e=int(event2[1][:2])*60 + int(event2[1][3:])
        if e1s<=e2s<=e1e: return True
        if e2s<=e1s<=e2e: return True
        if e1s<=e2e<=e1e: return True
        if e2s<=e1e<=e2e: return True
        else: return False",True
Average Value of Even Numbers That Are Divisible by Three,"Given an integer array nums of positive integers, return the average value of all even integers that are divisible by 3.
Note that the average of n elements is the sum of the n elements divided by n and rounded down to the nearest integer.
","Example 1:
Input: nums = [1,3,6,10,12,15]
Output: 9
Explanation: 6 and 12 are even numbers that are divisible by 3. (6 + 12) / 2 = 9.
Example 2:
Input: nums = [1,2,4,7,10]
Output: 0
Explanation: There is no single number that satisfies the requirement, so return 0.
","class Solution {
    public int averageValue(int[] nums) {
        int sum = 0;
        int count = 0;
        for(int num:nums)
            if (num%6==0) {
                sum += num;
                count++;
            }
       return count == 0 ? 0 : sum/count;
    }
}",False
Odd String Difference,"You are given an array of equal-length strings words. Assume that the length of each string is n.
Each string words[i] can be converted into a difference integer array difference[i] of length n - 1 where difference[i][j] = words[i][j+1] - words[i][j] where 0 <= j <= n - 2. Note that the difference between two letters is the difference between their positions in the alphabet i.e. the position of 'a' is 0, 'b' is 1, and 'z' is 25.
For example, for the string ""acb"", the difference integer array is [2 - 0, 1 - 2] = [2, -1].
All the strings in words have the same difference integer array, except one. You should find that string.
Return the string in words that has different difference integer array.
","Example 1:
Input: words = [""adc"",""wzy"",""abc""]
Output: ""abc""
Explanation: 
- The difference integer array of ""adc"" is [3 - 0, 2 - 3] = [3, -1].
- The difference integer array of ""wzy"" is [25 - 22, 24 - 25]= [3, -1].
- The difference integer array of ""abc"" is [1 - 0, 2 - 1] = [1, 1]. 
The odd array out is [1, 1], so we return the corresponding string, ""abc"".
Example 2:
Input: words = [""aaa"",""bob"",""ccc"",""ddd""]
Output: ""bob""
Explanation: All the integer arrays are [0, 0] except for ""bob"", which corresponds to [13, -13].
","class Solution:
    def oddString(self, words: List[str]) -> str:
        n = len(words[0])
        temp = []
        for i in range(len(words)):
            print(self.diff(words[i]))
            temp.append(self.diff(words[i]))

        print((temp))
        for i in range(len(temp)):
            if temp.count(temp[i]) == 1:
                return words[i]
        return ''
        
    def diff(self, word: str) -> str:
        return [ord(word[i]) - ord(word[i-1]) for i in range(1, len(word))]",True
Apply Operations to an Array,"You are given a 0-indexed array nums of size n consisting of non-negative integers.
You need to apply n - 1 operations to this array where, in the ith operation (0-indexed), you will apply the following on the ith element of nums:
If nums[i] == nums[i + 1], then multiply nums[i] by 2 and set nums[i + 1] to 0. Otherwise, you skip this operation.
After performing all the operations, shift all the 0's to the end of the array.
For example, the array [1,0,2,0,0,1] after shifting all its 0's to the end, is [1,2,1,0,0,0].
Return the resulting array.
Note that the operations are applied sequentially, not all at once.
","Example 1:
Input: nums = [1,2,2,1,1,0]
Output: [1,4,2,0,0,0]
Explanation: We do the following operations:
- i = 0: nums[0] and nums[1] are not equal, so we skip this operation.
- i = 1: nums[1] and nums[2] are equal, we multiply nums[1] by 2 and change nums[2] to 0. The array becomes [1,4,0,1,1,0].
- i = 2: nums[2] and nums[3] are not equal, so we skip this operation.
- i = 3: nums[3] and nums[4] are equal, we multiply nums[3] by 2 and change nums[4] to 0. The array becomes [1,4,0,2,0,0].
- i = 4: nums[4] and nums[5] are equal, we multiply nums[4] by 2 and change nums[5] to 0. The array becomes [1,4,0,2,0,0].
After that, we shift the 0's to the end, which gives the array [1,4,2,0,0,0].
Example 2:
Input: nums = [0,1]
Output: [1,0]
Explanation: No operation can be applied, we just shift the 0 to the end.
","class Solution:
    def applyOperations(self, nums: List[int]) -> List[int]:

        for i in range(len(nums)-1):
            if nums[i] == nums[i+1]:
                nums[i]*= 2
                nums[i + 1] = 0   # <-- performing the ""operation.""  
      
        return sorted(nums, key=lambda x: x == 0)   # Sorting on a boolean key: False, then True. O(N*logN) worst case, but likely much better because of the key.",True
Maximum Sum of Distinct Subarrays With Length K,"You are given an integer array nums and an integer k. Find the maximum subarray sum of all the subarrays of nums that meet the following conditions:
The length of the subarray is k, and
All the elements of the subarray are distinct.
Return the maximum subarray sum of all the subarrays that meet the conditions. If no subarray meets the conditions, return 0.
A subarray is a contiguous non-empty sequence of elements within an array.
","Example 1:
Input: nums = [1,5,4,2,9,9,9], k = 3
Output: 15
Explanation: The subarrays of nums with length 3 are:
- [1,5,4] which meets the requirements and has a sum of 10.
- [5,4,2] which meets the requirements and has a sum of 11.
- [4,2,9] which meets the requirements and has a sum of 15.
- [2,9,9] which does not meet the requirements because the element 9 is repeated.
- [9,9,9] which does not meet the requirements because the element 9 is repeated.
We return 15 because it is the maximum subarray sum of all the subarrays that meet the conditions
Example 2:
Input: nums = [4,4,4], k = 3
Output: 0
Explanation: The subarrays of nums with length 3 are:
- [4,4,4] which does not meet the requirements because the element 4 is repeated.
We return 0 because no subarrays meet the conditions.
","class Solution:
    def maximumSubarraySum(self, nums: List[int], k: int) -> int:
        
        subarray = {}
        queue = []
        temp_sum = 0
        max_sum = 0
    
        for i in range(len(nums)):

            # if not in subarray, we have two conditions to pay attention to
            if nums[i] not in subarray:
                # FIRST SCENARIO
                if len(subarray) < k:
                    # subarray size is less than K
                    # we can just simply add new element to subarray
                    subarray[nums[i]] = i
                    temp_sum += nums[i]
                    queue.append(nums[i])

                # SECOND SCENARIO
                else:
                    # remove first element in subarray
                    # add new element we encounter
                    temp = queue.pop(0)
                    temp_sum -= nums[subarray[temp]]
                    del subarray[temp]

                    subarray[nums[i]] = i
                    temp_sum += nums[i]   
                    queue.append(nums[i])                 

            else:
                # keep removing first element in the subarray
                # until the duplicated element we encounter no longer
                # exist in the subarray
                while nums[i] in subarray:
                    temp = queue.pop(0)
                    temp_sum -= nums[subarray[temp]]
                    del subarray[temp]
                # then add the new duplicated value to subarray (now it will be distinct)
                subarray[nums[i]] = i
                temp_sum += nums[i]
                queue.append(nums[i])
                
            # at the end of each for loop operation
            # we ensure that subarray are all distinct
            # if size of it satisfied constraint, we look to see
            # it it's a possible new max sum
            if len(subarray) == k:
                max_sum = max(temp_sum, max_sum)


        return max_sum
                  ",True
Total Cost to Hire K Workers,"You are given a 0-indexed integer array costs where costs[i] is the cost of hiring the ith worker.
You are also given two integers k and candidates. We want to hire exactly k workers according to the following rules:
You will run k sessions and hire exactly one worker in each session.
In each hiring session, choose the worker with the lowest cost from either the first candidates workers or the last candidates workers. Break the tie by the smallest index.
For example, if costs = [3,2,7,7,1,2] and candidates = 2, then in the first hiring session, we will choose the 4th worker because they have the lowest cost [3,2,7,7,1,2].
In the second hiring session, we will choose 1st worker because they have the same lowest cost as 4th worker but they have the smallest index [3,2,7,7,2]. Please note that the indexing may be changed in the process.
If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them. Break the tie by the smallest index.
A worker can only be chosen once.
Return the total cost to hire exactly k workers.
","Example 1:
Input: costs = [17,12,10,2,7,2,11,20,8], k = 3, candidates = 4
Output: 11
Explanation: We hire 3 workers in total. The total cost is initially 0.
- In the first hiring round we choose the worker from [17,12,10,2,7,2,11,20,8]. The lowest cost is 2, and we break the tie by the smallest index, which is 3. The total cost = 0 + 2 = 2.
- In the second hiring round we choose the worker from [17,12,10,7,2,11,20,8]. The lowest cost is 2 (index 4). The total cost = 2 + 2 = 4.
- In the third hiring round we choose the worker from [17,12,10,7,11,20,8]. The lowest cost is 7 (index 3). The total cost = 4 + 7 = 11. Notice that the worker with index 3 was common in the first and last four workers.
The total hiring cost is 11.
Example 2:
Input: costs = [1,2,4,1], k = 3, candidates = 3
Output: 4
Explanation: We hire 3 workers in total. The total cost is initially 0.
- In the first hiring round we choose the worker from [1,2,4,1]. The lowest cost is 1, and we break the tie by the smallest index, which is 0. The total cost = 0 + 1 = 1. Notice that workers with index 1 and 2 are common in the first and last 3 workers.
- In the second hiring round we choose the worker from [2,4,1]. The lowest cost is 1 (index 2). The total cost = 1 + 1 = 2.
- In the third hiring round there are less than three candidates. We choose the worker from the remaining workers [2,4]. The lowest cost is 2 (index 0). The total cost = 2 + 2 = 4.
The total hiring cost is 4.
",,False
Number of Distinct Averages,"You are given a 0-indexed integer array nums of even length.
As long as nums is not empty, you must repetitively:
Find the minimum number in nums and remove it.
Find the maximum number in nums and remove it.
Calculate the average of the two removed numbers.
The average of two numbers a and b is (a + b) / 2.
For example, the average of 2 and 3 is (2 + 3) / 2 = 2.5.
Return the number of distinct averages calculated using the above process.
Note that when there is a tie for a minimum or maximum number, any can be removed.
","Example 1:
Input: nums = [4,1,4,0,3,5]
Output: 2
Explanation:
1. Remove 0 and 5, and the average is (0 + 5) / 2 = 2.5. Now, nums = [4,1,4,3].
2. Remove 1 and 4. The average is (1 + 4) / 2 = 2.5, and nums = [4,3].
3. Remove 3 and 4, and the average is (3 + 4) / 2 = 3.5.
Since there are 2 distinct numbers among 2.5, 2.5, and 3.5, we return 2.
Example 2:
Input: nums = [1,100]
Output: 1
Explanation:
There is only one average to be calculated after removing 1 and 100, so we return 1.
","class Solution:
    def distinctAverages(self, nums: List[int]) -> int:
        av=[]
        nums.sort()
        while nums:
            av.append((nums[-1]+nums[0])/2)
            nums.pop(-1)
            nums.pop(0)
        return len(set(av))",True
Most Profitable Path in a Tree,"There is an undirected tree with n nodes labeled from 0 to n - 1, rooted at node 0. You are given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.
At every node i, there is a gate. You are also given an array of even integers amount, where amount[i] represents:
the price needed to open the gate at node i, if amount[i] is negative, or,
the cash reward obtained on opening the gate at node i, otherwise.
The game goes on as follows:
Initially, Alice is at node 0 and Bob is at node bob.
At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0.
For every node along their path, Alice and Bob either spend money to open the gate at that node, or accept the reward. Note that:
If the gate is already open, no price will be required, nor will there be any cash reward.
If Alice and Bob reach the node simultaneously, they share the price/reward for opening the gate there. In other words, if the price to open the gate is c, then both Alice and Bob pay c / 2 each. Similarly, if the reward at the gate is c, both of them receive c / 2 each.
If Alice reaches a leaf node, she stops moving. Similarly, if Bob reaches node 0, he stops moving. Note that these events are independent of each other.
Return the maximum net income Alice can have if she travels towards the optimal leaf node.
","Example 1:

Input: edges = [[0,1],[1,2],[1,3],[3,4]], bob = 3, amount = [-2,4,2,-4,6]
Output: 6
Explanation: 
The above diagram represents the given tree. The game goes as follows:
- Alice is initially on node 0, Bob on node 3. They open the gates of their respective nodes.
  Alice's net income is now -2.
- Both Alice and Bob move to node 1. 
  Since they reach here simultaneously, they open the gate together and share the reward.
  Alice's net income becomes -2 + (4 / 2) = 0.
- Alice moves on to node 3. Since Bob already opened its gate, Alice's income remains unchanged.
  Bob moves on to node 0, and stops moving.
- Alice moves on to node 4 and opens the gate there. Her net income becomes 0 + 6 = 6.
Now, neither Alice nor Bob can make any further moves, and the game ends.
It is not possible for Alice to get a higher net income.
Example 2:

Input: edges = [[0,1]], bob = 1, amount = [-7280,2350]
Output: -7280
Explanation: 
Alice follows the path 0->1 whereas Bob follows the path 1->0.
Thus, Alice opens the gate at node 0 only. Hence, her net income is -7280. 
",,False
Number of Unequal Triplets in Array,"You are given a 0-indexed array of positive integers nums. Find the number of triplets (i, j, k) that meet the following conditions:
0 <= i < j < k < nums.length
nums[i], nums[j], and nums[k] are pairwise distinct.
In other words, nums[i] != nums[j], nums[i] != nums[k], and nums[j] != nums[k].
Return the number of triplets that meet the conditions.
","Example 1:
Input: nums = [4,4,2,4,3]
Output: 3
Explanation: The following triplets meet the conditions:
- (0, 2, 4) because 4 != 2 != 3
- (1, 2, 4) because 4 != 2 != 3
- (2, 3, 4) because 2 != 4 != 3
Since there are 3 triplets, we return 3.
Note that (2, 0, 4) is not a valid triplet because 2 > 0.
Example 2:
Input: nums = [1,1,1,1,1]
Output: 0
Explanation: No triplets meet the conditions so we return 0.
","class Solution(object):
    def unequalTriplets(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ans = 0

        for i in range(len(nums) - 2):
            set_n = set()
            set_n.add(nums[i])
            for j in range(i + 1, len(nums) - 1):
                if nums[j] in set_n:
                    continue
                set_n.add(nums[j])
                for k in range(j + 1, len(nums)):
                    if nums[k] not in set_n:
                        ans += 1
                set_n.remove(nums[j])
        return ans
",True
Divide Players Into Teams of Equal Skill,"You are given a positive integer array skill of even length n where skill[i] denotes the skill of the ith player. Divide the players into n / 2 teams of size 2 such that the total skill of each team is equal.
The chemistry of a team is equal to the product of the skills of the players on that team.
Return the sum of the chemistry of all the teams, or return -1 if there is no way to divide the players into teams such that the total skill of each team is equal.
","Example 1:
Input: skill = [3,2,5,1,3,4]
Output: 22
Explanation: 
Divide the players into the following teams: (1, 5), (2, 4), (3, 3), where each team has a total skill of 6.
The sum of the chemistry of all the teams is: 1 * 5 + 2 * 4 + 3 * 3 = 5 + 8 + 9 = 22.
Example 2:
Input: skill = [3,4]
Output: 12
Explanation: 
The two players form a team with a total skill of 7.
The chemistry of the team is 3 * 4 = 12.
Example 3:
Input: skill = [1,1,2,3]
Output: -1
Explanation: 
There is no way to divide the players into teams such that the total skill of each team is equal.
","class Solution:
    def dividePlayers(self, skill: List[int]) -> int:
        n = len(skill)
        skill.sort()
        res = 0
        for i in range(0, n//2):
            if skill[i] + skill[n-i-1] != skill[0] + skill[-1]:
                return -1
            res += (skill[i] * skill[n-i-1])
        return res
        ",True
Delete Greatest Value in Each Row,"You are given an m x n matrix grid consisting of positive integers.
Perform the following operation until grid becomes empty:
Delete the element with the greatest value from each row. If multiple such elements exist, delete any of them.
Add the maximum of deleted elements to the answer.
Note that the number of columns decreases by one after each operation.
Return the answer after performing the operations described above.
","Example 1:

Input: grid = [[1,2,4],[3,3,1]]
Output: 8
Explanation: The diagram above shows the removed values in each step.
- In the first operation, we remove 4 from the first row and 3 from the second row (notice that, there are two cells with value 3 and we can remove any of them). We add 4 to the answer.
- In the second operation, we remove 2 from the first row and 3 from the second row. We add 3 to the answer.
- In the third operation, we remove 1 from the first row and 1 from the second row. We add 1 to the answer.
The final answer = 4 + 3 + 1 = 8.
Example 2:

Input: grid = [[10]]
Output: 10
Explanation: The diagram above shows the removed values in each step.
- In the first operation, we remove 10 from the first row. We add 10 to the answer.
The final answer = 10.
","class Solution {
public:
    static bool cmp(int a , int b){
        return a>b;
    }
    int deleteGreatestValue(vector<vector<int>>& grid) {
        int ans = 0;
        
        vector<vector<int>> mat = grid;
        
        
        for(int i=0 ; i<grid.size() ; i++){
            sort(mat[i].begin() , mat[i].end() , cmp);
        }
        
        for(int j=0 ; j<mat[0].size() ; j++){
            vector<int> tmp(mat.size());
            for(int i=0 ; i<mat.size() ; i++){
               
                tmp.push_back(mat[i][j]);
            }
           
            sort(tmp.begin() , tmp.end() , cmp);
            
            ans = ans + tmp[0];
        }
        return ans;
    }
};",False
Longest Square Streak in an Array,"You are given an integer array nums. A subsequence of nums is called a square streak if:
The length of the subsequence is at least 2, and
after sorting the subsequence, each element (except the first element) is the square of the previous number.
Return the length of the longest square streak in nums, or return -1 if there is no square streak.
A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.
","Example 1:
Input: nums = [4,3,6,16,8,2]
Output: 3
Explanation: Choose the subsequence [4,16,2]. After sorting it, it becomes [2,4,16].
- 4 = 2 * 2.
- 16 = 4 * 4.
Therefore, [4,16,2] is a square streak.
It can be shown that every subsequence of length 4 is not a square streak.
Example 2:
Input: nums = [2,3,5,6,7]
Output: -1
Explanation: There is no square streak in nums so return -1.
","class Solution:
    def longestSquareStreak(self, nums: List[int]) -> int:
        dp = defaultdict(int)
        for x in sorted(nums): 
            dp[x] = max(dp[x], 1)
            v = isqrt(x)
            if v**2 == x: dp[x] = 1 + dp[v]
        ans = max(dp.values())
        return ans if ans > 1 else -1",True
Design Memory Allocator,"You are given an integer n representing the size of a 0-indexed memory array. All memory units are initially free.
You have a memory allocator with the following functionalities:
Allocate a block of size consecutive free memory units and assign it the id mID.
Free all memory units with the given id mID.
Note that:
Multiple blocks can be allocated to the same mID.
You should free all the memory units with mID, even if they were allocated in different blocks.
Implement the Allocator class:
Allocator(int n) Initializes an Allocator object with a memory array of size n.
int allocate(int size, int mID) Find the leftmost block of size consecutive free memory units and allocate it with the id mID. Return the block's first index. If such a block does not exist, return -1.
int free(int mID) Free all memory units with the id mID. Return the number of memory units you have freed.
","Example 1:
Input
[""Allocator"", ""allocate"", ""allocate"", ""allocate"", ""free"", ""allocate"", ""allocate"", ""allocate"", ""free"", ""allocate"", ""free""]
[[10], [1, 1], [1, 2], [1, 3], [2], [3, 4], [1, 1], [1, 1], [1], [10, 2], [7]]
Output
[null, 0, 1, 2, 1, 3, 1, 6, 3, -1, 0]

Explanation
Allocator loc = new Allocator(10); // Initialize a memory array of size 10. All memory units are initially free.
loc.allocate(1, 1); // The leftmost block's first index is 0. The memory array becomes [1,_,_,_,_,_,_,_,_,_]. We return 0.
loc.allocate(1, 2); // The leftmost block's first index is 1. The memory array becomes [1,2,_,_,_,_,_,_,_,_]. We return 1.
loc.allocate(1, 3); // The leftmost block's first index is 2. The memory array becomes [1,2,3,_,_,_,_,_,_,_]. We return 2.
loc.free(2); // Free all memory units with mID 2. The memory array becomes [1,_, 3,_,_,_,_,_,_,_]. We return 1 since there is only 1 unit with mID 2.
loc.allocate(3, 4); // The leftmost block's first index is 3. The memory array becomes [1,_,3,4,4,4,_,_,_,_]. We return 3.
loc.allocate(1, 1); // The leftmost block's first index is 1. The memory array becomes [1,1,3,4,4,4,_,_,_,_]. We return 1.
loc.allocate(1, 1); // The leftmost block's first index is 6. The memory array becomes [1,1,3,4,4,4,1,_,_,_]. We return 6.
loc.free(1); // Free all memory units with mID 1. The memory array becomes [_,_,3,4,4,4,_,_,_,_]. We return 3 since there are 3 units with mID 1.
loc.allocate(10, 2); // We can not find any free block with 10 consecutive free memory units, so we return -1.
loc.free(7); // Free all memory units with mID 7. The memory array remains the same since there is no memory unit with mID 7. We return 0.
",,False
Maximum Value of a String in an Array,"The value of an alphanumeric string can be defined as:
The numeric representation of the string in base 10, if it comprises of digits only.
The length of the string, otherwise.
Given an array strs of alphanumeric strings, return the maximum value of any string in strs.
","Example 1:
Input: strs = [""alic3"",""bob"",""3"",""4"",""00000""]
Output: 5
Explanation: 
- ""alic3"" consists of both letters and digits, so its value is its length, i.e. 5.
- ""bob"" consists only of letters, so its value is also its length, i.e. 3.
- ""3"" consists only of digits, so its value is its numeric equivalent, i.e. 3.
- ""4"" also consists only of digits, so its value is 4.
- ""00000"" consists only of digits, so its value is 0.
Hence, the maximum value is 5, of ""alic3"".
Example 2:
Input: strs = [""1"",""01"",""001"",""0001""]
Output: 1
Explanation: 
Each string in the array has value 1. Hence, we return 1.
","class Solution:
    def maximumValue(self, s: List[str]) -> int:
        n=len(s)
        for i in range(n):
            if s[i].isnumeric():
                s[i]=int(s[i])
            else:
                s[i]=len(s[i])
        return max(s)",True
Maximum Star Sum of a Graph,"There is an undirected graph consisting of n nodes numbered from 0 to n - 1. You are given a 0-indexed integer array vals of length n where vals[i] denotes the value of the ith node.
You are also given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting nodes ai and bi.
A star graph is a subgraph of the given graph having a center node containing 0 or more neighbors. In other words, it is a subset of edges of the given graph such that there exists a common node for all edges.
The image below shows star graphs with 3 and 4 neighbors respectively, centered at the blue node.

The star sum is the sum of the values of all the nodes present in the star graph.
Given an integer k, return the maximum star sum of a star graph containing at most k edges.
","Example 1:

Input: vals = [1,2,3,4,10,-10,-20], edges = [[0,1],[1,2],[1,3],[3,4],[3,5],[3,6]], k = 2
Output: 16
Explanation: The above diagram represents the input graph.
The star graph with the maximum star sum is denoted by blue. It is centered at 3 and includes its neighbors 1 and 4.
It can be shown it is not possible to get a star graph with a sum greater than 16.
Example 2:
Input: vals = [-5], edges = [], k = 0
Output: -5
Explanation: There is only one possible star graph, which is node 0 itself.
Hence, we return -5.
","class Solution:
    def maxStarSum(self, v: List[int], edges: List[List[int]], k: int) -> int:
        n = len(v)
        g = defaultdict(list)
        for s,d in edges:
            g[s].append([v[d],d])
            g[d].append([v[s],s])
        
        ms = -inf
        
        for z in range(n):
            if g[z]:
                g[z].sort(reverse=True)

                cs = v[z]
                c = k
                for j in range(len(g[z])):

                    if g[z][j][0] > 0:
                        cs += g[z][j][0]
                        c = c-1

                        if c == 0: break

                    else: break
                    
                ms = max(ms,cs)
                
        
        if ms == -inf:
            return max(v)
        else:
            return ms",True
Frog Jump II,"You are given a 0-indexed integer array stones sorted in strictly increasing order representing the positions of stones in a river.
A frog, initially on the first stone, wants to travel to the last stone and then return to the first stone. However, it can jump to any stone at most once.
The length of a jump is the absolute difference between the position of the stone the frog is currently on and the position of the stone to which the frog jumps.
More formally, if the frog is at stones[i] and is jumping to stones[j], the length of the jump is |stones[i] - stones[j]|.
The cost of a path is the maximum length of a jump among all jumps in the path.
Return the minimum cost of a path for the frog.
","Example 1:

Input: stones = [0,2,5,6,7]
Output: 5
Explanation: The above figure represents one of the optimal paths the frog can take.
The cost of this path is 5, which is the maximum length of a jump.
Since it is not possible to achieve a cost of less than 5, we return it.
Example 2:

Input: stones = [0,3,9]
Output: 9
Explanation: 
The frog can jump directly to the last stone and come back to the first stone. 
In this case, the length of each jump will be 9. The cost for the path will be max(9, 9) = 9.
It can be shown that this is the minimum achievable cost.
","class Solution:
    def maxJump(self, stones: List[int]) -> int:
        if len(stones) == 2:
            return (stones[-1] - stones[0])
        maxjump = 0
        i, j = 0, 2
        while j < len(stones):
            maxjump = max(maxjump, (stones[j] - stones[i]))
            i+= 1; j+= 1
        return maxjump
        ",True
Maximum Tastiness of Candy Basket,"You are given an array of positive integers price where price[i] denotes the price of the ith candy and a positive integer k.
The store sells baskets of k distinct candies. The tastiness of a candy basket is the smallest absolute difference of the prices of any two candies in the basket.
Return the maximum tastiness of a candy basket.
","Example 1:
Input: price = [13,5,1,8,21,2], k = 3
Output: 8
Explanation: Choose the candies with the prices [13,5,21].
The tastiness of the candy basket is: min(|13 - 5|, |13 - 21|, |5 - 21|) = min(8, 8, 16) = 8.
It can be proven that 8 is the maximum tastiness that can be achieved.
Example 2:
Input: price = [1,3,1], k = 2
Output: 2
Explanation: Choose the candies with the prices [1,3].
The tastiness of the candy basket is: min(|1 - 3|) = min(2) = 2.
It can be proven that 2 is the maximum tastiness that can be achieved.
Example 3:
Input: price = [7,7,7,7], k = 2
Output: 0
Explanation: Choosing any two distinct candies from the candies we have will result in a tastiness of 0.
","class Solution:
    def maximumTastiness(self, price: List[int], k: int) -> int:
        # Trivial case of 2 candies
        # is is also the maximal possible distance for later binary search right bound
        rightDistanceBound = max(price) - min(price)
        if k == 2:
            return rightDistanceBound

        # sort the candies to ""spread"" them
        price.sort()

        # trivial case when all candies need to be taken
        if k == len(price):
            minimalCandyDistance = rightDistanceBound
            it = iter(price)
            previousPrice = next(it)
            for currentPrice in it:
                distance = currentPrice - previousPrice
                previousPrice = currentPrice
                if distance < minimalCandyDistance:
                    minimalCandyDistance = distance
            return minimalCandyDistance

        # left bound of the binary search
        leftDistanceBound = 0

        # if keep track of the maximal result once k candies are found
        maxResult = 0
        # binary sarch
        while leftDistanceBound < rightDistanceBound:
            # take the middle
            midDistance = (leftDistanceBound + rightDistanceBound) >> 1
            # track the minimal distance as we pick the candies
            minimalCandyDistance = rightDistanceBound
            # pick the first candy
            pickedCandies = 1  # picked so far
            it = iter(price)
            previousPrice = next(it)  # previously picked candy
            for currentPrice in it:
                # make sure the next candy is at least m steps away from the previous
                distance = currentPrice - previousPrice
                if distance >= midDistance:
                    # update the minimalDistance observed in this search
                    if distance < minimalCandyDistance:
                        minimalCandyDistance = distance
                    # update counts and the previous candy
                    pickedCandies += 1
                    previousPrice = currentPrice
                    # if k candies are picked
                    if pickedCandies == k:
                        # update the result if larger
                        if minimalCandyDistance > maxResult:
                            maxResult = minimalCandyDistance
                        # try to increase the distance in the next round
                        leftDistanceBound = midDistance + 1
                        break
            else:
                # No break from the loop, less than k candies, decrease the distance for the next round
                rightDistanceBound = midDistance
        return maxResult",True
Maximum Enemy Forts That Can Be Captured,"You are given a 0-indexed integer array forts of length n representing the positions of several forts. forts[i] can be -1, 0, or 1 where:
-1 represents there is no fort at the ith position.
0 indicates there is an enemy fort at the ith position.
1 indicates the fort at the ith the position is under your command.
Now you have decided to move your army from one of your forts at position i to an empty position j such that:
0 <= i, j <= n - 1
The army travels over enemy forts only. Formally, for all k where min(i,j) < k < max(i,j), forts[k] == 0.
While moving the army, all the enemy forts that come in the way are captured.
Return the maximum number of enemy forts that can be captured. In case it is impossible to move your army, or you do not have any fort under your command, return 0.
","Example 1:
Input: forts = [1,0,0,-1,0,0,0,0,1]
Output: 4
Explanation:
- Moving the army from position 0 to position 3 captures 2 enemy forts, at 1 and 2.
- Moving the army from position 8 to position 3 captures 4 enemy forts.
Since 4 is the maximum number of enemy forts that can be captured, we return 4.
Example 2:
Input: forts = [0,0,1,-1]
Output: 0
Explanation: Since no enemy fort can be captured, 0 is returned.
","class Solution:
    def captureForts(self, forts: List[int]) -> int:
        indx = 0
        count = 0
        prev = 0
        ans = 0
        for i in range(len(forts)):
            if forts[i]!=0:
                prev = forts[i]
                indx = i
                break
                
        for i in range(indx+1, len(forts)):
            if forts[i] == 0:
                count += 1
            else:
                if (forts[i] == 1 and prev == -1) or (forts[i] == -1 and prev == 1):
                    ans = max(ans, count)
                    count = 0
                    prev = forts[i]
                else:
                    count = 0
        
        return ans
            ",True
Reward Top K Students,"You are given two string arrays positive_feedback and negative_feedback, containing the words denoting positive and negative feedback, respectively. Note that no word is both positive and negative.
Initially every student has 0 points. Each positive word in a feedback report increases the points of a student by 3, whereas each negative word decreases the points by 1.
You are given n feedback reports, represented by a 0-indexed string array report and a 0-indexed integer array student_id, where student_id[i] represents the ID of the student who has received the feedback report report[i]. The ID of each student is unique.
Given an integer k, return the top k students after ranking them in non-increasing order by their points. In case more than one student has the same points, the one with the lower ID ranks higher.
","Example 1:
Input: positive_feedback = [""smart"",""brilliant"",""studious""], negative_feedback = [""not""], report = [""this student is studious"",""the student is smart""], student_id = [1,2], k = 2
Output: [1,2]
Explanation: 
Both the students have 1 positive feedback and 3 points but since student 1 has a lower ID he ranks higher.
Example 2:
Input: positive_feedback = [""smart"",""brilliant"",""studious""], negative_feedback = [""not""], report = [""this student is not studious"",""the student is smart""], student_id = [1,2], k = 2
Output: [2,1]
Explanation: 
- The student with ID 1 has 1 positive feedback and 1 negative feedback, so he has 3-1=2 points. 
- The student with ID 2 has 1 positive feedback, so he has 3 points. 
Since student 2 has more points, [2,1] is returned.
","class Solution: 
    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:
        positive_feedback = set(positive_feedback)
        negative_feedback = set(negative_feedback)
        mp = {}
        for sentence, id in zip(report, student_id): 
            point = 0 
            for word in sentence.split(): 
                if word in positive_feedback: point += 3
                elif word in negative_feedback: point -= 1
            mp[id] = point 
        return sorted(mp, key=lambda x: (-mp[x], x))[:k]",True
Minimum Operations to Make Array Equal II,"You are given two integer arrays nums1 and nums2 of equal length n and an integer k. You can perform the following operation on nums1:
Choose two indexes i and j and increment nums1[i] by k and decrement nums1[j] by k. In other words, nums1[i] = nums1[i] + k and nums1[j] = nums1[j] - k.
nums1 is said to be equal to nums2 if for all indices i such that 0 <= i < n, nums1[i] == nums2[i].
Return the minimum number of operations required to make nums1 equal to nums2. If it is impossible to make them equal, return -1.
","Example 1:
Input: nums1 = [4,3,1,4], nums2 = [1,3,7,1], k = 3
Output: 2
Explanation: In 2 operations, we can transform nums1 to nums2.
1st operation: i = 2, j = 0. After applying the operation, nums1 = [1,3,4,4].
2nd operation: i = 2, j = 3. After applying the operation, nums1 = [1,3,7,1].
One can prove that it is impossible to make arrays equal in fewer operations.
Example 2:
Input: nums1 = [3,8,5,2], nums2 = [2,4,1,6], k = 1
Output: -1
Explanation: It can be proved that it is impossible to make the two arrays equal.
","class Solution {
    public long minOperations(int[] nums1, int[] nums2, int k) {
        long diff = 0;
        long sum = 0;
        long ans = -1;
        for(int i = 0; i<nums1.length; i++)
        {
            if((Math.abs(nums1[i]-nums2[i])!=0 && Math.abs(nums1[i]-nums2[i]) < k ) ||((k!=0)&&(Math.abs(nums1[i]-nums2[i])%k) !=0))
            {
            return -1;
            }
            diff += (nums1[i] - nums2[i]);
            sum+= Math.abs(nums1[i] - nums2[i]);
        }
        if( diff == 0 && k!=0)
        {
            if(sum % (k*2) == 0 && sum >=(k*2))
            {
                sum = sum/2;
                ans = sum/k;
            }
            else if (sum == 0 && diff == 0)
            {
                ans = 0;
            }
            else
            {
                ans = -1;
            }
        }
        else
        {
            if(sum == 0 && diff == 0)
            {
                ans = 0;
            }
            else if(diff != 0 && k !=0)
            {
                ans = -1;
            }
            else if(diff == 0 && (k == 0&&sum!=0))
            {
                ans = -1;
            }
        }
        return ans;
    }
}",False
Difference Between Ones and Zeros in Row and Column,"You are given a 0-indexed m x n binary matrix grid.
A 0-indexed m x n difference matrix diff is created with the following procedure:
Let the number of ones in the ith row be onesRowi.
Let the number of ones in the jth column be onesColj.
Let the number of zeros in the ith row be zerosRowi.
Let the number of zeros in the jth column be zerosColj.
diff[i][j] = onesRowi + onesColj - zerosRowi - zerosColj
Return the difference matrix diff.
","Example 1:

Input: grid = [[0,1,1],[1,0,1],[0,0,1]]
Output: [[0,0,4],[0,0,4],[-2,-2,2]]
Explanation:
- diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0 = 2 + 1 - 1 - 2 = 0 
- diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1 = 2 + 1 - 1 - 2 = 0 
- diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2 = 2 + 3 - 1 - 0 = 4 
- diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0 = 2 + 1 - 1 - 2 = 0 
- diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1 = 2 + 1 - 1 - 2 = 0 
- diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2 = 2 + 3 - 1 - 0 = 4 
- diff[2][0] = onesRow2 + onesCol0 - zerosRow2 - zerosCol0 = 1 + 1 - 2 - 2 = -2
- diff[2][1] = onesRow2 + onesCol1 - zerosRow2 - zerosCol1 = 1 + 1 - 2 - 2 = -2
- diff[2][2] = onesRow2 + onesCol2 - zerosRow2 - zerosCol2 = 1 + 3 - 2 - 0 = 2
Example 2:

Input: grid = [[1,1,1],[1,1,1]]
Output: [[5,5,5],[5,5,5]]
Explanation:
- diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0 = 3 + 2 - 0 - 0 = 5
- diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1 = 3 + 2 - 0 - 0 = 5
- diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2 = 3 + 2 - 0 - 0 = 5
- diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0 = 3 + 2 - 0 - 0 = 5
- diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1 = 3 + 2 - 0 - 0 = 5
- diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2 = 3 + 2 - 0 - 0 = 5
","class Solution:
    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:
        lis = [ [0]*len(grid[0]) for i in range(len(grid))]
        # grid1 = [ [0]*len(grid[0]) for i in range(len(grid))]
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 0:
                    grid[i][j] =-1
        
                
        
        
        rows = {}
        cols = {}
        ele = 0
        for i in range(len(grid)):
            rows[i] = sum(grid[i])
        
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if j not in cols:
                    cols[j] = grid[i][j] 
                else:
                    cols[j] += grid[i][j] 
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                ele = rows[i]+cols[j]
                lis[i][j] = ele
            
        return lis
        ",True
Distinct Prime Factors of Product of Array,"Given an array of positive integers nums, return the number of distinct prime factors in the product of the elements of nums.
Note that:
A number greater than 1 is called prime if it is divisible by only 1 and itself.
An integer val1 is a factor of another integer val2 if val2 / val1 is an integer.
","Example 1:
Input: nums = [2,4,3,7,10,6]
Output: 4
Explanation:
The product of all the elements in nums is: 2 * 4 * 3 * 7 * 10 * 6 = 10080 = 25 * 32 * 5 * 7.
There are 4 distinct prime factors so we return 4.
Example 2:
Input: nums = [2,4,8,16]
Output: 1
Explanation:
The product of all the elements in nums is: 2 * 4 * 8 * 16 = 1024 = 210.
There is 1 distinct prime factor so we return 1.
","class Solution:
    def distinctPrimeFactors(self, nums: List[int]) -> int:

        seen, primes = set(), {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31} 
         
        for num in nums:
            for p in primes:

                r = num%p
                if p not in seen and not r: seen.add(p)

                while not r:
                    num//= p
                    r = num%p

            if num > 1: seen.add(num) 

        return len(seen)
",True
Maximum Count of Positive Integer and Negative Integer,"Given an array nums sorted in non-decreasing order, return the maximum between the number of positive integers and the number of negative integers.
In other words, if the number of positive integers in nums is pos and the number of negative integers is neg, then return the maximum of pos and neg.
Note that 0 is neither positive nor negative.
","Example 1:
Input: nums = [-2,-1,-1,1,2,3]
Output: 3
Explanation: There are 3 positive integers and 3 negative integers. The maximum count among them is 3.
Example 2:
Input: nums = [-3,-2,-1,0,0,1,2]
Output: 3
Explanation: There are 2 positive integers and 3 negative integers. The maximum count among them is 3.
Example 3:
Input: nums = [5,20,66,1314]
Output: 4
Explanation: There are 4 positive integers and 0 negative integers. The maximum count among them is 4.
","class Solution:
    def maximumCount(self, nums: List[int]) -> int:
        l1 = list(filter(lambda x: x>0, nums))
        l2 = list(filter(lambda x: x<0, nums))
        return max(len(l1),len(l2))",True
Maximal Score After Applying K Operations,"You are given a 0-indexed integer array nums and an integer k. You have a starting score of 0.
In one operation:
choose an index i such that 0 <= i < nums.length,
increase your score by nums[i], and
replace nums[i] with ceil(nums[i] / 3).
Return the maximum possible score you can attain after applying exactly k operations.
The ceiling function ceil(val) is the least integer greater than or equal to val.
","Example 1:
Input: nums = [10,10,10,10,10], k = 5
Output: 50
Explanation: Apply the operation to each array element exactly once. The final score is 10 + 10 + 10 + 10 + 10 = 50.
Example 2:
Input: nums = [1,10,3,3,3], k = 3
Output: 17
Explanation: You can do the following operations:
Operation 1: Select i = 1, so nums becomes [1,4,3,3,3]. Your score increases by 10.
Operation 2: Select i = 1, so nums becomes [1,2,3,3,3]. Your score increases by 4.
Operation 3: Select i = 2, so nums becomes [1,1,1,3,3]. Your score increases by 3.
The final score is 10 + 4 + 3 = 17.
","class Solution:
    def maxKelements(self, nums: List[int], k: int) -> int:
        heapq._heapify_max(nums)
        ans=0
        for _ in range(k):
            ans += nums[0]
            heapq._heapreplace_max(nums, (nums[0]+2)//3)
        return ans",True
Find Xor-Beauty of Array,"You are given a 0-indexed integer array nums.
The effective value of three indices i, j, and k is defined as ((nums[i] | nums[j]) & nums[k]).
The xor-beauty of the array is the XORing of the effective values of all the possible triplets of indices (i, j, k) where 0 <= i, j, k < n.
Return the xor-beauty of nums.
Note that:
val1 | val2 is bitwise OR of val1 and val2.
val1 & val2 is bitwise AND of val1 and val2.
","Example 1:
Input: nums = [1,4]
Output: 5
Explanation: 
The triplets and their corresponding effective values are listed below:
- (0,0,0) with effective value ((1 | 1) & 1) = 1
- (0,0,1) with effective value ((1 | 1) & 4) = 0
- (0,1,0) with effective value ((1 | 4) & 1) = 1
- (0,1,1) with effective value ((1 | 4) & 4) = 4
- (1,0,0) with effective value ((4 | 1) & 1) = 1
- (1,0,1) with effective value ((4 | 1) & 4) = 4
- (1,1,0) with effective value ((4 | 4) & 1) = 0
- (1,1,1) with effective value ((4 | 4) & 4) = 4 
Xor-beauty of array will be bitwise XOR of all beauties = 1 ^ 0 ^ 1 ^ 4 ^ 1 ^ 4 ^ 0 ^ 4 = 5.
Example 2:
Input: nums = [15,45,20,2,34,35,5,44,32,30]
Output: 34
Explanation: The xor-beauty of the given array is 34.
",,False
Difference Between Element Sum and Digit Sum of an Array,"You are given a positive integer array nums.
The element sum is the sum of all the elements in nums.
The digit sum is the sum of all the digits (not necessarily distinct) that appear in nums.
Return the absolute difference between the element sum and digit sum of nums.
Note that the absolute difference between two integers x and y is defined as |x - y|.
","Example 1:
Input: nums = [1,15,6,3]
Output: 9
Explanation: 
The element sum of nums is 1 + 15 + 6 + 3 = 25.
The digit sum of nums is 1 + 1 + 5 + 6 + 3 = 16.
The absolute difference between the element sum and digit sum is |25 - 16| = 9.
Example 2:
Input: nums = [1,2,3,4]
Output: 0
Explanation:
The element sum of nums is 1 + 2 + 3 + 4 = 10.
The digit sum of nums is 1 + 2 + 3 + 4 = 10.
The absolute difference between the element sum and digit sum is |10 - 10| = 0.
","class Solution {
public:
    int differenceOfSum(vector<int>& nums) {
        int tsum = accumulate(nums.begin(),nums.end(),0);

        int digitSum = 0;

        for(auto x : nums){
            while(x){
                int rem = x % 10;
                digitSum+= rem;
                x = x/10;
            }
        }

        return abs(tsum - digitSum);
    }
};",False
Increment Submatrices by One,"You are given a positive integer n, indicating that we initially have an n x n 0-indexed integer matrix mat filled with zeroes.
You are also given a 2D integer array query. For each query[i] = [row1i, col1i, row2i, col2i], you should do the following operation:
Add 1 to every element in the submatrix with the top left corner (row1i, col1i) and the bottom right corner (row2i, col2i). That is, add 1 to mat[x][y] for all row1i <= x <= row2i and col1i <= y <= col2i.
Return the matrix mat after performing every query.
","Example 1:

Input: n = 3, queries = [[1,1,2,2],[0,0,1,1]]
Output: [[1,1,0],[1,2,1],[0,1,1]]
Explanation: The diagram above shows the initial matrix, the matrix after the first query, and the matrix after the second query.
- In the first query, we add 1 to every element in the submatrix with the top left corner (1, 1) and bottom right corner (2, 2).
- In the second query, we add 1 to every element in the submatrix with the top left corner (0, 0) and bottom right corner (1, 1).
Example 2:

Input: n = 2, queries = [[0,0,1,1]]
Output: [[1,1],[1,1]]
Explanation: The diagram above shows the initial matrix and the matrix after the first query.
- In the first query we add 1 to every element in the matrix.
","class Solution:
    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:
        ans = [[0] * n for _ in range(n)]
        for r1, c1, r2, c2 in queries:
            ans[r1][c1] += 1
            if r2 + 1 < n: ans[r2 + 1][c1] -= 1
            if c2 + 1 < n: ans[r1][c2 + 1] -= 1
            if r2 + 1 < n and c2 + 1 < n: ans[r2 + 1][c2 + 1] += 1
        for r in range(1, n):
            for c in range(n):
                ans[r][c] += ans[r - 1][c]
        for r in range(n):
            for c in range(1, n):
                ans[r][c] += ans[r][c - 1]
        return ans",True
Count the Number of Good Subarrays,"Given an integer array nums and an integer k, return the number of good subarrays of nums.
A subarray arr is good if it there are at least k pairs of indices (i, j) such that i < j and arr[i] == arr[j].
A subarray is a contiguous non-empty sequence of elements within an array.
","Example 1:
Input: nums = [1,1,1,1,1], k = 10
Output: 1
Explanation: The only good subarray is the array nums itself.
Example 2:
Input: nums = [3,1,4,3,2,2,4], k = 2
Output: 4
Explanation: There are 4 different good subarrays:
- [3,1,4,3,2,2] that has 2 pairs.
- [3,1,4,3,2,2,4] that has 3 pairs.
- [1,4,3,2,2,4] that has 2 pairs.
- [4,3,2,2,4] that has 2 pairs.
","class Solution(object):
    def countGood(self, nums, k):
        """"""
        :type nums: List[int]
        :type k: int
        :rtype: int
        """"""
        elements_in_current_window=dict()
        pair_count=0
        start=0
        end=0
        ans=0
        while(end<len(nums)):
            if(elements_in_current_window.has_key(nums[end])):
                elements_in_current_window[nums[end]]+=1 #incrementing 
            else:
                elements_in_current_window[nums[end]]=1 #initializing entry in the dictionary
            pair_count+=elements_in_current_window[nums[end]]-1 #counting number of pairs
            while pair_count>=k: #The shrinking phase
                ans+=1+len(nums)-end-1 #the number of new sequences
                elements_in_current_window[nums[start]]-=1 #remove the element at the starting of the window
                pair_count-=elements_in_current_window[nums[start]]
                start+=1
            end+=1    
        return ans            
            
        ",True
Sort the Students by Their Kth Score,"There is a class with m students and n exams. You are given a 0-indexed m x n integer matrix score, where each row represents one student and score[i][j] denotes the score the ith student got in the jth exam. The matrix score contains distinct integers only.
You are also given an integer k. Sort the students (i.e., the rows of the matrix) by their scores in the kth (0-indexed) exam from the highest to the lowest.
Return the matrix after sorting it.
","Example 1:

Input: score = [[10,6,9,1],[7,5,11,2],[4,8,3,15]], k = 2
Output: [[7,5,11,2],[10,6,9,1],[4,8,3,15]]
Explanation: In the above diagram, S denotes the student, while E denotes the exam.
- The student with index 1 scored 11 in exam 2, which is the highest score, so they got first place.
- The student with index 0 scored 9 in exam 2, which is the second highest score, so they got second place.
- The student with index 2 scored 3 in exam 2, which is the lowest score, so they got third place.
Example 2:

Input: score = [[3,4],[5,6]], k = 0
Output: [[5,6],[3,4]]
Explanation: In the above diagram, S denotes the student, while E denotes the exam.
- The student with index 1 scored 5 in exam 0, which is the highest score, so they got first place.
- The student with index 0 scored 3 in exam 0, which is the lowest score, so they got second place.
","class Solution:
    def sortTheStudents(self, score: List[List[int]], k: int) -> List[List[int]]:
        col={j[k]:i for i,j in enumerate(score)}
        x=sorted(col.items(),key=lambda col:col[0])
        a=[]
        while x:
            c=(score[x.pop()[1]])
            a.append(c)
        return a",True
Minimum Common Value,"Given two integer arrays nums1 and nums2, sorted in non-decreasing order, return the minimum integer common to both arrays. If there is no common integer amongst nums1 and nums2, return -1.
Note that an integer is said to be common to nums1 and nums2 if both arrays have at least one occurrence of that integer.
","Example 1:
Input: nums1 = [1,2,3], nums2 = [2,4]
Output: 2
Explanation: The smallest element common to both arrays is 2, so we return 2.
Example 2:
Input: nums1 = [1,2,3,6], nums2 = [2,3,4,5]
Output: 2
Explanation: There are two common elements in the array 2 and 3 out of which 2 is the smallest, so 2 is returned.
","class Solution {
public:
    int getCommon(vector<int>& nums1, vector<int>& nums2) {
        int l1 = 0, l2 = 0, r1 = nums1.size()-1, r2 = nums2.size()-1;
        
        while(l1 <= r1 && l2 <= r2) {
            if(nums1[l1] == nums2[l2]) {
                return nums1[l1];
            }
            
            if(nums1[l1] < nums2[l2]) {
                l1++;
            } else {
                l2++;
            }
            
            if(nums1[r1] < nums2[r2]) {
                r2--;
            } else if(nums1[r1] == nums2[r2]) {
                // do nothing
            } else {
                r1--;
            }
        }
        
        return -1;
    }
};",False
Separate the Digits in an Array,"Given an array of positive integers nums, return an array answer that consists of the digits of each integer in nums after separating them in the same order they appear in nums.
To separate the digits of an integer is to get all the digits it has in the same order.
For example, for the integer 10921, the separation of its digits is [1,0,9,2,1].
","Example 1:
Input: nums = [13,25,83,77]
Output: [1,3,2,5,8,3,7,7]
Explanation: 
- The separation of 13 is [1,3].
- The separation of 25 is [2,5].
- The separation of 83 is [8,3].
- The separation of 77 is [7,7].
answer = [1,3,2,5,8,3,7,7]. Note that answer contains the separations in the same order.
Example 2:
Input: nums = [7,1,3,9]
Output: [7,1,3,9]
Explanation: The separation of each integer in nums is itself.
answer = [7,1,3,9].
","class Solution:
    def separateDigits(self, nums: List[int]) -> List[int]:
        lst=[]
        for i in nums:
            t=[]
            while(i>0):
                d=i%10
                t.append(d)
                i=i//10
            t.reverse()
            lst.extend(t)
        return lst",True
Maximum Number of Integers to Choose From a Range I,"You are given an integer array banned and two integers n and maxSum. You are choosing some number of integers following the below rules:
The chosen integers have to be in the range [1, n].
Each integer can be chosen at most once.
The chosen integers should not be in the array banned.
The sum of the chosen integers should not exceed maxSum.
Return the maximum number of integers you can choose following the mentioned rules.
","Example 1:
Input: banned = [1,6,5], n = 5, maxSum = 6
Output: 2
Explanation: You can choose the integers 2 and 4.
2 and 4 are from the range [1, 5], both did not appear in banned, and their sum is 6, which did not exceed maxSum.
Example 2:
Input: banned = [1,2,3,4,5,6,7], n = 8, maxSum = 1
Output: 0
Explanation: You cannot choose any integer while following the mentioned conditions.
Example 3:
Input: banned = [11], n = 7, maxSum = 50
Output: 7
Explanation: You can choose the integers 1, 2, 3, 4, 5, 6, and 7.
They are from the range [1, 7], all did not appear in banned, and their sum is 28, which did not exceed maxSum.
","class Solution:
    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:
        arr = set(i for i in range(1, n + 1))
        x = arr - set(banned)
        x = sorted(list(x))
        cnt = 0
        cntt = 0
        i = 0
        while cnt <= maxSum and i != len(x):
            cnt += x[i]
            i += 1
        if cnt > maxSum:
            return i - 1
        return i",True
Count the Number of Vowel Strings in Range,"You are given a 0-indexed array of string words and two integers left and right.
A string is called a vowel string if it starts with a vowel character and ends with a vowel character where vowel characters are 'a', 'e', 'i', 'o', and 'u'.
Return the number of vowel strings words[i] where i belongs to the inclusive range [left, right].
","Example 1:
Input: words = [""are"",""amy"",""u""], left = 0, right = 2
Output: 2
Explanation: 
- ""are"" is a vowel string because it starts with 'a' and ends with 'e'.
- ""amy"" is not a vowel string because it does not end with a vowel.
- ""u"" is a vowel string because it starts with 'u' and ends with 'u'.
The number of vowel strings in the mentioned range is 2.
Example 2:
Input: words = [""hey"",""aeo"",""mu"",""ooo"",""artro""], left = 1, right = 4
Output: 3
Explanation: 
- ""aeo"" is a vowel string because it starts with 'a' and ends with 'o'.
- ""mu"" is not a vowel string because it does not start with a vowel.
- ""ooo"" is a vowel string because it starts with 'o' and ends with 'o'.
- ""artro"" is a vowel string because it starts with 'a' and ends with 'o'.
The number of vowel strings in the mentioned range is 3.
","class Solution:
    def vowelStrings(self, words: List[str], left: int, right: int) -> int:
        vowels='aeiouAEIOU'
        count=0
        for i in range(left,right+1):
            if words[i][0] in vowels and words[i][-1] in vowels:
                count+=1

        return count        ",True
Rearrange Array to Maximize Prefix Score,"You are given a 0-indexed integer array nums. You can rearrange the elements of nums to any order (including the given order).
Let prefix be the array containing the prefix sums of nums after rearranging it. In other words, prefix[i] is the sum of the elements from 0 to i in nums after rearranging it. The score of nums is the number of positive integers in the array prefix.
Return the maximum score you can achieve.
","Example 1:
Input: nums = [2,-1,0,1,-3,3,-3]
Output: 6
Explanation: We can rearrange the array into nums = [2,3,1,-1,-3,0,-3].
prefix = [2,5,6,5,2,2,-1], so the score is 6.
It can be shown that 6 is the maximum score we can obtain.
Example 2:
Input: nums = [-2,-3,0]
Output: 0
Explanation: Any rearrangement of the array will result in a score of 0.
",,False
Check Knight Tour Configuration,"There is a knight on an n x n chessboard. In a valid configuration, the knight starts at the top-left cell of the board and visits every cell on the board exactly once.
You are given an n x n integer matrix grid consisting of distinct integers from the range [0, n * n - 1] where grid[row][col] indicates that the cell (row, col) is the grid[row][col]th cell that the knight visited. The moves are 0-indexed.
Return true if grid represents a valid configuration of the knight's movements or false otherwise.
Note that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.

","Example 1:

Input: grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]
Output: true
Explanation: The above diagram represents the grid. It can be shown that it is a valid configuration.
Example 2:

Input: grid = [[0,3,6],[5,8,1],[2,7,4]]
Output: false
Explanation: The above diagram represents the grid. The 8th move of the knight is not valid considering its position after the 7th move.
","class Solution:
    def checkValidGrid(self, grid: List[List[int]]) -> bool:

        n, d = len(grid), defaultdict(tuple)
        if n < 5: return n == 1

        notLegal = lambda x, y : {abs(x[0]-y[0]),
                                  abs(x[1]-y[1])} != {1,2}

        for row, col in product(range(n),range(n)):
            d[grid[row][col]] = (row,col)
        
        prev, cnt = (0,0), 1

        while cnt < n*n:
            curr = d[cnt]

            if notLegal(prev,curr):  return False

            cnt+=1
            prev = curr

        return True",True
Maximize Greatness of an Array,"You are given a 0-indexed integer array nums. You are allowed to permute nums into a new array perm of your choosing.
We define the greatness of nums be the number of indices 0 <= i < nums.length for which perm[i] > nums[i].
Return the maximum possible greatness you can achieve after permuting nums.
","Example 1:
Input: nums = [1,3,5,2,1,3,1]
Output: 4
Explanation: One of the optimal rearrangements is perm = [2,5,1,3,3,1,1].
At indices = 0, 1, 3, and 4, perm[i] > nums[i]. Hence, we return 4.
Example 2:
Input: nums = [1,2,3,4]
Output: 3
Explanation: We can prove the optimal perm is [2,3,4,1].
At indices = 0, 1, and 2, perm[i] > nums[i]. Hence, we return 3.
","class Solution {
public:
    int maximizeGreatness(vector<int>& nums) {
    sort(nums.begin(), nums.end()); // Sort nums in non-decreasing order
    int greatness = 0;
    for (auto &it : nums) { // Loop over the elements of nums
        if (it > nums[greatness]) { // If the current element is greater than the greatest element seen so far
            greatness++; // Increment the number of indices i for which perm[i] > nums[i]
        }
    }
    return greatness; // Return the maximum possible greatness
}
};
static bool     _foo = ios::sync_with_stdio(false);
static ostream* _bar = cin.tie(NULL);",False
Minimum Time to Repair Cars,"You are given an integer array ranks representing the ranks of some mechanics. ranksi is the rank of the ith mechanic. A mechanic with a rank r can repair n cars in r * n2 minutes.
You are also given an integer cars representing the total number of cars waiting in the garage to be repaired.
Return the minimum time taken to repair all the cars.
Note: All the mechanics can repair the cars simultaneously.
","Example 1:
Input: ranks = [4,2,3,1], cars = 10
Output: 16
Explanation: 
- The first mechanic will repair two cars. The time required is 4 * 2 * 2 = 16 minutes.
- The second mechanic will repair two cars. The time required is 2 * 2 * 2 = 8 minutes.
- The third mechanic will repair two cars. The time required is 3 * 2 * 2 = 12 minutes.
- The fourth mechanic will repair four cars. The time required is 1 * 4 * 4 = 16 minutes.
It can be proved that the cars cannot be repaired in less than 16 minutes.
Example 2:
Input: ranks = [5,1,8], cars = 6
Output: 16
Explanation: 
- The first mechanic will repair one car. The time required is 5 * 1 * 1 = 5 minutes.
- The second mechanic will repair four cars. The time required is 1 * 4 * 4 = 16 minutes.
- The third mechanic will repair one car. The time required is 8 * 1 * 1 = 8 minutes.
It can be proved that the cars cannot be repaired in less than 16 minutes.
",,False
Form Smallest Number From Two Digit Arrays,"unique
nums1
nums2
the smallest number that contains at least one digit from each array
","Example 1:
Input: nums1 = [4,1,3], nums2 = [5,7]
Output: 15
Explanation: The number 15 contains the digit 1 from nums1 and the digit 5 from nums2. It can be proven that 15 is the smallest number we can have.
Example 2:
Input: nums1 = [3,5,2,6], nums2 = [3,1,7]
Output: 3
Explanation: The number 3 contains the digit 3 which exists in both arrays.
","class Solution:
    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:
        nums1.sort()
        nums2.sort()
        for i in nums1:
            if i in nums2:
                return i
        ans = (str(nums1[0]) + str(nums2[0])) if nums1[0] < nums2[0] else str(nums2[0]) + str(nums1[0]) 
        ans = int(ans)
        return ans",True
Find the Substring With Maximum Cost,"You are given a string s, a string chars of distinct characters and an integer array vals of the same length as chars.
The cost of the substring is the sum of the values of each character in the substring. The cost of an empty string is considered 0.
The value of the character is defined in the following way:
If the character is not in the string chars, then its value is its corresponding position (1-indexed) in the alphabet.
For example, the value of 'a' is 1, the value of 'b' is 2, and so on. The value of 'z' is 26.
Otherwise, assuming i is the index where the character occurs in the string chars, then its value is vals[i].
Return the maximum cost among all substrings of the string s.
","Example 1:
Input: s = ""adaa"", chars = ""d"", vals = [-1000]
Output: 2
Explanation: The value of the characters ""a"" and ""d"" is 1 and -1000 respectively.
The substring with the maximum cost is ""aa"" and its cost is 1 + 1 = 2.
It can be proven that 2 is the maximum cost.
Example 2:
Input: s = ""abc"", chars = ""abc"", vals = [-1,-1,-1]
Output: 0
Explanation: The value of the characters ""a"", ""b"" and ""c"" is -1, -1, and -1 respectively.
The substring with the maximum cost is the empty substring """" and its cost is 0.
It can be proven that 0 is the maximum cost.
",,False
Find the Width of Columns of a Grid,"You are given a 0-indexed m x n integer matrix grid. The width of a column is the maximum length of its integers.
For example, if grid = [[-10], [3], [12]], the width of the only column is 3 since -10 is of length 3.
Return an integer array ans of size n where ans[i] is the width of the ith column.
The length of an integer x with len digits is equal to len if x is non-negative, and len + 1 otherwise.
","Example 1:
Input: grid = [[1],[22],[333]]
Output: [3]
Explanation: In the 0th column, 333 is of length 3.
Example 2:
Input: grid = [[-15,1,3],[15,7,12],[5,6,-2]]
Output: [3,1,2]
Explanation: 
In the 0th column, only -15 is of length 3.
In the 1st column, all integers are of length 1. 
In the 2nd column, both 12 and -2 are of length 2.
","class Solution:
    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:
        l=[0]*len(grid[0])
        for i in grid:
            for j in range(len(i)):
                x=len(str(i[j]))
                l[j]=max(x,l[j])
        return l",True
Find the Score of All Prefixes of an Array,"We define the conversion array conver of an array arr as follows:
conver[i] = arr[i] + max(arr[0..i]) where max(arr[0..i]) is the maximum value of arr[j] over 0 <= j <= i.
We also define the score of an array arr as the sum of the values of the conversion array of arr.
Given a 0-indexed integer array nums of length n, return an array ans of length n where ans[i] is the score of the prefix nums[0..i].
","Example 1:
Input: nums = [2,3,7,5,10]
Output: [4,10,24,36,56]
Explanation: 
For the prefix [2], the conversion array is [4] hence the score is 4
For the prefix [2, 3], the conversion array is [4, 6] hence the score is 10
For the prefix [2, 3, 7], the conversion array is [4, 6, 14] hence the score is 24
For the prefix [2, 3, 7, 5], the conversion array is [4, 6, 14, 12] hence the score is 36
For the prefix [2, 3, 7, 5, 10], the conversion array is [4, 6, 14, 12, 20] hence the score is 56
Example 2:
Input: nums = [1,1,2,4,8,16]
Output: [2,4,8,16,32,64]
Explanation: 
For the prefix [1], the conversion array is [2] hence the score is 2
For the prefix [1, 1], the conversion array is [2, 2] hence the score is 4
For the prefix [1, 1, 2], the conversion array is [2, 2, 4] hence the score is 8
For the prefix [1, 1, 2, 4], the conversion array is [2, 2, 4, 8] hence the score is 16
For the prefix [1, 1, 2, 4, 8], the conversion array is [2, 2, 4, 8, 16] hence the score is 32
For the prefix [1, 1, 2, 4, 8, 16], the conversion array is [2, 2, 4, 8, 16, 32] hence the score is 64
",,False
Count Distinct Numbers on Board,"You are given a positive integer n, that is initially placed on a board. Every day, for 109 days, you perform the following procedure:
For each number x present on the board, find all numbers 1 <= i <= n such that x % i == 1.
Then, place those numbers on the board.
Return the number of distinct integers present on the board after 109 days have elapsed.
Note:
Once a number is placed on the board, it will remain on it until the end.
% stands for the modulo operation. For example, 14 % 3 is 2.
","Example 1:
Input: n = 5
Output: 4
Explanation: Initially, 5 is present on the board. 
The next day, 2 and 4 will be added since 5 % 2 == 1 and 5 % 4 == 1. 
After that day, 3 will be added to the board because 4 % 3 == 1. 
At the end of a billion days, the distinct numbers on the board will be 2, 3, 4, and 5. 
Example 2:
Input: n = 3
Output: 2
Explanation: 
Since 3 % 2 == 1, 2 will be added to the board. 
After a billion days, the only two distinct numbers on the board are 2 and 3. 
","class Solution:
    def distinctIntegers(self, n: int) -> int:
      if n==1:
        return 1
      return n-1
        ",True
Determine the Winner of a Bowling Game,"You are given two 0-indexed integer arrays player1 and player2, representing the number of pins that player 1 and player 2 hit in a bowling game, respectively.
The bowling game consists of n turns, and the number of pins in each turn is exactly 10.
Assume a player hits xi pins in the ith turn. The value of the ith turn for the player is:
2xi if the player hits 10 pins in either (i - 1)th or (i - 2)th turn.
Otherwise, it is xi.
The score of the player is the sum of the values of their n turns.
Return
1 if the score of player 1 is more than the score of player 2,
2 if the score of player 2 is more than the score of player 1, and
0 in case of a draw.
","Example 1:
Input: player1 = [5,10,3,2], player2 = [6,5,7,3]
Output: 1
Explanation:
The score of player 1 is 5 + 10 + 2*3 + 2*2 = 25.
The score of player 2 is 6 + 5 + 7 + 3 = 21.
Example 2:
Input: player1 = [3,5,7,6], player2 = [8,10,10,2]
Output: 2
Explanation:
The score of player 1 is 3 + 5 + 7 + 6 = 21.
The score of player 2 is 8 + 10 + 2*10 + 2*2 = 42.
Example 3:
Input: player1 = [2,3], player2 = [4,1]
Output: 0
Explanation:
The score of player1 is 2 + 3 = 5.
The score of player2 is 4 + 1 = 5.
Example 4:
Input: player1 = [1,1,1,10,10,10,10], player2 = [10,10,10,10,1,1,1]
Output: 1
Explanation:
The score of player1 is 1 + 1 + 1 + 10 + 2*10 + 2*10 + 2*10 = 73.
The score of player2 is 10 + 2*10 + 2*10 + 2*10 + 2*1 + 2*1 + 1 = 75.
","class Solution{
    public int isWinner(int[] p1, int[] p2){
        int n = p1.length;
        int a=p1[0], b=p2[0];
        if(n==1){
            if(a>b) return 1;
            else if(b>a) return 2;
            return 0;
        }
        if(a==10) a += 2*p1[1];
        else a += p1[1];
        if(b==10) b += 2*p2[1];
        else b += p2[1];
        for(int i=2; i<n; i++){
            if(p1[i-1]==10 || p1[i-2]==10) a += 2*p1[i];
            else a += p1[i];
            if(p2[i-1]==10 || p2[i-2]==10) b += 2*p2[i];
            else b += p2[i];
        }
        if(a>b) return 1;
        else if(b>a) return 2;
        return 0;
    }
}",False
First Completely Painted Row or Column,"You are given a 0-indexed integer array arr, and an m x n integer matrix mat. arr and mat both contain all the integers in the range [1, m * n].
Go through each index i in arr starting from index 0 and paint the cell in mat containing the integer arr[i].
Return the smallest index i at which either a row or a column will be completely painted in mat.
","Example 1:


Input: arr = [1,3,4,2], mat = [[1,4],[2,3]]
Output: 2
Explanation: The moves are shown in order, and both the first row and second column of the matrix become fully painted at arr[2].
Example 2:

Input: arr = [2,8,7,4,1,3,5,6,9], mat = [[3,2,5],[1,4,6],[8,7,9]]
Output: 3
Explanation: The second column becomes fully painted at arr[3].
","class Solution:
    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:
        d={}
        for i in range(len(mat)):
            d[i]=len(mat[0])
        for j in range(len(mat[0])):
            d[j+len(mat)]=len(mat)
        d1={}
        for i in range(0,len(mat)):
            for j in range(0,len(mat[i])):
                d1[mat[i][j]]=[i,j]
        st=inf
        for k in range(len(arr)):
            if arr[k] in d1:
                x=d1[arr[k]]
                d[x[0]]-=1
                d[x[1]+len(mat)]-=1
                if d[x[0]]==0 or d[x[1]+len(mat)]==0:
                    st=min(st,k)
        return st",True
Count Vowel Strings in Ranges,"You are given a 0-indexed array of strings words and a 2D array of integers queries.
Each query queries[i] = [li, ri] asks us to find the number of strings present in the range li to ri (both inclusive) of words that start and end with a vowel.
Return an array ans of size queries.length, where ans[i] is the answer to the ith query.
Note that the vowel letters are 'a', 'e', 'i', 'o', and 'u'.
","Example 1:
Input: words = [""aba"",""bcb"",""ece"",""aa"",""e""], queries = [[0,2],[1,4],[1,1]]
Output: [2,3,0]
Explanation: The strings starting and ending with a vowel are ""aba"", ""ece"", ""aa"" and ""e"".
The answer to the query [0,2] is 2 (strings ""aba"" and ""ece"").
to query [1,4] is 3 (strings ""ece"", ""aa"", ""e"").
to query [1,1] is 0.
We return [2,3,0].
Example 2:
Input: words = [""a"",""e"",""i""], queries = [[0,2],[0,1],[2,2]]
Output: [3,2,1]
Explanation: Every string satisfies the conditions, so we return [3,2,1].
","class Solution {
    public int[] vowelStrings(String[] words, int[][] queries) {
        HashSet<Character> hs = new HashSet<>();
        hs.add('a');
        hs.add('e');
        hs.add('i');
        hs.add('o');
        hs.add('u');
        
        int N = words.length;
        int[] arr = new int[N];
        for(int i=0; i<N; i++) {
            if(hs.contains(words[i].charAt(0)) && hs.contains(words[i].charAt(words[i].length()-1))){
                arr[i] = 1;
            }
        }
        
        int[] prefix = new int[N];
        prefix[0] = arr[0];
        for(int i=1; i<N; i++) {
            prefix[i] = prefix[i-1]+arr[i];
        }
        
        int[] ansArr = new int[queries.length];
        
        for(int i=0; i<queries.length; i++) {
            int[] q = queries[i];
            int s = q[0];
            int e = q[1];
            
            int cnt = prefix[e];
            
            if(s-1>=0) {
                cnt -= prefix[s-1];
            }
            
            ansArr[i] = cnt;
        }
        
        return ansArr;
    }
}",False
Take Gifts From the Richest Pile,"You are given an integer array gifts denoting the number of gifts in various piles. Every second, you do the following:
Choose the pile with the maximum number of gifts.
If there is more than one pile with the maximum number of gifts, choose any.
Leave behind the floor of the square root of the number of gifts in the pile. Take the rest of the gifts.
Return the number of gifts remaining after k seconds.
","Example 1:
Input: gifts = [25,64,9,4,100], k = 4
Output: 29
Explanation: 
The gifts are taken in the following way:
- In the first second, the last pile is chosen and 10 gifts are left behind.
- Then the second pile is chosen and 8 gifts are left behind.
- After that the first pile is chosen and 5 gifts are left behind.
- Finally, the last pile is chosen again and 3 gifts are left behind.
The final remaining gifts are [5,8,9,4,3], so the total number of gifts remaining is 29.
Example 2:
Input: gifts = [1,1,1,1], k = 4
Output: 4
Explanation: 
In this case, regardless which pile you choose, you have to leave behind 1 gift in each pile. 
That is, you can't take any pile with you. 
So, the total gifts remaining are 4.
","class Solution:
    def pickGifts(self, gifts: List[int], k: int) -> int:
        i = 1
        while i <= k:
            max_gift = max(gifts)
            if max_gift in gifts:
                gifts.remove(max_gift)
                gifts.append(int(math.sqrt(max_gift)))
            max_gift = 0
            i += 1
        ans = sum(gifts)
        return ans
    ",True
Find the Maximum Divisibility Score,"You are given two 0-indexed integer arrays nums and divisors.
The divisibility score of divisors[i] is the number of indices j such that nums[j] is divisible by divisors[i].
Return the integer divisors[i] with the maximum divisibility score. If there is more than one integer with the maximum score, return the minimum of them.
","Example 1:
Input: nums = [4,7,9,3,9], divisors = [5,2,3]
Output: 3
Explanation: The divisibility score for every element in divisors is:
The divisibility score of divisors[0] is 0 since no number in nums is divisible by 5.
The divisibility score of divisors[1] is 1 since nums[0] is divisible by 2.
The divisibility score of divisors[2] is 3 since nums[2], nums[3], and nums[4] are divisible by 3.
Since divisors[2] has the maximum divisibility score, we return it.
Example 2:
Input: nums = [20,14,21,10], divisors = [5,7,5]
Output: 5
Explanation: The divisibility score for every element in divisors is:
The divisibility score of divisors[0] is 2 since nums[0] and nums[3] are divisible by 5.
The divisibility score of divisors[1] is 2 since nums[1] and nums[2] are divisible by 7.
The divisibility score of divisors[2] is 2 since nums[0] and nums[3] are divisible by 5.
Since divisors[0], divisors[1], and divisors[2] all have the maximum divisibility score, we return the minimum of them (i.e., divisors[2]).
Example 3:
Input: nums = [12], divisors = [10,16]
Output: 10
Explanation: The divisibility score for every element in divisors is:
The divisibility score of divisors[0] is 0 since no number in nums is divisible by 10.
The divisibility score of divisors[1] is 0 since no number in nums is divisible by 16.
Since divisors[0] and divisors[1] both have the maximum divisibility score, we return the minimum of them (i.e., divisors[0]).
","class Solution:
    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:
        ans=-1
        most=-1
        for d in divisors:
            cnt=sum(1 for n in nums if n%d==0)
            if cnt>most or cnt==most and d<ans:
                ans=d
                most=cnt

        return ans        ",True
Find Score of an Array After Marking All Elements,"You are given an array nums consisting of positive integers.
Starting with score = 0, apply the following algorithm:
Choose the smallest integer of the array that is not marked. If there is a tie, choose the one with the smallest index.
Add the value of the chosen integer to score.
Mark the chosen element and its two adjacent elements if they exist.
Repeat until all the array elements are marked.
Return the score you get after applying the above algorithm.
","Example 1:
Input: nums = [2,1,3,4,5,2]
Output: 7
Explanation: We mark the elements as follows:
- 1 is the smallest unmarked element, so we mark it and its two adjacent elements: [2,1,3,4,5,2].
- 2 is the smallest unmarked element, so we mark it and its left adjacent element: [2,1,3,4,5,2].
- 4 is the only remaining unmarked element, so we mark it: [2,1,3,4,5,2].
Our score is 1 + 2 + 4 = 7.
Example 2:
Input: nums = [2,3,5,1,3,2]
Output: 5
Explanation: We mark the elements as follows:
- 1 is the smallest unmarked element, so we mark it and its two adjacent elements: [2,3,5,1,3,2].
- 2 is the smallest unmarked element, since there are two of them, we choose the left-most one, so we mark the one at index 0 and its right adjacent element: [2,3,5,1,3,2].
- 2 is the only remaining unmarked element, so we mark it: [2,3,5,1,3,2].
Our score is 1 + 2 + 2 = 5.
","class Solution:
    def findScore(self, nums: List[int]) -> int:
        ans,pq,seen,n = 0,[],set(),len(nums)
        for i,num in enumerate(nums):
            heapq.heappush(pq,(num,i))
        while pq:
            empty = False
            while True:
                if not pq: 
                    empty = True
                    break
                num,i = heapq.heappop(pq)
                if i not in seen:
                    break
            if empty:
                break
            ans += num
            if i+1<n:
                seen.add(i+1)
            if i-1>=0:
                seen.add(i-1)
        return ans",True
The Number of Beautiful Subsets,"You are given an array nums of positive integers and a positive integer k.
A subset of nums is beautiful if it does not contain two integers with an absolute difference equal to k.
Return the number of non-empty beautiful subsets of the array nums.
A subset of nums is an array that can be obtained by deleting some (possibly none) elements from nums. Two subsets are different if and only if the chosen indices to delete are different.
","Example 1:
Input: nums = [2,4,6], k = 2
Output: 4
Explanation: The beautiful subsets of the array nums are: [2], [4], [6], [2, 6].
It can be proved that there are only 4 beautiful subsets in the array [2,4,6].
Example 2:
Input: nums = [1], k = 1
Output: 1
Explanation: The beautiful subset of the array nums is [1].
It can be proved that there is only 1 beautiful subset in the array [1].
",,False
Find the Array Concatenation Value,"You are given a 0-indexed integer array nums.
The concatenation of two numbers is the number formed by concatenating their numerals.
For example, the concatenation of 15, 49 is 1549.
The concatenation value of nums is initially equal to 0. Perform this operation until nums becomes empty:
If there exists more than one number in nums, pick the first element and last element in nums respectively and add the value of their concatenation to the concatenation value of nums, then delete the first and last element from nums.
If one element exists, add its value to the concatenation value of nums, then delete it.
Return the concatenation value of the nums.
","Example 1:
Input: nums = [7,52,2,4]
Output: 596
Explanation: Before performing any operation, nums is [7,52,2,4] and concatenation value is 0.
 - In the first operation:
We pick the first element, 7, and the last element, 4.
Their concatenation is 74, and we add it to the concatenation value, so it becomes equal to 74.
Then we delete them from nums, so nums becomes equal to [52,2].
 - In the second operation:
We pick the first element, 52, and the last element, 2.
Their concatenation is 522, and we add it to the concatenation value, so it becomes equal to 596.
Then we delete them from the nums, so nums becomes empty.
Since the concatenation value is 596 so the answer is 596.
Example 2:
Input: nums = [5,14,13,8,12]
Output: 673
Explanation: Before performing any operation, nums is [5,14,13,8,12] and concatenation value is 0.
 - In the first operation:
We pick the first element, 5, and the last element, 12.
Their concatenation is 512, and we add it to the concatenation value, so it becomes equal to 512.
Then we delete them from the nums, so nums becomes equal to [14,13,8].
 - In the second operation:
We pick the first element, 14, and the last element, 8.
Their concatenation is 148, and we add it to the concatenation value, so it becomes equal to 660.
Then we delete them from the nums, so nums becomes equal to [13].
 - In the third operation:
nums has only one element, so we pick 13 and add it to the concatenation value, so it becomes equal to 673.
Then we delete it from nums, so nums become empty.
Since the concatenation value is 673 so the answer is 673.
","class Solution:
    def findTheArrayConcVal(self, nums: List[int]) -> int:
        concatenation = 0
        while len(nums)>0:
            if len(nums)>1:
                concatenation += int(str(nums[0])+str(nums[-1]))
                del nums[-1]
            else:
                concatenation += nums[0]
            del nums[0]
        return concatenation",True
Minimum Score by Changing Two Elements,"You are given an integer array nums.
The low score of nums is the minimum absolute difference between any two integers.
The high score of nums is the maximum absolute difference between any two integers.
The score of nums is the sum of the high and low scores.
Return the minimum score after changing two elements of nums.
","Example 1:
Input: nums = [1,4,7,8,5]
Output: 3
Explanation:
Change nums[0] and nums[1] to be 6 so that nums becomes [6,6,7,8,5].
The low score is the minimum absolute difference: |6 - 6| = 0.
The high score is the maximum absolute difference: |8 - 5| = 3.
The sum of high and low score is 3.
Example 2:
Input: nums = [1,4,3]
Output: 0
Explanation:
Change nums[1] and nums[2] to 1 so that nums becomes [1,1,1].
The sum of maximum absolute difference and minimum absolute difference is 0.
","class Solution:
    def minimizeSum(self, nums: List[int]) -> int:
        nums.sort()
        return min(nums[-1]-nums[2],nums[-2]-nums[1],nums[-3]-nums[0])     ",True
Merge Two 2D Arrays by Summing Values,"You are given two 2D integer arrays nums1 and nums2.
nums1[i] = [idi, vali] indicate that the number with the id idi has a value equal to vali.
nums2[i] = [idi, vali] indicate that the number with the id idi has a value equal to vali.
Each array contains unique ids and is sorted in ascending order by id.
Merge the two arrays into one array that is sorted in ascending order by id, respecting the following conditions:
Only ids that appear in at least one of the two arrays should be included in the resulting array.
Each id should be included only once and its value should be the sum of the values of this id in the two arrays. If the id does not exist in one of the two arrays then its value in that array is considered to be 0.
Return the resulting array. The returned array must be sorted in ascending order by id.
","Example 1:
Input: nums1 = [[1,2],[2,3],[4,5]], nums2 = [[1,4],[3,2],[4,1]]
Output: [[1,6],[2,3],[3,2],[4,6]]
Explanation: The resulting array contains the following:
- id = 1, the value of this id is 2 + 4 = 6.
- id = 2, the value of this id is 3.
- id = 3, the value of this id is 2.
- id = 4, the value of this id is 5 + 1 = 6.
Example 2:
Input: nums1 = [[2,4],[3,6],[5,5]], nums2 = [[1,3],[4,3]]
Output: [[1,3],[2,4],[3,6],[4,3],[5,5]]
Explanation: There are no common ids, so we just include each id with its value in the resulting list.
","class Solution:
    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:
        d1,d2 = {},{}
		# add all entries of nums1 to map d1
        for num in nums1:
            d1[num[0]] = num[1]
			
		# add all entries of nums2 to map d2
        for num in nums2:
            d2[num[0]] = num[1]
			
		# to store final ans
        ans = []
		
		# traverse map1
        for num in d1.keys():
            val = d1[num]
			
			# if the entry is in map2 add it in the value of map1 and remove it from map2
            if num in d2:
                val += d2[num]
                del d2[num]
				
			# add the id,val pair  to ans
            ans.append([num,val])
			
		# traverse map2 to get items that are not in map1
        for key,val in d2.items():
            ans.append([key,val])
			
		# sort the final ans by ids
        ans.sort(key=lambda x:x[0])
        return ans",True
Find the Maximum Number of Marked Indices,"You are given a 0-indexed integer array nums.
Initially, all of the indices are unmarked. You are allowed to make this operation any number of times:
Pick two different unmarked indices i and j such that 2 * nums[i] <= nums[j], then mark i and j.
Return the maximum possible number of marked indices in nums using the above operation any number of times.
","Example 1:
Input: nums = [3,5,2,4]
Output: 2
Explanation: In the first operation: pick i = 2 and j = 1, the operation is allowed because 2 * nums[2] <= nums[1]. Then mark index 2 and 1.
It can be shown that there's no other valid operation so the answer is 2.
Example 2:
Input: nums = [9,2,5,4]
Output: 4
Explanation: In the first operation: pick i = 3 and j = 0, the operation is allowed because 2 * nums[3] <= nums[0]. Then mark index 3 and 0.
In the second operation: pick i = 1 and j = 2, the operation is allowed because 2 * nums[1] <= nums[2]. Then mark index 1 and 2.
Since there is no other operation, the answer is 4.
Example 3:
Input: nums = [7,6,8]
Output: 0
Explanation: There is no valid operation to do, so the answer is 0.
","class Solution {
public:
    int maxNumOfMarkedIndices(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        int j=nums.size()-1;
        int c=0;
        int i=0;
        for(int i=nums.size()/2-1;i>=0;i--)
        {
            if(nums[i]*2<=nums[j])
            {
                c+=2;
                j--;
            }
        }
        return c;
    }
};",False
Find the Divisibility Array of a String,"You are given a 0-indexed string word of length n consisting of digits, and a positive integer m.
The divisibility array div of word is an integer array of length n such that:
div[i] = 1 if the numeric value of word[0,...,i] is divisible by m, or
div[i] = 0 otherwise.
Return the divisibility array of word.
","Example 1:
Input: word = ""998244353"", m = 3
Output: [1,1,0,0,0,1,1,0,0]
Explanation: There are only 4 prefixes that are divisible by 3: ""9"", ""99"", ""998244"", and ""9982443"".
Example 2:
Input: word = ""1010"", m = 10
Output: [0,1,0,1]
Explanation: There are only 2 prefixes that are divisible by 10: ""10"", and ""1010"".
","class Solution:
    def divisibilityArray(self, word: str, m: int) -> List[int]:
        mod = 0
        div = []

        for i in range(0, len(word)):
            mod = (mod * 10 + int(word[i])) % m
            div.append(1 if mod % m == 0 else 0)
        return div",True
Left and Right Sum Differences,"Given a 0-indexed integer array nums, find a 0-indexed integer array answer where:
answer.length == nums.length.
answer[i] = |leftSum[i] - rightSum[i]|.
Where:
leftSum[i] is the sum of elements to the left of the index i in the array nums. If there is no such element, leftSum[i] = 0.
rightSum[i] is the sum of elements to the right of the index i in the array nums. If there is no such element, rightSum[i] = 0.
Return the array answer.
","Example 1:
Input: nums = [10,4,8,3]
Output: [15,1,11,22]
Explanation: The array leftSum is [0,10,14,22] and the array rightSum is [15,11,3,0].
The array answer is [|0 - 15|,|10 - 11|,|14 - 3|,|22 - 0|] = [15,1,11,22].
Example 2:
Input: nums = [1]
Output: [0]
Explanation: The array leftSum is [0] and the array rightSum is [0].
The array answer is [|0 - 0|] = [0].
","class Solution:
    def leftRigthDifference(self, nums: List[int]) -> List[int]:
        res = []

        for i in range(len(nums)):
            res.append(abs(sum(nums[0:i])-sum(nums[i+1:])))

        return res",True
Prime Subtraction Operation,"You are given a 0-indexed integer array nums of length n.
You can perform the following operation as many times as you want:
Pick an index i that you haven’t picked before, and pick a prime p strictly less than nums[i], then subtract p from nums[i].
Return true if you can make nums a strictly increasing array using the above operation and false otherwise.
A strictly increasing array is an array whose each element is strictly greater than its preceding element.
","Example 1:
Input: nums = [4,9,6,10]
Output: true
Explanation: In the first operation: Pick i = 0 and p = 3, and then subtract 3 from nums[0], so that nums becomes [1,9,6,10].
In the second operation: i = 1, p = 7, subtract 7 from nums[1], so nums becomes equal to [1,2,6,10].
After the second operation, nums is sorted in strictly increasing order, so the answer is true.
Example 2:
Input: nums = [6,8,11,12]
Output: true
Explanation: Initially nums is sorted in strictly increasing order, so we don't need to make any operations.
Example 3:
Input: nums = [5,8,3]
Output: false
Explanation: It can be proven that there is no way to perform operations to make nums sorted in strictly increasing order, so the answer is false.
","class Solution:
  def primeSubOperation(self, nums: List[int]) -> bool:
    primes = [0, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]
    prev_small = 0
    for v in nums:
      pos, is_found = bisect_left(primes, v), False
      for i in range(pos - 1, -1, -1):
        if v - primes[i] > prev_small:
          prev_small = v - primes[i]
          is_found = True
          break
      if not is_found:
        return False
    
    return True",True
Minimize the Maximum Difference of Pairs,"You are given a 0-indexed integer array nums and an integer p. Find p pairs of indices of nums such that the maximum difference amongst all the pairs is minimized. Also, ensure no index appears more than once amongst the p pairs.
Note that for a pair of elements at the index i and j, the difference of this pair is |nums[i] - nums[j]|, where |x| represents the absolute value of x.
Return the minimum maximum difference among all p pairs. We define the maximum of an empty set to be zero.
","Example 1:
Input: nums = [10,1,2,7,1,3], p = 2
Output: 1
Explanation: The first pair is formed from the indices 1 and 4, and the second pair is formed from the indices 2 and 5. 
The maximum difference is max(|nums[1] - nums[4]|, |nums[2] - nums[5]|) = max(0, 1) = 1. Therefore, we return 1.
Example 2:
Input: nums = [4,2,1,2], p = 1
Output: 0
Explanation: Let the indices 1 and 3 form a pair. The difference of that pair is |2 - 2| = 0, which is the minimum we can attain.
","class Solution:
    def minimizeMax(self, nums: list[int], p: int) -> int:
        if p == 0: return 0

        nums.sort()
        pairs = [(b-a,i) for i,(a,b) in enumerate(itertools.pairwise(nums))]
        pairs.sort()

        # edge case optimization 1 --- copied from some other solution
        if len(nums) == 2*p:
            (d,i) = pairs.pop()
            while (i&1):
                (d,i) = pairs.pop()
            return d
                
        # edge case optimization 2 --- copied from some other solution
        dictmin = pairs[p-1][0]
        dictmax = pairs[2*p-2][0]
        if (dictmin == dictmax):
            return dictmin

        m = [0]*len(nums)
        for i, (d,loc) in enumerate(pairs):
            l, r = m[loc-1], m[loc+1]
            m[loc] = m[loc-l] = m[loc+r] = l+r+1
            p -= 1&~(l|r)
            if p == 0: return d
",True
Sum of Distances,"You are given a 0-indexed integer array nums. There exists an array arr of length nums.length, where arr[i] is the sum of |i - j| over all j such that nums[j] == nums[i] and j != i. If there is no such j, set arr[i] to be 0.
Return the array arr.
","Example 1:
Input: nums = [1,3,1,1,2]
Output: [5,0,3,4,0]
Explanation: 
When i = 0, nums[0] == nums[2] and nums[0] == nums[3]. Therefore, arr[0] = |0 - 2| + |0 - 3| = 5. 
When i = 1, arr[1] = 0 because there is no other index with value 3.
When i = 2, nums[2] == nums[0] and nums[2] == nums[3]. Therefore, arr[2] = |2 - 0| + |2 - 3| = 3. 
When i = 3, nums[3] == nums[0] and nums[3] == nums[2]. Therefore, arr[3] = |3 - 0| + |3 - 2| = 4. 
When i = 4, arr[4] = 0 because there is no other index with value 2. 
Example 2:
Input: nums = [0,5,3]
Output: [0,0,0]
Explanation: Since each element in nums is distinct, arr[i] = 0 for all i.
","class Solution:
    def distance(self, nums: List[int]) -> List[int]:
        d={}
        for i in range(len(nums)):
            if(nums[i] not in d):
                d[nums[i]]=[i]
            else:
                d[nums[i]].append(d[nums[i]][-1]+i)
        ans=[]
        for i in d:
            d[i].append(0)
            d[i].append(len(d[i])-1)
        print(d)
        for i in range(len(nums)):
            a=d[nums[i]][-2]
            n=d[nums[i]][-1]
            if(n==1):
                ans.append(0)
                continue
            print(a,n)
            ans.append(abs((a+1)*i-d[nums[i]][a])+abs((n-a-1)*i-(d[nums[i]][-3]-d[nums[i]][a])))
            d[nums[i]][-2]+=1
        return ans
            
            
        ",True
Prime In Diagonal,"You are given a 0-indexed two-dimensional integer array nums.
Return the largest prime number that lies on at least one of the diagonals of nums. In case, no prime is present on any of the diagonals, return 0.
Note that:
An integer is prime if it is greater than 1 and has no positive integer divisors other than 1 and itself.
An integer val is on one of the diagonals of nums if there exists an integer i for which nums[i][i] = val or an i for which nums[i][nums.length - i - 1] = val.

In the above diagram, one diagonal is [1,5,9] and another diagonal is [3,5,7].
","Example 1:
Input: nums = [[1,2,3],[5,6,7],[9,10,11]]
Output: 11
Explanation: The numbers 1, 3, 6, 9, and 11 are the only numbers present on at least one of the diagonals. Since 11 is the largest prime, we return 11.
Example 2:
Input: nums = [[1,2,3],[5,17,7],[9,11,10]]
Output: 17
Explanation: The numbers 1, 3, 9, 10, and 17 are all present on at least one of the diagonals. 17 is the largest prime, so we return 17.
","class Solution {
    bool prime(int n) {
        if(n < 2) return false;
        for(int i=2;i*i<=n;i++) {
            if(n % i == 0) return false;
        }
        return true;
    }
public:
    int diagonalPrime(vector<vector<int>>& nums) {
        int n = nums.size();
        int maxi = 0;
        for(int i=0;i<n;i++) {
            if(prime(nums[i][i])) {
                maxi = max(maxi, nums[i][i]);
            }
            if(prime(nums[i][n - i - 1])) {
                maxi = max(maxi, nums[i][n - i - 1]);
            }
        }
        return maxi;
    }
};",False
Convert an Array Into a 2D Array With Conditions,"You are given an integer array nums. You need to create a 2D array from nums satisfying the following conditions:
The 2D array should contain only the elements of the array nums.
Each row in the 2D array contains distinct integers.
The number of rows in the 2D array should be minimal.
Return the resulting array. If there are multiple answers, return any of them.
Note that the 2D array can have a different number of elements on each row.
","Example 1:
Input: nums = [1,3,4,1,2,3,1]
Output: [[1,3,4,2],[1,3],[1]]
Explanation: We can create a 2D array that contains the following rows:
- 1,3,4,2
- 1,3
- 1
All elements of nums were used, and each row of the 2D array contains distinct integers, so it is a valid answer.
It can be shown that we cannot have less than 3 rows in a valid array.
Example 2:
Input: nums = [1,2,3,4]
Output: [[4,3,2,1]]
Explanation: All elements of the array are distinct, so we can keep all of them in the first row of the 2D array.
","class Solution:
    def findMatrix(self, nums: List[int]) -> List[List[int]]:
        res = []

        # Iterate over the input array
        for num in nums:
            # Try to add the number to an existing row
            for row in res:
                if num not in row:
                    row.add(num)
                    break
            else:
                # If no such row is found, create a new one
                res.append(set([num]))

        # Convert sets to lists for the final result
        return [list(row) for row in res]",True
Number of Senior Citizens,"You are given a 0-indexed array of strings details. Each element of details provides information about a given passenger compressed into a string of length 15. The system is such that:
The first ten characters consist of the phone number of passengers.
The next character denotes the gender of the person.
The following two characters are used to indicate the age of the person.
The last two characters determine the seat allotted to that person.
Return the number of passengers who are strictly more than 60 years old.
","Example 1:
Input: details = [""7868190130M7522"",""5303914400F9211"",""9273338290F4010""]
Output: 2
Explanation: The passengers at indices 0, 1, and 2 have ages 75, 92, and 40. Thus, there are 2 people who are over 60 years old.
Example 2:
Input: details = [""1313579440F2036"",""2921522980M5644""]
Output: 0
Explanation: None of the passengers are older than 60.
",,False
Sum in a Matrix,"You are given a 0-indexed 2D integer array nums. Initially, your score is 0. Perform the following operations until the matrix becomes empty:
From each row in the matrix, select the largest number and remove it. In the case of a tie, it does not matter which number is chosen.
Identify the highest number amongst all those removed in step 1. Add that number to your score.
Return the final score.
","Example 1:
Input: nums = [[7,2,1],[6,4,2],[6,5,3],[3,2,1]]
Output: 15
Explanation: In the first operation, we remove 7, 6, 6, and 3. We then add 7 to our score. Next, we remove 2, 4, 5, and 2. We add 5 to our score. Lastly, we remove 1, 2, 3, and 1. We add 3 to our score. Thus, our final score is 7 + 5 + 3 = 15.
Example 2:
Input: nums = [[1]]
Output: 1
Explanation: We remove 1 and add it to the answer. We return 1.
",,False
Maximum OR,"You are given a 0-indexed integer array nums of length n and an integer k. In an operation, you can choose an element and multiply it by 2.
Return the maximum possible value of nums[0] | nums[1] | ... | nums[n - 1] that can be obtained after applying the operation on nums at most k times.
Note that a | b denotes the bitwise or between two integers a and b.
","Example 1:
Input: nums = [12,9], k = 1
Output: 30
Explanation: If we apply the operation to index 1, our new array nums will be equal to [12,18]. Thus, we return the bitwise or of 12 and 18, which is 30.
Example 2:
Input: nums = [8,1,2], k = 2
Output: 35
Explanation: If we apply the operation twice on index 0, we yield a new array of [32,1,2]. Thus, we return 32|1|2 = 35.
","class Solution:
    def maximumOr(self, nums: List[int], k: int) -> int:
        cur = 0
        saved = 0
        for num in nums:
            saved |= num & cur
            cur |= num
        
        max_num = 0
        
        for num in nums:
            max_num = max(max_num, saved | (cur & ~num) | num << k)
        return max_num
        ",True
Row With Maximum Ones,"Given a m x n binary matrix mat, find the 0-indexed position of the row that contains the maximum count of ones, and the number of ones in that row.
In case there are multiple rows that have the maximum count of ones, the row with the smallest row number should be selected.
Return an array containing the index of the row, and the number of ones in it.
","Example 1:
Input: mat = [[0,1],[1,0]]
Output: [0,1]
Explanation: Both rows have the same number of 1's. So we return the index of the smaller row, 0, and the maximum count of ones (1). So, the answer is [0,1]. 
Example 2:
Input: mat = [[0,0,0],[0,1,1]]
Output: [1,2]
Explanation: The row indexed 1 has the maximum count of ones (2). So we return its index, 1, and the count. So, the answer is [1,2].
Example 3:
Input: mat = [[0,0],[1,1],[0,0]]
Output: [1,2]
Explanation: The row indexed 1 has the maximum count of ones (2). So the answer is [1,2].
","class Solution:
    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:
        maxcount=0
        res=[0,0]
        for i,row in enumerate(mat):
            count=sum(row)
            if maxcount<count:
                res=[i,count]
                maxcount=count
        return res
        ",True
Sliding Subarray Beauty,"Given an integer array nums containing n integers, find the beauty of each subarray of size k.
The beauty of a subarray is the xth smallest integer in the subarray if it is negative, or 0 if there are fewer than x negative integers.
Return an integer array containing n - k + 1 integers, which denote the beauty of the subarrays in order from the first index in the array.
A subarray is a contiguous non-empty sequence of elements within an array.
","Example 1:
Input: nums = [1,-1,-3,-2,3], k = 3, x = 2
Output: [-1,-2,-2]
Explanation: There are 3 subarrays with size k = 3. 
The first subarray is [1, -1, -3] and the 2nd smallest negative integer is -1. 
The second subarray is [-1, -3, -2] and the 2nd smallest negative integer is -2. 
The third subarray is [-3, -2, 3] and the 2nd smallest negative integer is -2.
Example 2:
Input: nums = [-1,-2,-3,-4,-5], k = 2, x = 2
Output: [-1,-2,-3,-4]
Explanation: There are 4 subarrays with size k = 2.
For [-1, -2], the 2nd smallest negative integer is -1.
For [-2, -3], the 2nd smallest negative integer is -2.
For [-3, -4], the 2nd smallest negative integer is -3.
For [-4, -5], the 2nd smallest negative integer is -4. 
Example 3:
Input: nums = [-3,1,2,-3,0,-3], k = 2, x = 1
Output: [-3,0,-3,-3,-3]
Explanation: There are 5 subarrays with size k = 2.
For [-3, 1], the 1st smallest negative integer is -3.
For [1, 2], there is no negative integer so the beauty is 0.
For [2, -3], the 1st smallest negative integer is -3.
For [-3, 0], the 1st smallest negative integer is -3.
For [0, -3], the 1st smallest negative integer is -3.
",,False
Minimum Number of Operations to Make All Array Elements Equal to 1,"You are given a 0-indexed array nums consisiting of positive integers. You can do the following operation on the array any number of times:
Select an index i such that 0 <= i < n - 1 and replace either of nums[i] or nums[i+1] with their gcd value.
Return the minimum number of operations to make all elements of nums equal to 1. If it is impossible, return -1.
The gcd of two integers is the greatest common divisor of the two integers.
","Example 1:
Input: nums = [2,6,3,4]
Output: 4
Explanation: We can do the following operations:
- Choose index i = 2 and replace nums[2] with gcd(3,4) = 1. Now we have nums = [2,6,1,4].
- Choose index i = 1 and replace nums[1] with gcd(6,1) = 1. Now we have nums = [2,1,1,4].
- Choose index i = 0 and replace nums[0] with gcd(2,1) = 1. Now we have nums = [1,1,1,4].
- Choose index i = 2 and replace nums[3] with gcd(1,4) = 1. Now we have nums = [1,1,1,1].
Example 2:
Input: nums = [2,10,6,14]
Output: -1
Explanation: It can be shown that it is impossible to make all the elements equal to 1.
","class Solution:
    def minOperations(self, nums):
        n, ones, diff = len(nums), nums.count(1), float(""inf"")

        if ones: return n-ones

        for i in range(n):
            val = nums[i]
            for j in range(i+1,n):
                val = gcd(val,nums[j])
                if val == 1:
                    diff = min(diff,j-i+(n-1))
                    break

        return -1 if diff == float(""inf"") else diff",True
Maximum Strength of a Group,"You are given a 0-indexed integer array nums representing the score of students in an exam. The teacher would like to form one non-empty group of students with maximal strength, where the strength of a group of students of indices i0, i1, i2, ... , ik is defined as nums[i0] * nums[i1] * nums[i2] * ... * nums[ik].
Return the maximum strength of a group the teacher can create.
","Example 1:
Input: nums = [3,-1,-5,2,5,-9]
Output: 1350
Explanation: One way to form a group of maximal strength is to group the students at indices [0,2,3,4,5]. Their strength is 3 * (-5) * 2 * 5 * (-9) = 1350, which we can show is optimal.
Example 2:
Input: nums = [-4,-5,-4]
Output: 20
Explanation: Group the students at indices [0, 1] . Then, we’ll have a resulting strength of 20. We cannot achieve greater strength.
","class Solution:
    def maxStrength(self, nums: List[int]) -> int:
        pos,neg=[],[]

        if len(nums)==1:
            return nums[0]

        for x in nums:
            if x>0:
                pos.append(x)
            elif x<0:
                neg.append(-x)

        neg.sort(reverse=True)
        
        if len(neg)%2==1:
            neg.pop()

        if len(neg)==0 and len(pos)==0:
            return 0
        else:
            res=1
            for x in neg: res*=x
            for x in pos: res*=x
            return res
       ",True
Extra Characters in a String,"You are given a 0-indexed string s and a dictionary of words dictionary. You have to break s into one or more non-overlapping substrings such that each substring is present in dictionary. There may be some extra characters in s which are not present in any of the substrings.
Return the minimum number of extra characters left over if you break up s optimally.
","Example 1:
Input: s = ""leetscode"", dictionary = [""leet"",""code"",""leetcode""]
Output: 1
Explanation: We can break s in two substrings: ""leet"" from index 0 to 3 and ""code"" from index 5 to 8. There is only 1 unused character (at index 4), so we return 1.
Example 2:
Input: s = ""sayhelloworld"", dictionary = [""hello"",""world""]
Output: 3
Explanation: We can break s in two substrings: ""hello"" from index 3 to 7 and ""world"" from index 8 to 12. The characters at indices 0, 1, 2 are not used in any substring and thus are considered as extra characters. Hence, we return 3.
","class Solution:
    def minExtraChar(self, s: str, dictionary: List[str]) -> int:

        # Build a trie with reversed words in dictionary
        trie = {}
        for w in dictionary:
            w = reversed(w)
            cur = trie
            for c in w:
                if c not in cur:
                    cur[c] = {}
                cur = cur[c]
            cur['match'] = True

        def getDictWord(i, trie, s):
            '''Retrieve the lookback indices with revserd trie and index.'''
            cur = trie
            res = []
            for j in range(i+1)[::-1]:
                if s[j] in cur:
                    cur = cur[s[j]]
                    if 'match' in cur:
                        res += [j]
                else:
                    break
            return res


        n = len(s)
        dp = []
        for i in range(n):
            # - Fetch lookback indices
            lookback = getDictWord(i, trie, s)
            # - Initial cost
            if dp:
                v = dp[-1] + 1
            else:
                v = 1
            # - Optimized the cost with lookback indices
            if lookback:
                for j in lookback:
                    if j == 0:
                        v = 0
                        break
                    v = min(v, dp[j-1])
            dp += [v]
        return dp[-1]
",True
Buy Two Chocolates,"You are given an integer array prices representing the prices of various chocolates in a store. You are also given a single integer money, which represents your initial amount of money.
You must buy exactly two chocolates in such a way that you still have some non-negative leftover money. You would like to minimize the sum of the prices of the two chocolates you buy.
Return the amount of money you will have leftover after buying the two chocolates. If there is no way for you to buy two chocolates without ending up in debt, return money. Note that the leftover must be non-negative.
","Example 1:
Input: prices = [1,2,2], money = 3
Output: 0
Explanation: Purchase the chocolates priced at 1 and 2 units respectively. You will have 3 - 3 = 0 units of money afterwards. Thus, we return 0.
Example 2:
Input: prices = [3,2,3], money = 3
Output: 3
Explanation: You cannot buy 2 chocolates without going in debt, so we return 3.
","class Solution {
public:
    int buyChoco(vector<int>& prices, int money) {
          int n=prices.size();
          int n1=prices[0],n2=prices[1];
          if(n1>n2){swap(n1,n2);}
          for(int i=2;i<n;i++){
              if(n1>prices[i]){
                  n2=n1;
                  n1=prices[i];
              }else if(n2>prices[i]){
                  n2=prices[i];
              }
          }
          if(n1+n2<=money){
              return (money-n1-n2);
          }return money;
    }
};",False
Maximum Number of Fish in a Grid,"You are given a 0-indexed 2D matrix grid of size m x n, where (r, c) represents:
A land cell if grid[r][c] = 0, or
A water cell containing grid[r][c] fish, if grid[r][c] > 0.
A fisher can start at any water cell (r, c) and can do the following operations any number of times:
Catch all the fish at cell (r, c), or
Move to any adjacent water cell.
Return the maximum number of fish the fisher can catch if he chooses his starting cell optimally, or 0 if no water cell exists.
An adjacent cell of the cell (r, c), is one of the cells (r, c + 1), (r, c - 1), (r + 1, c) or (r - 1, c) if it exists.
","Example 1:

Input: grid = [[0,2,1,0],[4,0,0,3],[1,0,0,4],[0,3,2,0]]
Output: 7
Explanation: The fisher can start at cell (1,3) and collect 3 fish, then move to cell (2,3) and collect 4 fish.
Example 2:

Input: grid = [[1,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,1]]
Output: 1
Explanation: The fisher can start at cells (0,0) or (3,3) and collect a single fish. 
",,False
Find the Prefix Common Array of Two Arrays,"You are given two 0-indexed integer permutations A and B of length n.
A prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.
Return the prefix common array of A and B.
A sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.
","Example 1:
Input: A = [1,3,2,4], B = [3,1,2,4]
Output: [0,2,3,4]
Explanation: At i = 0: no number is common, so C[0] = 0.
At i = 1: 1 and 3 are common in A and B, so C[1] = 2.
At i = 2: 1, 2, and 3 are common in A and B, so C[2] = 3.
At i = 3: 1, 2, 3, and 4 are common in A and B, so C[3] = 4.
Example 2:
Input: A = [2,3,1], B = [3,1,2]
Output: [0,1,3]
Explanation: At i = 0: no number is common, so C[0] = 0.
At i = 1: only 3 is common in A and B, so C[1] = 1.
At i = 2: 1, 2, and 3 are common in A and B, so C[2] = 3.
","class Solution:
    def findThePrefixCommonArray(self, a: list[int], b: list[int]) -> list[int]:
        prefix_array = []
        a_mask = 0
        b_mask = 0

        for a_num, b_num in zip(a, b):
            a_mask ^= (1 << a_num)
            b_mask ^= (1 << b_num)
            prefix_array.append((a_mask & b_mask).bit_count())
        
        return prefix_array",True
Maximum Sum With Exactly K Elements ,"You are given a 0-indexed integer array nums and an integer k. Your task is to perform the following operation exactly k times in order to maximize your score:
Select an element m from nums.
Remove the selected element m from the array.
Add a new element with a value of m + 1 to the array.
Increase your score by m.
Return the maximum score you can achieve after performing the operation exactly k times.
","Example 1:
Input: nums = [1,2,3,4,5], k = 3
Output: 18
Explanation: We need to choose exactly 3 elements from nums to maximize the sum.
For the first iteration, we choose 5. Then sum is 5 and nums = [1,2,3,4,6]
For the second iteration, we choose 6. Then sum is 5 + 6 and nums = [1,2,3,4,7]
For the third iteration, we choose 7. Then sum is 5 + 6 + 7 = 18 and nums = [1,2,3,4,8]
So, we will return 18.
It can be proven, that 18 is the maximum answer that we can achieve.
Example 2:
Input: nums = [5,5,5], k = 2
Output: 11
Explanation: We need to choose exactly 2 elements from nums to maximize the sum.
For the first iteration, we choose 5. Then sum is 5 and nums = [5,5,6]
For the second iteration, we choose 6. Then sum is 5 + 6 = 11 and nums = [5,5,7]
So, we will return 11.
It can be proven, that 11 is the maximum answer that we can achieve.
","class Solution {
public:
    int maximizeSum(vector<int>& nums, int k) {
        sort(nums.begin(),nums.end());
        
        int n = nums[nums.size()-1];
        int ans = nums[nums.size()-1];
        for(int i = 1; i<k; i++){
            n+=1;
            ans+=n;
        }
        return ans;
    }
};

",False
Find the Distinct Difference Array,"You are given a 0-indexed array nums of length n.
The distinct difference array of nums is an array diff of length n such that diff[i] is equal to the number of distinct elements in the suffix nums[i + 1, ..., n - 1] subtracted from the number of distinct elements in the prefix nums[0, ..., i].
Return the distinct difference array of nums.
Note that nums[i, ..., j] denotes the subarray of nums starting at index i and ending at index j inclusive. Particularly, if i > j then nums[i, ..., j] denotes an empty subarray.
","Example 1:
Input: nums = [1,2,3,4,5]
Output: [-3,-1,1,3,5]
Explanation: For index i = 0, there is 1 element in the prefix and 4 distinct elements in the suffix. Thus, diff[0] = 1 - 4 = -3.
For index i = 1, there are 2 distinct elements in the prefix and 3 distinct elements in the suffix. Thus, diff[1] = 2 - 3 = -1.
For index i = 2, there are 3 distinct elements in the prefix and 2 distinct elements in the suffix. Thus, diff[2] = 3 - 2 = 1.
For index i = 3, there are 4 distinct elements in the prefix and 1 distinct element in the suffix. Thus, diff[3] = 4 - 1 = 3.
For index i = 4, there are 5 distinct elements in the prefix and no elements in the suffix. Thus, diff[4] = 5 - 0 = 5.
Example 2:
Input: nums = [3,2,3,4,2]
Output: [-2,-1,0,2,3]
Explanation: For index i = 0, there is 1 element in the prefix and 3 distinct elements in the suffix. Thus, diff[0] = 1 - 3 = -2.
For index i = 1, there are 2 distinct elements in the prefix and 3 distinct elements in the suffix. Thus, diff[1] = 2 - 3 = -1.
For index i = 2, there are 2 distinct elements in the prefix and 2 distinct elements in the suffix. Thus, diff[2] = 2 - 2 = 0.
For index i = 3, there are 3 distinct elements in the prefix and 1 distinct element in the suffix. Thus, diff[3] = 3 - 1 = 2.
For index i = 4, there are 3 distinct elements in the prefix and no elements in the suffix. Thus, diff[4] = 3 - 0 = 3.
",,False
Number of Adjacent Elements With the Same Color,"You are given an integer n representing an array colors of length n where all elements are set to 0's meaning uncolored. You are also given a 2D integer array queries where queries[i] = [indexi, colori]. For the ith query:
Set colors[indexi] to colori.
Count adjacent pairs in colors set to the same color (regardless of colori).
Return an array answer of the same length as queries where answer[i] is the answer to the ith query.
","Example 1:
Input: n = 4, queries = [[0,2],[1,2],[3,1],[1,1],[2,1]]
Output: [0,1,1,0,2]
Explanation:
Initially array colors = [0,0,0,0], where 0 denotes uncolored elements of the array.
After the 1st query colors = [2,0,0,0]. The count of adjacent pairs with the same color is 0.
After the 2nd query colors = [2,2,0,0]. The count of adjacent pairs with the same color is 1.
After the 3rd query colors = [2,2,0,1]. The count of adjacent pairs with the same color is 1.
After the 4th query colors = [2,1,0,1]. The count of adjacent pairs with the same color is 0.
After the 5th query colors = [2,1,1,1]. The count of adjacent pairs with the same color is 2.
Example 2:
Input: n = 1, queries = [[0,100000]]
Output: [0]
Explanation:
After the 1st query colors = [100000]. The count of adjacent pairs with the same color is 0.
","class Solution:
    def colorTheArray(self, n, queries):
        ans, nums, count = [], [0]*n, 0

        for i in range(len(queries)):
            index, color = queries[i][0], queries[i][1]

            if index-1 >= 0 and nums[index] != 0 and nums[index-1] == nums[index]:
                count -= 1
            if index+1 < n and nums[index] != 0 and nums[index+1] == nums[index]:
                count -= 1

            nums[index] = color

            if index-1 >= 0 and nums[index] != 0 and nums[index-1] == nums[index]:
                count += 1
            if index+1 < n and nums[index] != 0 and nums[index+1] == nums[index]:
                count += 1

            ans.append(count)

        return ans

            




",True
Make Costs of Paths Equal in a Binary Tree,"You are given an integer n representing the number of nodes in a perfect binary tree consisting of nodes numbered from 1 to n. The root of the tree is node 1 and each node i in the tree has two children where the left child is the node 2 * i and the right child is 2 * i + 1.
Each node in the tree also has a cost represented by a given 0-indexed integer array cost of size n where cost[i] is the cost of node i + 1. You are allowed to increment the cost of any node by 1 any number of times.
Return the minimum number of increments you need to make the cost of paths from the root to each leaf node equal.
Note:
A perfect binary tree is a tree where each node, except the leaf nodes, has exactly 2 children.
The cost of a path is the sum of costs of nodes in the path.
","Example 1:

Input: n = 7, cost = [1,5,2,2,3,3,1]
Output: 6
Explanation: We can do the following increments:
- Increase the cost of node 4 one time.
- Increase the cost of node 3 three times.
- Increase the cost of node 7 two times.
Each path from the root to a leaf will have a total cost of 9.
The total increments we did is 1 + 3 + 2 = 6.
It can be shown that this is the minimum answer we can achieve.
Example 2:

Input: n = 3, cost = [5,3,3]
Output: 0
Explanation: The two paths already have equal total costs, so no increments are needed.
","class Solution:
    def minIncrements(self, n: int, cost: List[int]) -> int:
        idx, ans = n - 1, 0
        while idx >= 2:
            parent_idx = idx // 2 - 1
            child_cost = cost[idx]
            if cost[idx] != cost[idx - 1]:
                child_cost = max(cost[idx], cost[idx - 1])
                ans += abs(cost[idx] - cost[idx - 1])
            cost[parent_idx] += child_cost
            idx -= 2
        return ans",True
Semi-Ordered Permutation,"You are given a 0-indexed permutation of n integers nums.
A permutation is called semi-ordered if the first number equals 1 and the last number equals n. You can perform the below operation as many times as you want until you make nums a semi-ordered permutation:
Pick two adjacent elements in nums, then swap them.
Return the minimum number of operations to make nums a semi-ordered permutation.
A permutation is a sequence of integers from 1 to n of length n containing each number exactly once.
","Example 1:
Input: nums = [2,1,4,3]
Output: 2
Explanation: We can make the permutation semi-ordered using these sequence of operations: 
1 - swap i = 0 and j = 1. The permutation becomes [1,2,4,3].
2 - swap i = 2 and j = 3. The permutation becomes [1,2,3,4].
It can be proved that there is no sequence of less than two operations that make nums a semi-ordered permutation. 
Example 2:
Input: nums = [2,4,1,3]
Output: 3
Explanation: We can make the permutation semi-ordered using these sequence of operations:
1 - swap i = 1 and j = 2. The permutation becomes [2,1,4,3].
2 - swap i = 0 and j = 1. The permutation becomes [1,2,4,3].
3 - swap i = 2 and j = 3. The permutation becomes [1,2,3,4].
It can be proved that there is no sequence of less than three operations that make nums a semi-ordered permutation.
Example 3:
Input: nums = [1,3,4,2,5]
Output: 0
Explanation: The permutation is already a semi-ordered permutation.
","class Solution {
public:
    int semiOrderedPermutation(vector<int>& nums) {
        int n=nums.size();
        int cnt=0;
        bool f=false;
        while(f==false){
               for(int i=0;i<n;i++){
                   if(nums[i]==n & i!=(n-1)){
                       swap(nums[i],nums[i+1]);
                       cnt++;
                   }
                   if(nums[i]==1 && i!=0){
                       swap(nums[i], nums[i-1]);
                       cnt++;
                   }
               }
               if(nums[0]==1 && nums[n-1]==n){
                   f=true;
               }

        }
        return cnt;
    }
};",False
Movement of Robots,"Some robots are standing on an infinite number line with their initial coordinates given by a 0-indexed integer array nums and will start moving once given the command to move. The robots will move a unit distance each second.
You are given a string s denoting the direction in which robots will move on command. 'L' means the robot will move towards the left side or negative side of the number line, whereas 'R' means the robot will move towards the right side or positive side of the number line.
If two robots collide, they will start moving in opposite directions.
Return the sum of distances between all the pairs of robots d seconds after the command. Since the sum can be very large, return it modulo 109 + 7.
Note:
For two robots at the index i and j, pair (i,j) and pair (j,i) are considered the same pair.
When robots collide, they instantly change their directions without wasting any time.
Collision happens when two robots share the same place in a moment.
For example, if a robot is positioned in 0 going to the right and another is positioned in 2 going to the left, the next second they'll be both in 1 and they will change direction and the next second the first one will be in 0, heading left, and another will be in 2, heading right.
For example, if a robot is positioned in 0 going to the right and another is positioned in 1 going to the left, the next second the first one will be in 0, heading left, and another will be in 1, heading right.
","Example 1:
Input: nums = [-2,0,2], s = ""RLL"", d = 3
Output: 8
Explanation: 
After 1 second, the positions are [-1,-1,1]. Now, the robot at index 0 will move left, and the robot at index 1 will move right.
After 2 seconds, the positions are [-2,0,0]. Now, the robot at index 1 will move left, and the robot at index 2 will move right.
After 3 seconds, the positions are [-3,-1,1].
The distance between the robot at index 0 and 1 is abs(-3 - (-1)) = 2.
The distance between the robot at index 0 and 2 is abs(-3 - 1) = 4.
The distance between the robot at index 1 and 2 is abs(-1 - 1) = 2.
The sum of the pairs of all distances = 2 + 4 + 2 = 8.
Example 2:
Input: nums = [1,0], s = ""RL"", d = 2
Output: 5
Explanation: 
After 1 second, the positions are [2,-1].
After 2 seconds, the positions are [3,-2].
The distance between the two robots is abs(-2 - 3) = 5.
","class Solution:
    def sumDistance(self, nums: List[int], s: str, d: int) -> int:
        for i in range(len(s)):
            if s[i] == 'L':
                nums[i] -= d
            else:
                nums[i] += d
                
        ans = 0
        nums.sort()
        mod = 10 ** 9 + 7
        s = 0
        
        for i in range(len(nums)):
            ans += (nums[i] * i - s)
            s += nums[i]
            ans %= mod
            s %= mod
        
        return ans % mod",True
Find the Losers of the Circular Game,"There are n friends that are playing a game. The friends are sitting in a circle and are numbered from 1 to n in clockwise order. More formally, moving clockwise from the ith friend brings you to the (i+1)th friend for 1 <= i < n, and moving clockwise from the nth friend brings you to the 1st friend.
The rules of the game are as follows:
1st friend receives the ball.
After that, 1st friend passes it to the friend who is k steps away from them in the clockwise direction.
After that, the friend who receives the ball should pass it to the friend who is 2 * k steps away from them in the clockwise direction.
After that, the friend who receives the ball should pass it to the friend who is 3 * k steps away from them in the clockwise direction, and so on and so forth.
In other words, on the ith turn, the friend holding the ball should pass it to the friend who is i * k steps away from them in the clockwise direction.
The game is finished when some friend receives the ball for the second time.
The losers of the game are friends who did not receive the ball in the entire game.
Given the number of friends, n, and an integer k, return the array answer, which contains the losers of the game in the ascending order.
","Example 1:
Input: n = 5, k = 2
Output: [4,5]
Explanation: The game goes as follows:
1) Start at 1st friend and pass the ball to the friend who is 2 steps away from them - 3rd friend.
2) 3rd friend passes the ball to the friend who is 4 steps away from them - 2nd friend.
3) 2nd friend passes the ball to the friend who is 6 steps away from them  - 3rd friend.
4) The game ends as 3rd friend receives the ball for the second time.
Example 2:
Input: n = 4, k = 4
Output: [2,3,4]
Explanation: The game goes as follows:
1) Start at the 1st friend and pass the ball to the friend who is 4 steps away from them - 1st friend.
2) The game ends as 1st friend receives the ball for the second time.
","class Solution:
    def circularGameLosers(self, n: int, k: int) -> List[int]:
        res = [i for i in range(1,n+1)]
        res.remove(1)
        curr = 1
        count = 1
        while True:
            curr = (curr+(count*k))%n
            if curr == 0:
                curr = n
            if curr not in res:
                return res
            else:
                res.remove(curr)
            count+=1                ",True
Neighboring Bitwise XOR,"A 0-indexed array derived with length n is derived by computing the bitwise XOR (⊕) of adjacent values in a binary array original of length n.
Specifically, for each index i in the range [0, n - 1]:
If i = n - 1, then derived[i] = original[i] ⊕ original[0].
Otherwise, derived[i] = original[i] ⊕ original[i + 1].
Given an array derived, your task is to determine whether there exists a valid binary array original that could have formed derived.
Return true if such an array exists or false otherwise.
A binary array is an array containing only 0's and 1's
","Example 1:
Input: derived = [1,1,0]
Output: true
Explanation: A valid original array that gives derived is [0,1,0].
derived[0] = original[0] ⊕ original[1] = 0 ⊕ 1 = 1 
derived[1] = original[1] ⊕ original[2] = 1 ⊕ 0 = 1
derived[2] = original[2] ⊕ original[0] = 0 ⊕ 0 = 0
Example 2:
Input: derived = [1,1]
Output: true
Explanation: A valid original array that gives derived is [0,1].
derived[0] = original[0] ⊕ original[1] = 1
derived[1] = original[1] ⊕ original[0] = 1
Example 3:
Input: derived = [1,0]
Output: false
Explanation: There is no valid original array that gives derived.
","class Solution {
public:
    bool doesValidArrayExist(vector<int>& derived) {
        return !accumulate(derived.begin(), derived.end(), 0, bit_xor<int>());
    }
};",False
Maximum Number of Moves in a Grid,"You are given a 0-indexed m x n matrix grid consisting of positive integers.
You can start at any cell in the first column of the matrix, and traverse the grid in the following way:
From a cell (row, col), you can move to any of the cells: (row - 1, col + 1), (row, col + 1) and (row + 1, col + 1) such that the value of the cell you move to, should be strictly bigger than the value of the current cell.
Return the maximum number of moves that you can perform.
","Example 1:

Input: grid = [[2,4,3,5],[5,4,9,3],[3,4,2,11],[10,9,13,15]]
Output: 3
Explanation: We can start at the cell (0, 0) and make the following moves:
- (0, 0) -> (0, 1).
- (0, 1) -> (1, 2).
- (1, 2) -> (2, 3).
It can be shown that it is the maximum number of moves that can be made.
Example 2:
Input: grid = [[3,2,4],[2,1,9],[1,1,7]]
Output: 0
Explanation: Starting from any cell in the first column we cannot perform any moves.
","class Solution:
    def maxMoves(self, grid: List[List[int]]) -> int:
        dp={}
        def dfs(i,j):
            n=0
            n1=0
            n2=0
            if((i,j) in dp):return dp[(i,j)]
            if(i-1>=0 and j+1<len(grid[0]) and grid[i][j]<grid[i-1][j+1]):
                n=1+dfs(i-1,j+1)
            if(i>=0 and i<len(grid) and j+1<len(grid[0])):
                if(i+1<len(grid) and grid[i+1][j+1]>grid[i][j]):
                    n1=1+dfs(i+1,j+1)
                if(grid[i][j+1]>grid[i][j]):
                    n2=1+dfs(i,j+1)
            dp[(i,j)]=max(n,n1,n2)
            return dp[(i,j)]
        res=0
        for i in range(len(grid)):
            res=max(res,dfs(i,0))
        return res",True
Difference of Number of Distinct Values on Diagonals,"Given a 2D grid of size m x n, you should find the matrix answer of size m x n.
The cell answer[r][c] is calculated by looking at the diagonal values of the cell grid[r][c]:
Let leftAbove[r][c] be the number of distinct values on the diagonal to the left and above the cell grid[r][c] not including the cell grid[r][c] itself.
Let rightBelow[r][c] be the number of distinct values on the diagonal to the right and below the cell grid[r][c], not including the cell grid[r][c] itself.
Then answer[r][c] = |leftAbove[r][c] - rightBelow[r][c]|.
A matrix diagonal is a diagonal line of cells starting from some cell in either the topmost row or leftmost column and going in the bottom-right direction until the end of the matrix is reached.
For example, in the below diagram the diagonal is highlighted using the cell with indices (2, 3) colored gray:
Red-colored cells are left and above the cell.
Blue-colored cells are right and below the cell.

Return the matrix answer.
","Example 1:
Input: grid = [[1,2,3],[3,1,5],[3,2,1]]
Output: Output: [[1,1,0],[1,0,1],[0,1,1]]
Explanation:
To calculate the answer cells:
answer left-above elements leftAbove right-below elements rightBelow |leftAbove - rightBelow|
[0][0] [] 0 [grid[1][1], grid[2][2]] |{1, 1}| = 1 1
[0][1] [] 0 [grid[1][2]] |{5}| = 1 1
[0][2] [] 0 [] 0 0
[1][0] [] 0 [grid[2][1]] |{2}| = 1 1
[1][1] [grid[0][0]] |{1}| = 1 [grid[2][2]] |{1}| = 1 0
[1][2] [grid[0][1]] |{2}| = 1 [] 0 1
[2][0] [] 0 [] 0 0
[2][1] [grid[1][0]] |{3}| = 1 [] 0 1
[2][2] [grid[0][0], grid[1][1]] |{1, 1}| = 1 [] 0 1
Example 2:
Input: grid = [[1]]
Output: Output: [[0]]
","class Solution:
    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:
        row, col = len(grid), len(grid[0])
        ans = [[0] * col for i in range(row)]
        
        start = set([(i,0)for i in range(len(grid))]) | set([(0,i) for i in range(len(grid[0]))])
        for (i,j) in start:
            upper_dict = defaultdict(int)
            lower_dict = defaultdict(int)
            for j1 in range(len(grid)):
                if 0<= i +j1< row and 0<= j+j1< col:
                    lower_dict[grid[i+j1][j+j1]] += 1
            for j1 in range(len(grid)):
                if 0<= i +j1< row and 0<= j+j1< col:
                    ele = grid[i+j1][j+j1]
                    lower_dict[ele] -= 1
                    if lower_dict[ele] == 0: lower_dict.pop(ele)
                    ans[i+j1][j+j1] = abs(len(lower_dict) - len(upper_dict))
                    upper_dict[ele] += 1
            
        return ans        ",True
Number of Beautiful Pairs,"You are given a 0-indexed integer array nums. A pair of indices i, j where 0 <= i < j < nums.length is called beautiful if the first digit of nums[i] and the last digit of nums[j] are coprime.
Return the total number of beautiful pairs in nums.
Two integers x and y are coprime if there is no integer greater than 1 that divides both of them. In other words, x and y are coprime if gcd(x, y) == 1, where gcd(x, y) is the greatest common divisor of x and y.
","Example 1:
Input: nums = [2,5,1,4]
Output: 5
Explanation: There are 5 beautiful pairs in nums:
When i = 0 and j = 1: the first digit of nums[0] is 2, and the last digit of nums[1] is 5. We can confirm that 2 and 5 are coprime, since gcd(2,5) == 1.
When i = 0 and j = 2: the first digit of nums[0] is 2, and the last digit of nums[2] is 1. Indeed, gcd(2,1) == 1.
When i = 1 and j = 2: the first digit of nums[1] is 5, and the last digit of nums[2] is 1. Indeed, gcd(5,1) == 1.
When i = 1 and j = 3: the first digit of nums[1] is 5, and the last digit of nums[3] is 4. Indeed, gcd(5,4) == 1.
When i = 2 and j = 3: the first digit of nums[2] is 1, and the last digit of nums[3] is 4. Indeed, gcd(1,4) == 1.
Thus, we return 5.
Example 2:
Input: nums = [11,21,12]
Output: 2
Explanation: There are 2 beautiful pairs:
When i = 0 and j = 1: the first digit of nums[0] is 1, and the last digit of nums[1] is 1. Indeed, gcd(1,1) == 1.
When i = 0 and j = 2: the first digit of nums[0] is 1, and the last digit of nums[2] is 2. Indeed, gcd(1,2) == 1.
Thus, we return 2.
",,False
Relocate Marbles,"You are given a 0-indexed integer array nums representing the initial positions of some marbles. You are also given two 0-indexed integer arrays moveFrom and moveTo of equal length.
Throughout moveFrom.length steps, you will change the positions of the marbles. On the ith step, you will move all marbles at position moveFrom[i] to position moveTo[i].
After completing all the steps, return the sorted list of occupied positions.
Notes:
We call a position occupied if there is at least one marble in that position.
There may be multiple marbles in a single position.
","Example 1:
Input: nums = [1,6,7,8], moveFrom = [1,7,2], moveTo = [2,9,5]
Output: [5,6,8,9]
Explanation: Initially, the marbles are at positions 1,6,7,8.
At the i = 0th step, we move the marbles at position 1 to position 2. Then, positions 2,6,7,8 are occupied.
At the i = 1st step, we move the marbles at position 7 to position 9. Then, positions 2,6,8,9 are occupied.
At the i = 2nd step, we move the marbles at position 2 to position 5. Then, positions 5,6,8,9 are occupied.
At the end, the final positions containing at least one marbles are [5,6,8,9].
Example 2:
Input: nums = [1,1,3,3], moveFrom = [1,3], moveTo = [2,2]
Output: [2]
Explanation: Initially, the marbles are at positions [1,1,3,3].
At the i = 0th step, we move all the marbles at position 1 to position 2. Then, the marbles are at positions [2,2,3,3].
At the i = 1st step, we move all the marbles at position 3 to position 2. Then, the marbles are at positions [2,2,2,2].
Since 2 is the only occupied position, we return [2].
","class Solution:
    def relocateMarbles(self, nums: List[int], f: List[int], t: List[int]) -> List[int]:
        d = {}
        for i in nums:
            if i not in d:
                d[i] = 1
            else:
                d[i]+=1
        # print(d)
        for i,j in zip(f,t):
            if d.get(i) is not None:
                a = d[i]
                del d[i]
                d[j] = a        
        l = []
        for i in d:
            l += [i]*d[i]
        l.sort()
        return sorted(list((set(l))))
        
        ",True
Neither Minimum nor Maximum,"Given an integer array nums containing distinct positive integers, find and return any number from the array that is neither the minimum nor the maximum value in the array, or -1 if there is no such number.
Return the selected integer.
","Example 1:
Input: nums = [3,2,1,4]
Output: 2
Explanation: In this example, the minimum value is 1 and the maximum value is 4. Therefore, either 2 or 3 can be valid answers.
Example 2:
Input: nums = [1,2]
Output: -1
Explanation: Since there is no number in nums that is neither the maximum nor the minimum, we cannot select a number that satisfies the given condition. Therefore, there is no answer.
Example 3:
Input: nums = [2,1,3]
Output: 2
Explanation: Since 2 is neither the maximum nor the minimum value in nums, it is the only valid answer. 
","class Solution:
    def findNonMinOrMax(self, nums: List[int]) -> int:
        minimum, maximum = min(nums), max(nums)
        return next((num for num in nums if num not in (minimum, maximum)), -1)",True
Sum of Matrix After Queries,"You are given an integer n and a 0-indexed 2D array queries where queries[i] = [typei, indexi, vali].
Initially, there is a 0-indexed n x n matrix filled with 0's. For each query, you must apply one of the following changes:
if typei == 0, set the values in the row with indexi to vali, overwriting any previous values.
if typei == 1, set the values in the column with indexi to vali, overwriting any previous values.
Return the sum of integers in the matrix after all queries are applied.
","Example 1:

Input: n = 3, queries = [[0,0,1],[1,2,2],[0,2,3],[1,0,4]]
Output: 23
Explanation: The image above describes the matrix after each query. The sum of the matrix after all queries are applied is 23. 
Example 2:

Input: n = 3, queries = [[0,0,4],[0,1,2],[1,0,1],[0,2,3],[1,2,1]]
Output: 17
Explanation: The image above describes the matrix after each query. The sum of the matrix after all queries are applied is 17.
","class Solution:
    def matrixSumQueries(self, n, queries):
        ans = 0
        rsum = 0
        csum = 0
        mpr = {}
        mpc = {}
        queries.reverse()
        
        for it in queries:
            if it[0] == 0:
                # row
                r = it[1]
                val = it[2]
                if r not in mpr:
                    rsum += 1
                    mpr[r] = val
                    ans += val * (n - csum)
            else:
                # col
                c = it[1]
                val = it[2]
                if c not in mpc:
                    csum += 1
                    mpc[c] = val
                    ans += val * (n - rsum)
        
        return ans",True
Sum of Squares of Special Elements ,"You are given a 1-indexed integer array nums of length n.
An element nums[i] of nums is called special if i divides n, i.e. n % i == 0.
Return the sum of the squares of all special elements of nums.
","Example 1:
Input: nums = [1,2,3,4]
Output: 21
Explanation: There are exactly 3 special elements in nums: nums[1] since 1 divides 4, nums[2] since 2 divides 4, and nums[4] since 4 divides 4. 
Hence, the sum of the squares of all special elements of nums is nums[1] * nums[1] + nums[2] * nums[2] + nums[4] * nums[4] = 1 * 1 + 2 * 2 + 4 * 4 = 21.  
Example 2:
Input: nums = [2,7,1,19,18,3]
Output: 63
Explanation: There are exactly 4 special elements in nums: nums[1] since 1 divides 6, nums[2] since 2 divides 6, nums[3] since 3 divides 6, and nums[6] since 6 divides 6. 
Hence, the sum of the squares of all special elements of nums is nums[1] * nums[1] + nums[2] * nums[2] + nums[3] * nums[3] + nums[6] * nums[6] = 2 * 2 + 7 * 7 + 1 * 1 + 3 * 3 = 63. 
","class Solution:
    def sumOfSquares(self, nums: List[int]) -> int:
        #count of the sum of squares
        count=0
        #length of nums
        n=len(nums) 
        for i in range(0,n) :
            if  n%(i+1)==0:
                count+=nums[i]**2
        return count",True
Find the Value of the Partition,"You are given a positive integer array nums.
Partition nums into two arrays, nums1 and nums2, such that:
Each element of the array nums belongs to either the array nums1 or the array nums2.
Both arrays are non-empty.
The value of the partition is minimized.
The value of the partition is |max(nums1) - min(nums2)|.
Here, max(nums1) denotes the maximum element of the array nums1, and min(nums2) denotes the minimum element of the array nums2.
Return the integer denoting the value of such partition.
","Example 1:
Input: nums = [1,3,2,4]
Output: 1
Explanation: We can partition the array nums into nums1 = [1,2] and nums2 = [3,4].
- The maximum element of the array nums1 is equal to 2.
- The minimum element of the array nums2 is equal to 3.
The value of the partition is |2 - 3| = 1. 
It can be proven that 1 is the minimum value out of all partitions.
Example 2:
Input: nums = [100,1,10]
Output: 9
Explanation: We can partition the array nums into nums1 = [10] and nums2 = [100,1].
- The maximum element of the array nums1 is equal to 10.
- The minimum element of the array nums2 is equal to 1.
The value of the partition is |10 - 1| = 9.
It can be proven that 9 is the minimum value out of all partitions.
","class Solution {
public:
    int findValueOfPartition(vector<int>& nums) {
        int n= nums.size();
        sort(nums.begin(),nums.end());
        int mini= INT_MAX;
        for(int i=1; i<n; i++){
            mini= min(nums[i]-nums[i-1],mini);
        }
        return mini;
        
    }
};",False
Find Maximum Number of String Pairs,"You are given a 0-indexed array words consisting of distinct strings.
The string words[i] can be paired with the string words[j] if:
The string words[i] is equal to the reversed string of words[j].
0 <= i < j < words.length.
Return the maximum number of pairs that can be formed from the array words.
Note that each string can belong in at most one pair.
","Example 1:
Input: words = [""cd"",""ac"",""dc"",""ca"",""zz""]
Output: 2
Explanation: In this example, we can form 2 pair of strings in the following way:
- We pair the 0th string with the 2nd string, as the reversed string of word[0] is ""dc"" and is equal to words[2].
- We pair the 1st string with the 3rd string, as the reversed string of word[1] is ""ca"" and is equal to words[3].
It can be proven that 2 is the maximum number of pairs that can be formed.
Example 2:
Input: words = [""ab"",""ba"",""cc""]
Output: 1
Explanation: In this example, we can form 1 pair of strings in the following way:
- We pair the 0th string with the 1st string, as the reversed string of words[1] is ""ab"" and is equal to words[0].
It can be proven that 1 is the maximum number of pairs that can be formed.
Example 3:
Input: words = [""aa"",""ab""]
Output: 0
Explanation: In this example, we are unable to form any pair of strings.
","class Solution:
    def maximumNumberOfStringPairs(self, words: List[str]) -> int:
        strings = set()
        ans = 0
        for w in words:
            if w in strings:
                ans += 1
            else:
                strings.add(w[::-1])
        return ans",True
Decremental String Concatenation,"You are given a 0-indexed array words containing n strings.
Let's define a join operation join(x, y) between two strings x and y as concatenating them into xy. However, if the last character of x is equal to the first character of y, one of them is deleted.
For example join(""ab"", ""ba"") = ""aba"" and join(""ab"", ""cde"") = ""abcde"".
You are to perform n - 1 join operations. Let str0 = words[0]. Starting from i = 1 up to i = n - 1, for the ith operation, you can do one of the following:
Make stri = join(stri - 1, words[i])
Make stri = join(words[i], stri - 1)
Your task is to minimize the length of strn - 1.
Return an integer denoting the minimum possible length of strn - 1.
","Example 1:
Input: words = [""aa"",""ab"",""bc""]
Output: 4
Explanation: In this example, we can perform join operations in the following order to minimize the length of str2: 
str0 = ""aa""
str1 = join(str0, ""ab"") = ""aab""
str2 = join(str1, ""bc"") = ""aabc"" 
It can be shown that the minimum possible length of str2 is 4.
Example 2:
Input: words = [""ab"",""b""]
Output: 2
Explanation: In this example, str0 = ""ab"", there are two ways to get str1: 
join(str0, ""b"") = ""ab"" or join(""b"", str0) = ""bab"". 
The first string, ""ab"", has the minimum length. Hence, the answer is 2.
Example 3:
Input: words = [""aaa"",""c"",""aba""]
Output: 6
Explanation: In this example, we can perform join operations in the following order to minimize the length of str2: 
str0 = ""aaa""
str1 = join(str0, ""c"") = ""aaac""
str2 = join(""aba"", str1) = ""abaaac""
It can be shown that the minimum possible length of str2 is 6.
","class Solution:
    def minimizeConcatenatedLength(self, words: List[str]) -> int:
        N = len(words)
        C = 26
        cid = {chr(i + ord('a')) : i for i in range(C)}
        INF = float('-inf')
        
        # dp: max delete
        # assume dp[i][l][r]: step i, with (l, r) as left and right
        dp_l = [INF] * C   # [r]: dp[i][pl][r], pl ~ r
        dp_r = [INF] * C   # [l]: dp[i][l][pr], l ~ pr
        # Notice that for dp[i][l][r] to be valid, we need either l == pl or r == pr, so just using the two arrays above can save the info
        # We also derive update functions below to get rid of the [i] dimension
        
        # Previous l, r character
        pl = cid[words[0][0]]
        pr = cid[words[0][-1]]
        dp_l[pr] = dp_r[pl] = 0

        # max(dp_l), max(dp_r)
        lmax = rmax = 0

        # global add
        ladd = radd = 0
        
        for i in range(1, N):
            # Current l, r character
            cl = cid[words[i][0]]
            cr = cid[words[i][-1]]

            # To update dp_l:
            # dp_l[r] = dp[i][pl][r] = max(dp[i-1][_l][r] + (_l == cr))
            # (1) if r != pr, it's dp[i-1][pl][r] = dp_l[r] (no change); if pl == cr, should +1 (below)
            # (2) if r == pr, it's max(dp[i-1][_l][r] + (_l == cr)) = max(dp_r) and if best _l == cr, should +1 (here)
            # same for updating dp_r
            _lmax = lmax + (dp_l[cl] == lmax)   # the (2) case for updating dp_r
            _rmax = rmax + (dp_r[cr] == rmax)   # the (2) case for updating dp_l
            new_ladd = ladd + (pl == cr)        # the (1) case (add to this global variable instead of each element to improve complexity)
            new_radd = radd + (pr == cl)        # the (1) case
            dp_l[pr] = _rmax + radd - new_ladd  # the (1) case for dp_l, if ladd incremented, this essentially -1, cancelling out the +1 on dp_l[pr]
            dp_r[pl] = _lmax + ladd - new_radd  # the (1) case for dp_r
            ladd = new_ladd
            radd = new_radd

            # state (cl, cr) is maintained in both, should sync
            dp_l[cr] = max(dp_l[cr], dp_r[cl] + radd - ladd)
            dp_r[cl] = max(dp_r[cl], dp_l[cr] + ladd - radd)

            # only these entries are updated
            lmax = max([lmax, dp_l[pr], dp_l[cr]])
            rmax = max([rmax, dp_r[pl], dp_r[cl]])

            pl = cl
            pr = cr
        
        return sum([len(w) for w in words]) - max(lmax + ladd, rmax + radd)

",True
Maximum Number of Jumps to Reach the Last Index,"You are given a 0-indexed array nums of n integers and an integer target.
You are initially positioned at index 0. In one step, you can jump from index i to any index j such that:
0 <= i < j < n
-target <= nums[j] - nums[i] <= target
Return the maximum number of jumps you can make to reach index n - 1.
If there is no way to reach index n - 1, return -1.
","Example 1:
Input: nums = [1,3,6,4,1,2], target = 2
Output: 3
Explanation: To go from index 0 to index n - 1 with the maximum number of jumps, you can perform the following jumping sequence:
- Jump from index 0 to index 1. 
- Jump from index 1 to index 3.
- Jump from index 3 to index 5.
It can be proven that there is no other jumping sequence that goes from 0 to n - 1 with more than 3 jumps. Hence, the answer is 3. 
Example 2:
Input: nums = [1,3,6,4,1,2], target = 3
Output: 5
Explanation: To go from index 0 to index n - 1 with the maximum number of jumps, you can perform the following jumping sequence:
- Jump from index 0 to index 1.
- Jump from index 1 to index 2.
- Jump from index 2 to index 3.
- Jump from index 3 to index 4.
- Jump from index 4 to index 5.
It can be proven that there is no other jumping sequence that goes from 0 to n - 1 with more than 5 jumps. Hence, the answer is 5. 
Example 3:
Input: nums = [1,3,6,4,1,2], target = 0
Output: -1
Explanation: It can be proven that there is no jumping sequence that goes from 0 to n - 1. Hence, the answer is -1. 
","class Solution:
    def maximumJumps(self, nums: List[int], target: int) -> int:
        dp = [-1] * len(nums)
        dp[0] = 0
        for i in range(len(nums)):
            if dp[i] == -1: continue
            for j in range(i + 1, len(nums)):
                if abs(nums[j] - nums[i]) <= target:   
                    dp[j] = max(dp[i] + 1, dp[j])
        return dp[-1]",True
Count Complete Subarrays in an Array,"You are given an array nums consisting of positive integers.
We call a subarray of an array complete if the following condition is satisfied:
The number of distinct elements in the subarray is equal to the number of distinct elements in the whole array.
Return the number of complete subarrays.
A subarray is a contiguous non-empty part of an array.
","Example 1:
Input: nums = [1,3,1,2,2]
Output: 4
Explanation: The complete subarrays are the following: [1,3,1,2], [1,3,1,2,2], [3,1,2] and [3,1,2,2].
Example 2:
Input: nums = [5,5,5,5]
Output: 10
Explanation: The array consists only of the integer 5, so any subarray is complete. The number of subarrays that we can choose is 10.
","class Solution {
public:
    int countCompleteSubarrays(vector<int>& nums){
        unordered_set<int> freq(nums.begin(), nums.end());

        int count = 0;
        for (int i = 0; i < nums.size(); i++) {
            unordered_set<int> subFreq;
            for (int j = i; j < nums.size(); j++) {
                subFreq.insert(nums[j]);
                if (subFreq.size() == freq.size()) {
                    count++;
                }
            }
        }

        return count;
    }
};",False
Longest Even Odd Subarray With Threshold,"You are given a 0-indexed integer array nums and an integer threshold.
Find the length of the longest subarray of nums starting at index l and ending at index r (0 <= l <= r < nums.length) that satisfies the following conditions:
nums[l] % 2 == 0
For all indices i in the range [l, r - 1], nums[i] % 2 != nums[i + 1] % 2
For all indices i in the range [l, r], nums[i] <= threshold
Return an integer denoting the length of the longest such subarray.
Note: A subarray is a contiguous non-empty sequence of elements within an array.
","Example 1:
Input: nums = [3,2,5,4], threshold = 5
Output: 3
Explanation: In this example, we can select the subarray that starts at l = 1 and ends at r = 3 => [2,5,4]. This subarray satisfies the conditions.
Hence, the answer is the length of the subarray, 3. We can show that 3 is the maximum possible achievable length.
Example 2:
Input: nums = [1,2], threshold = 2
Output: 1
Explanation: In this example, we can select the subarray that starts at l = 1 and ends at r = 1 => [2]. 
It satisfies all the conditions and we can show that 1 is the maximum possible achievable length.
Example 3:
Input: nums = [2,3,4,5], threshold = 4
Output: 3
Explanation: In this example, we can select the subarray that starts at l = 0 and ends at r = 2 => [2,3,4]. 
It satisfies all the conditions.
Hence, the answer is the length of the subarray, 3. We can show that 3 is the maximum possible achievable length.
","class Solution:
    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:
        ans = 0
        for l in range(len(nums)):
            # check nums[l] is valid
            if nums[l] % 2 == 0 and nums[l] <= threshold:
                ans = max(ans, 1) # nums[l] is valid
                # check l+1 to the last element
                # break if any condition is not satisfied
                for r in range(l+1, len(nums)):
                    if nums[r] % 2 == nums[r-1] % 2:
                        break
                    if nums[r] > threshold:
                        break
                    # if ok, the length is r-l+1
                    ans = max(ans, r - l + 1)
        return ans
                
                ",True
Ways to Split Array Into Good Subarrays,"You are given a binary array nums.
A subarray of an array is good if it contains exactly one element with the value 1.
Return an integer denoting the number of ways to split the array nums into good subarrays. As the number may be too large, return it modulo 109 + 7.
A subarray is a contiguous non-empty sequence of elements within an array.
","Example 1:
Input: nums = [0,1,0,0,1]
Output: 3
Explanation: There are 3 ways to split nums into good subarrays:
- [0,1] [0,0,1]
- [0,1,0] [0,1]
- [0,1,0,0] [1]
Example 2:
Input: nums = [0,1,0]
Output: 1
Explanation: There is 1 way to split nums into good subarrays:
- [0,1,0]
",,False
Continuous Subarrays,"You are given a 0-indexed integer array nums. A subarray of nums is called continuous if:
Let i, i + 1, ..., j be the indices in the subarray. Then, for each pair of indices i <= i1, i2 <= j, 0 <= |nums[i1] - nums[i2]| <= 2.
Return the total number of continuous subarrays.
A subarray is a contiguous non-empty sequence of elements within an array.
","Example 1:
Input: nums = [5,4,2,4]
Output: 8
Explanation: 
Continuous subarray of size 1: [5], [4], [2], [4].
Continuous subarray of size 2: [5,4], [4,2], [2,4].
Continuous subarray of size 3: [4,2,4].
Thereare no subarrys of size 4.
Total continuous subarrays = 4 + 3 + 1 = 8.
It can be shown that there are no more continuous subarrays.
","class Solution:
    def continuousSubarrays(self, nums: List[int]) -> int:
        st = deque()
        st2 = deque()
        i = 0
        ans = 0
        j = 0
        while i < len(nums):
            if not st or st[-1] >= nums[i]:
                st.append(nums[i])
            else:
                while st and st[-1] < nums[i]:
                    st.pop()
                st.append(nums[i])
            while st and st[0] > nums[i] + 2:
                while nums[j] != st[0]:
                    j+=1
                st.popleft()
                j+=1
            
            if not st2 or st2[-1] <= nums[i]:
                st2.append(nums[i])
            else:
                while st2 and st2[-1] > nums[i]:
                    st2.pop()
                st2.append(nums[i])
            while st2 and st2[0] < nums[i] - 2:
                while nums[j] != st2[0]:
                    j+=1
                st2.popleft()
                j+=1
            ans += i-j+1
            i+=1
            # print(st,i,j)
        return ans
        
            
                
",True
Longest Non-decreasing Subarray From Two Arrays,"You are given two 0-indexed integer arrays nums1 and nums2 of length n.
Let's define another 0-indexed integer array, nums3, of length n. For each index i in the range [0, n - 1], you can assign either nums1[i] or nums2[i] to nums3[i].
Your task is to maximize the length of the longest non-decreasing subarray in nums3 by choosing its values optimally.
Return an integer representing the length of the longest non-decreasing subarray in nums3.
Note: A subarray is a contiguous non-empty sequence of elements within an array.
","Example 1:
Input: nums1 = [2,3,1], nums2 = [1,2,1]
Output: 2
Explanation: One way to construct nums3 is: 
nums3 = [nums1[0], nums2[1], nums2[2]] => [2,2,1]. 
The subarray starting from index 0 and ending at index 1, [2,2], forms a non-decreasing subarray of length 2. 
We can show that 2 is the maximum achievable length.
Example 2:
Input: nums1 = [1,3,2,1], nums2 = [2,2,3,4]
Output: 4
Explanation: One way to construct nums3 is: 
nums3 = [nums1[0], nums2[1], nums2[2], nums2[3]] => [1,2,3,4]. 
The entire array forms a non-decreasing subarray of length 4, making it the maximum achievable length.
Example 3:
Input: nums1 = [1,1], nums2 = [2,2]
Output: 2
Explanation: One way to construct nums3 is: 
nums3 = [nums1[0], nums1[1]] => [1,1]. 
The entire array forms a non-decreasing subarray of length 2, making it the maximum achievable length.
","class Solution:
    def maxNonDecreasingLength(self, nums1: List[int], nums2: List[int]) -> int:
        prev_elems = (0, 0)
        prev_lengths = [0, 0]
        
        result = 0

        for elems in zip(nums1, nums2):
            current_lengths = [1, 1]
            for i, elem in enumerate(elems):
                for j, prev_elem in enumerate(prev_elems):
                    if elem >= prev_elem:
                        current_lengths[i] = max(current_lengths[i], prev_lengths[j] + 1)
            
            result = max(result, max(current_lengths))

            prev_elems = elems
            prev_lengths = current_lengths
        
        return result",True
Longest Alternating Subarray,"You are given a 0-indexed integer array nums. A subarray s of length m is called alternating if:
m is greater than 1.
s1 = s0 + 1.
The 0-indexed subarray s looks like [s0, s1, s0, s1,...,s(m-1) % 2]. In other words, s1 - s0 = 1, s2 - s1 = -1, s3 - s2 = 1, s4 - s3 = -1, and so on up to s[m - 1] - s[m - 2] = (-1)m.
Return the maximum length of all alternating subarrays present in nums or -1 if no such subarray exists.
A subarray is a contiguous non-empty sequence of elements within an array.
","Example 1:
Input: nums = [2,3,4,3,4]
Output: 4
Explanation: The alternating subarrays are [3,4], [3,4,3], and [3,4,3,4]. The longest of these is [3,4,3,4], which is of length 4.
Example 2:
Input: nums = [4,5,6]
Output: 2
Explanation: [4,5] and [5,6] are the only two alternating subarrays. They are both of length 2.
","class Solution:
    def alternatingSubarray(self, nums: List[int]) -> int:
        n = len(nums) 
        res = dp = -1 
        for i in range(1, n): 
            if dp > 0 and nums[i] == nums[i - 2]: 
                dp += 1 
            else: 
                dp = 2 if nums[i] == nums[i - 1] + 1 else -1 
            res = max(res, dp) 
        return res ",True
Largest Element in an Array after Merge Operations,"You are given a 0-indexed array nums consisting of positive integers.
You can do the following operation on the array any number of times:
Choose an integer i such that 0 <= i < nums.length - 1 and nums[i] <= nums[i + 1]. Replace the element nums[i + 1] with nums[i] + nums[i + 1] and delete the element nums[i] from the array.
Return the value of the largest element that you can possibly obtain in the final array.
","Example 1:
Input: nums = [2,3,7,9,3]
Output: 21
Explanation: We can apply the following operations on the array:
- Choose i = 0. The resulting array will be nums = [5,7,9,3].
- Choose i = 1. The resulting array will be nums = [5,16,3].
- Choose i = 0. The resulting array will be nums = [21,3].
The largest element in the final array is 21. It can be shown that we cannot obtain a larger element.
Example 2:
Input: nums = [5,3,3]
Output: 11
Explanation: We can do the following operations on the array:
- Choose i = 1. The resulting array will be nums = [5,6].
- Choose i = 0. The resulting array will be nums = [11].
There is only one element in the final array, which is 11.
","class Solution:
    def maxArrayValue(self, nums: List[int]) -> int:
        n=len(nums)
        for i in range(n-1,0,-1):
            if nums[i-1]<=nums[i]:
                nums[i-1]=nums[i-1]+nums[i]

        return nums[0]        ",True
Prime Pairs With Target Sum,"You are given an integer n. We say that two integers x and y form a prime number pair if:
1 <= x <= y <= n
x + y == n
x and y are prime numbers
Return the 2D sorted list of prime number pairs [xi, yi]. The list should be sorted in increasing order of xi. If there are no prime number pairs at all, return an empty array.
Note: A prime number is a natural number greater than 1 with only two factors, itself and 1.
","Example 1:
Input: n = 10
Output: [[3,7],[5,5]]
Explanation: In this example, there are two prime pairs that satisfy the criteria. 
These pairs are [3,7] and [5,5], and we return them in the sorted order as described in the problem statement.
Example 2:
Input: n = 2
Output: []
Explanation: We can show that there is no prime number pair that gives a sum of 2, so we return an empty array. 
","class Solution:
    def findPrimePairs(self, n: int) -> List[List[int]]:
        def generate_primes(n):
            prime = [True]*(n+1)
            prime[0] = prime[1] = False
            p = 2
            while p*p<=n:
                if prime[p]:
                    for num in range(p*p,n+1,p):
                        prime[num] = False               
                p+=1
        
            ans = []
            for i in range(2,n+1):
                if prime[i]:
                    ans.append(i)
            return ans
        
        prime = generate_primes(n)
        l,r=0,len(prime)-1
        ans =[]
        while(l<=r):
            if prime[l]+ prime[r] == n:
                ans.append([prime[l],prime[r]])
                l+=1
                r-=1
            elif prime[l]+ prime[r] <n:
                l+=1
            else:
                r-=1
        return ans",True
Number of Employees Who Met the Target,"There are n employees in a company, numbered from 0 to n - 1. Each employee i has worked for hours[i] hours in the company.
The company requires each employee to work for at least target hours.
You are given a 0-indexed array of non-negative integers hours of length n and a non-negative integer target.
Return the integer denoting the number of employees who worked at least target hours.
","Example 1:
Input: hours = [0,1,2,3,4], target = 2
Output: 3
Explanation: The company wants each employee to work for at least 2 hours.
- Employee 0 worked for 0 hours and didn't meet the target.
- Employee 1 worked for 1 hours and didn't meet the target.
- Employee 2 worked for 2 hours and met the target.
- Employee 3 worked for 3 hours and met the target.
- Employee 4 worked for 4 hours and met the target.
There are 3 employees who met the target.
Example 2:
Input: hours = [5,1,4,2,2], target = 6
Output: 0
Explanation: The company wants each employee to work for at least 6 hours.
There are 0 employees who met the target.
","class Solution {
  int numberOfEmployeesWhoMetTarget(List<int> hours, int target) {
   int count=0;
   for(int i=0;i<hours.length;i++){
    if(hours[i]>=target){
        count+=1;
    }
   }
   return count;
  }
}",False
Minimum Index of a Valid Split,"An element x of an integer array arr of length m is dominant if freq(x) * 2 > m, where freq(x) is the number of occurrences of x in arr. Note that this definition implies that arr can have at most one dominant element.
You are given a 0-indexed integer array nums of length n with one dominant element.
You can split nums at an index i into two arrays nums[0, ..., i] and nums[i + 1, ..., n - 1], but the split is only valid if:
0 <= i < n - 1
nums[0, ..., i], and nums[i + 1, ..., n - 1] have the same dominant element.
Here, nums[i, ..., j] denotes the subarray of nums starting at index i and ending at index j, both ends being inclusive. Particularly, if j < i then nums[i, ..., j] denotes an empty subarray.
Return the minimum index of a valid split. If no valid split exists, return -1.
","Example 1:
Input: nums = [1,2,2,2]
Output: 2
Explanation: We can split the array at index 2 to obtain arrays [1,2,2] and [2]. 
In array [1,2,2], element 2 is dominant since it occurs twice in the array and 2 * 2 > 3. 
In array [2], element 2 is dominant since it occurs once in the array and 1 * 2 > 1.
Both [1,2,2] and [2] have the same dominant element as nums, so this is a valid split. 
It can be shown that index 2 is the minimum index of a valid split. 
Example 2:
Input: nums = [2,1,3,1,1,1,7,1,2,1]
Output: 4
Explanation: We can split the array at index 4 to obtain arrays [2,1,3,1,1] and [1,7,1,2,1].
In array [2,1,3,1,1], element 1 is dominant since it occurs thrice in the array and 3 * 2 > 5.
In array [1,7,1,2,1], element 1 is dominant since it occurs thrice in the array and 3 * 2 > 5.
Both [2,1,3,1,1] and [1,7,1,2,1] have the same dominant element as nums, so this is a valid split.
It can be shown that index 4 is the minimum index of a valid split.
Example 3:
Input: nums = [3,3,3,3,7,2,2]
Output: -1
Explanation: It can be shown that there is no valid split.
","class Solution:
    def minimumIndex(self, nums: List[int]) -> int:
        maxi=0

        freq=collections.defaultdict(int)
        for num in nums:
            freq[num]+=1
        maxi=0
        value=0
        n=len(nums)
        for num in freq:
            if freq[num]>maxi:
                maxi=freq[num]
                value=num
        cnt=0
        for i in range(n):
            if nums[i]==value:
                cnt+=1
                if cnt*2>(i+1):
                    break
        

        if (n-(i+1))>=(maxi-cnt)*2:
            return -1
        return i ",True
Maximum Beauty of an Array After Applying Operation,"You are given a 0-indexed array nums and a non-negative integer k.
In one operation, you can do the following:
Choose an index i that hasn't been chosen before from the range [0, nums.length - 1].
Replace nums[i] with any integer from the range [nums[i] - k, nums[i] + k].
The beauty of the array is the length of the longest subsequence consisting of equal elements.
Return the maximum possible beauty of the array nums after applying the operation any number of times.
Note that you can apply the operation to each index only once.
A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the order of the remaining elements.
","Example 1:
Input: nums = [4,6,1,2], k = 2
Output: 3
Explanation: In this example, we apply the following operations:
- Choose index 1, replace it with 4 (from range [4,8]), nums = [4,4,1,2].
- Choose index 3, replace it with 4 (from range [0,4]), nums = [4,4,1,4].
After the applied operations, the beauty of the array nums is 3 (subsequence consisting of indices 0, 1, and 3).
It can be proven that 3 is the maximum possible length we can achieve.
Example 2:
Input: nums = [1,1,1,1], k = 10
Output: 4
Explanation: In this example we don't have to apply any operations.
The beauty of the array nums is 4 (whole array).
","class Solution:
    def maximumBeauty(self, nums: List[int], k: int) -> int:
        max_a, max_b = -1, -1
        
        nums.sort(reverse=True)
        maxA = 0
        j = 0
        for i in range(len(nums)):
            max_a, max_b = nums[i] - k, nums[i] + k
            while (j < len(nums) and nums[j] + k >= max_a and nums[j] + k <= max_b):
                j += 1
                maxA = max(maxA, j - i)
        return maxA
            ",True
Check if Array is Good,"You are given an integer array nums. We consider an array good if it is a permutation of an array base[n].
base[n] = [1, 2, ..., n - 1, n, n] (in other words, it is an array of length n + 1 which contains 1 to n - 1 exactly once, plus two occurrences of n). For example, base[1] = [1, 1] and base[3] = [1, 2, 3, 3].
Return true if the given array is good, otherwise return false.
Note: A permutation of integers represents an arrangement of these numbers.
","Example 1:
Input: nums = [2, 1, 3]
Output: false
Explanation: Since the maximum element of the array is 3, the only candidate n for which this array could be a permutation of base[n], is n = 3. However, base[3] has four elements but array nums has three. Therefore, it can not be a permutation of base[3] = [1, 2, 3, 3]. So the answer is false.
Example 2:
Input: nums = [1, 3, 3, 2]
Output: true
Explanation: Since the maximum element of the array is 3, the only candidate n for which this array could be a permutation of base[n], is n = 3. It can be seen that nums is a permutation of base[3] = [1, 2, 3, 3] (by swapping the second and fourth elements in nums, we reach base[3]). Therefore, the answer is true.
Example 3:
Input: nums = [1, 1]
Output: true
Explanation: Since the maximum element of the array is 1, the only candidate n for which this array could be a permutation of base[n], is n = 1. It can be seen that nums is a permutation of base[1] = [1, 1]. Therefore, the answer is true.
Example 4:
Input: nums = [3, 4, 4, 1, 2, 1]
Output: false
Explanation: Since the maximum element of the array is 4, the only candidate n for which this array could be a permutation of base[n], is n = 4. However, base[4] has five elements but array nums has six. Therefore, it can not be a permutation of base[4] = [1, 2, 3, 4, 4]. So the answer is false.
","class Solution:
    def isGood(self, nums: List[int]) -> bool:
        return min(nums)==1 and max(nums)==len(nums)-1 and nums.count(len(nums)-1)==2 and len(set(nums))==len(nums)-1",True
Visit Array Positions to Maximize Score,"You are given a 0-indexed integer array nums and a positive integer x.
You are initially at position 0 in the array and you can visit other positions according to the following rules:
If you are currently in position i, then you can move to any position j such that i < j.
For each position i that you visit, you get a score of nums[i].
If you move from a position i to a position j and the parities of nums[i] and nums[j] differ, then you lose a score of x.
Return the maximum total score you can get.
Note that initially you have nums[0] points.
","Example 1:
Input: nums = [2,3,6,1,9,2], x = 5
Output: 13
Explanation: We can visit the following positions in the array: 0 -> 2 -> 3 -> 4.
The corresponding values are 2, 6, 1 and 9. Since the integers 6 and 1 have different parities, the move 2 -> 3 will make you lose a score of x = 5.
The total score will be: 2 + 6 + 1 + 9 - 5 = 13.
Example 2:
Input: nums = [2,4,6,8], x = 3
Output: 20
Explanation: All the integers in the array have the same parities, so we can visit all of them without losing any score.
The total score is: 2 + 4 + 6 + 8 = 20.
","class Solution:
    def maxScore(self, nums: List[int], x: int) -> int:
        
        #defining memorization
        memo = {}
        def dp(i,prev):
            #if the curr index is greater then or equal to the length of the array return 0
            if i >= len(nums):
                return 0

            #if previously computed then return the precomputed result
            elif (i,prev) in memo:
                return memo[(i,prev)]
            else:
                #if parities is equal
                if prev==nums[i]%2:
                    left = dp(i+1,nums[i]%2)+nums[i]
                #if parities is not equal
                else:
                    left = dp(i+1,nums[i]%2)+nums[i]-x

                #if not consider the current index
                memo[(i,prev)] = max(left,dp(i+1,prev))
                return memo[(i,prev)]

        return dp(1,nums[0]%2) +nums[0]",True
Max Pair Sum in an Array,"You are given an integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the largest digit in both numbers is equal.
For example, 2373 is made up of three distinct digits: 2, 3, and 7, where 7 is the largest among them.
Return the maximum sum or -1 if no such pair exists.
","Example 1:
Input: nums = [112,131,411]
Output: -1
Explanation:
Each numbers largest digit in order is [2,3,4].
Example 2:
Input: nums = [2536,1613,3366,162]
Output: 5902
Explanation:
All the numbers have 6 as their largest digit, so the answer is 2536 + 3366 = 5902.
Example 3:
Input: nums = [51,71,17,24,42]
Output: 88
Explanation:
Each number's largest digit in order is [5,7,7,4,4].
So we have only two possible pairs, 71 + 17 = 88 and 24 + 42 = 66.
","class Solution {
 int
   maxSum(List<int> nums) {

int temp=0;

for(int i=0;i<nums.length-1;i++){
int max1 =maxDigit(nums[i]);
  for(int j=i+1;j<nums.length;j++){
      int max2 =maxDigit(nums[j]);
    if(max1==max2){
      int sum = nums[i]+nums[j];

      if(sum> temp){
          temp=sum;
      }
    }
  }

}
return temp==0? -1:temp;

  }


int maxDigit(int x){
 List<int> val = x.toString().split('').map((e)=>int.parse(e)).toList();
 int value = val.reduce(max);
return value;
}


}",False
Find the Safest Path in a Grid,"You are given a 0-indexed 2D matrix grid of size n x n, where (r, c) represents:
A cell containing a thief if grid[r][c] = 1
An empty cell if grid[r][c] = 0
You are initially positioned at cell (0, 0). In one move, you can move to any adjacent cell in the grid, including cells containing thieves.
The safeness factor of a path on the grid is defined as the minimum manhattan distance from any cell in the path to any thief in the grid.
Return the maximum safeness factor of all paths leading to cell (n - 1, n - 1).
An adjacent cell of cell (r, c), is one of the cells (r, c + 1), (r, c - 1), (r + 1, c) and (r - 1, c) if it exists.
The Manhattan distance between two cells (a, b) and (x, y) is equal to |a - x| + |b - y|, where |val| denotes the absolute value of val.
","Example 1:

Input: grid = [[1,0,0],[0,0,0],[0,0,1]]
Output: 0
Explanation: All paths from (0, 0) to (n - 1, n - 1) go through the thieves in cells (0, 0) and (n - 1, n - 1).
Example 2:

Input: grid = [[0,0,1],[0,0,0],[0,0,0]]
Output: 2
Explanation: The path depicted in the picture above has a safeness factor of 2 since:
- The closest cell of the path to the thief at cell (0, 2) is cell (0, 0). The distance between them is | 0 - 0 | + | 0 - 2 | = 2.
It can be shown that there are no other paths with a higher safeness factor.
Example 3:

Input: grid = [[0,0,0,1],[0,0,0,0],[0,0,0,0],[1,0,0,0]]
Output: 2
Explanation: The path depicted in the picture above has a safeness factor of 2 since:
- The closest cell of the path to the thief at cell (0, 3) is cell (1, 2). The distance between them is | 0 - 1 | + | 3 - 2 | = 2.
- The closest cell of the path to the thief at cell (3, 0) is cell (3, 2). The distance between them is | 3 - 3 | + | 0 - 2 | = 2.
It can be shown that there are no other paths with a higher safeness factor.
","class Solution:
    def __init__(self):
        self.roww = [0, 0, -1, 1]
        self.coll = [-1, 1, 0, 0]

    def bfs(self, grid, score, n):
        q = deque()

        for i in range(n):
            for j in range(n):
                if grid[i][j]:
                    score[i][j] = 0
                    q.append((i, j))

        while q:
            x, y = q.popleft()
            s = score[x][y]

            for i in range(4):
                new_x = x + self.roww[i]
                new_y = y + self.coll[i]

                if 0 <= new_x < n and 0 <= new_y < n and score[new_x][new_y] > s + 1:
                    score[new_x][new_y] = s + 1
                    q.append((new_x, new_y))

    def maximumSafenessFactor(self, grid):
        n = len(grid)
        if grid[0][0] or grid[n - 1][n - 1]:
            return 0

        score = [[float('inf')] * n for _ in range(n)]
        self.bfs(grid, score, n)

        vis = [[False] * n for _ in range(n)]
        pq = [(-score[0][0], 0, 0)]
        heapq.heapify(pq)

        while pq:
            safe, x, y = heapq.heappop(pq)
            safe = -safe

            if x == n - 1 and y == n - 1:
                return safe

            vis[x][y] = True

            for i in range(4):
                new_x = x + self.roww[i]
                new_y = y + self.coll[i]

                if 0 <= new_x < n and 0 <= new_y < n and not vis[new_x][new_y]:
                    s = min(safe, score[new_x][new_y])
                    heapq.heappush(pq, (-s, new_x, new_y))
                    vis[new_x][new_y] = True

        return -1
",True
Check if it is Possible to Split Array,"You are given an array nums of length n and an integer m. You need to determine if it is possible to split the array into n non-empty arrays by performing a series of steps.
In each step, you can select an existing array (which may be the result of previous steps) with a length of at least two and split it into two subarrays, if, for each resulting subarray, at least one of the following holds:
The length of the subarray is one, or
The sum of elements of the subarray is greater than or equal to m.
Return true if you can split the given array into n arrays, otherwise return false.
Note: A subarray is a contiguous non-empty sequence of elements within an array.
","Example 1:
Input: nums = [2, 2, 1], m = 4
Output: true
Explanation: We can split the array into [2, 2] and [1] in the first step. Then, in the second step, we can split [2, 2] into [2] and [2]. As a result, the answer is true.
Example 2:
Input: nums = [2, 1, 3], m = 5 
Output: false
Explanation: We can try splitting the array in two different ways: the first way is to have [2, 1] and [3], and the second way is to have [2] and [1, 3]. However, both of these ways are not valid. So, the answer is false.
Example 3:
Input: nums = [2, 3, 3, 2, 3], m = 6
Output: true
Explanation: We can split the array into [2, 3, 3, 2] and [3] in the first step. Then, in the second step, we can split [2, 3, 3, 2] into [2, 3, 3] and [2]. Then, in the third step, we can split [2, 3, 3] into [2] and [3, 3]. And in the last step we can split [3, 3] into [3] and [3]. As a result, the answer is true.
","class Solution:
    def canSplitArray(self, nums: List[int], m: int) -> bool:
        n = len(nums)
        if n<=2: #can split into two length==1's lists
            return True

        for i in range(1, n): # if there no (nums[i-1]+nums[i]) >= m will be false  
            if nums[i-1]+nums[i] >= m:
                return True

        return False
    ",True
Count Pairs Whose Sum is Less than Target,"0-indexed
nums
n
target
the number of pairs
(i, j)
where
0 <= i < j < n
and
nums[i] + nums[j] < target
","Example 1:
Input: nums = [-1,1,2,3,1], target = 2
Output: 3
Explanation: There are 3 pairs of indices that satisfy the conditions in the statement:
- (0, 1) since 0 < 1 and nums[0] + nums[1] = 0 < target
- (0, 2) since 0 < 2 and nums[0] + nums[2] = 1 < target 
- (0, 4) since 0 < 4 and nums[0] + nums[4] = 0 < target
Note that (0, 3) is not counted since nums[0] + nums[3] is not strictly less than the target.
Example 2:
Input: nums = [-6,2,5,-2,-7,-1,3], target = -2
Output: 10
Explanation: There are 10 pairs of indices that satisfy the conditions in the statement:
- (0, 1) since 0 < 1 and nums[0] + nums[1] = -4 < target
- (0, 3) since 0 < 3 and nums[0] + nums[3] = -8 < target
- (0, 4) since 0 < 4 and nums[0] + nums[4] = -13 < target
- (0, 5) since 0 < 5 and nums[0] + nums[5] = -7 < target
- (0, 6) since 0 < 6 and nums[0] + nums[6] = -3 < target
- (1, 4) since 1 < 4 and nums[1] + nums[4] = -5 < target
- (3, 4) since 3 < 4 and nums[3] + nums[4] = -9 < target
- (3, 5) since 3 < 5 and nums[3] + nums[5] = -3 < target
- (4, 5) since 4 < 5 and nums[4] + nums[5] = -8 < target
- (4, 6) since 4 < 6 and nums[4] + nums[6] = -4 < target
","class Solution(object):
    def countPairs(self, nums, target):
        n = len(nums)

        nums.sort()

        c = 0
        l = 0
        r = n-1

        while l < r:
            if nums[l] + nums[r] < target:
                c += r - l
                l += 1
            else:
                r -= 1

        return c",True
Minimum Seconds to Equalize a Circular Array,"You are given a 0-indexed array nums containing n integers.
At each second, you perform the following operation on the array:
For every index i in the range [0, n - 1], replace nums[i] with either nums[i], nums[(i - 1 + n) % n], or nums[(i + 1) % n].
Note that all the elements get replaced simultaneously.
Return the minimum number of seconds needed to make all elements in the array nums equal.
","Example 1:
Input: nums = [1,2,1,2]
Output: 1
Explanation: We can equalize the array in 1 second in the following way:
- At 1st second, replace values at each index with [nums[3],nums[1],nums[3],nums[3]]. After replacement, nums = [2,2,2,2].
It can be proven that 1 second is the minimum amount of seconds needed for equalizing the array.
Example 2:
Input: nums = [2,1,3,3,2]
Output: 2
Explanation: We can equalize the array in 2 seconds in the following way:
- At 1st second, replace values at each index with [nums[0],nums[2],nums[2],nums[2],nums[3]]. After replacement, nums = [2,3,3,3,3].
- At 2nd second, replace values at each index with [nums[1],nums[1],nums[2],nums[3],nums[4]]. After replacement, nums = [3,3,3,3,3].
It can be proven that 2 seconds is the minimum amount of seconds needed for equalizing the array.
Example 3:
Input: nums = [5,5,5,5]
Output: 0
Explanation: We don't need to perform any operations as all elements in the initial array are the same.
","class Solution:
    def minimumSeconds(self, nums: List[int]) -> int:
        n=len(nums)
        d={}
# Calculate gaps between same elements of the array
# in map we store for each unique element (maxgap , first_index , prev_index)
        for i in range(n):
            if(nums[i] not in d):
                d[nums[i]]=[0,i,i]
            else:
# maximum between present gap and (prev index - current index) 
                d[nums[i]][0]=max(d[nums[i]][0],i-d[nums[i]][2]-1)
                d[nums[i]][2]=i

# for difference of first and last similar element of array (CIRCULAR ARRAY)
        for i in d:
            d[i][0]=max(n-(d[i][2]-d[i][1])-1,d[i][0])

# for minimum between maximum gaps of all elements
        ans=10**9
        for i in d:
                ans=min(ans,d[i][0])

# every second gap decrease by 2 (element-->   <--element)
        ans=math.ceil(ans/2)
        return ans
        


                
            
            
        ",True
Maximum Sum of Almost Unique Subarray,"You are given an integer array nums and two positive integers m and k.
Return the maximum sum out of all almost unique subarrays of length k of nums. If no such subarray exists, return 0.
A subarray of nums is almost unique if it contains at least m distinct elements.
A subarray is a contiguous non-empty sequence of elements within an array.
","Example 1:
Input: nums = [2,6,7,3,1,7], m = 3, k = 4
Output: 18
Explanation: There are 3 almost unique subarrays of size k = 4. These subarrays are [2, 6, 7, 3], [6, 7, 3, 1], and [7, 3, 1, 7]. Among these subarrays, the one with the maximum sum is [2, 6, 7, 3] which has a sum of 18.
Example 2:
Input: nums = [5,9,9,2,4,5,4], m = 1, k = 3
Output: 23
Explanation: There are 5 almost unique subarrays of size k. These subarrays are [5, 9, 9], [9, 9, 2], [9, 2, 4], [2, 4, 5], and [4, 5, 4]. Among these subarrays, the one with the maximum sum is [5, 9, 9] which has a sum of 23.
Example 3:
Input: nums = [1,2,1,2,1,2,1], m = 3, k = 3
Output: 0
Explanation: There are no subarrays of size k = 3 that contain at least m = 3 distinct elements in the given array [1,2,1,2,1,2,1]. Therefore, no almost unique subarrays exist, and the maximum sum is 0.
","class Solution:
    def maxSum(self, nums: List[int], m: int, k: int) -> int:
        result = 0
        window = Counter()
        left = 0
        total = 0

        for right in range(len(nums)):
            window[nums[right]] += 1
            total += nums[right]

            if right - left + 1 < k:
                continue

            if len(window) >= m:
                result = max(result, total)

            window[nums[left]] -= 1
            total -= nums[left]
            left += 1

            if window[nums[left - 1]] == 0:
                del window[nums[left - 1]]

        return result",True
Check if a String Is an Acronym of Words,"Given an array of strings words and a string s, determine if s is an acronym of words.
The string s is considered an acronym of words if it can be formed by concatenating the first character of each string in words in order. For example, ""ab"" can be formed from [""apple"", ""banana""], but it can't be formed from [""bear"", ""aardvark""].
Return true if s is an acronym of words, and false otherwise.
","Example 1:
Input: words = [""alice"",""bob"",""charlie""], s = ""abc""
Output: true
Explanation: The first character in the words ""alice"", ""bob"", and ""charlie"" are 'a', 'b', and 'c', respectively. Hence, s = ""abc"" is the acronym. 
Example 2:
Input: words = [""an"",""apple""], s = ""a""
Output: false
Explanation: The first character in the words ""an"" and ""apple"" are 'a' and 'a', respectively. 
The acronym formed by concatenating these characters is ""aa"". 
Hence, s = ""a"" is not the acronym.
Example 3:
Input: words = [""never"",""gonna"",""give"",""up"",""on"",""you""], s = ""ngguoy""
Output: true
Explanation: By concatenating the first character of the words in the array, we get the string ""ngguoy"". 
Hence, s = ""ngguoy"" is the acronym.
","class Solution:
    def isAcronym(self, words: List[str], s: str) -> bool:

        return ''.join(word[0] for word in words) == s",True
Maximize the Profit as the Salesman,"You are given an integer n representing the number of houses on a number line, numbered from 0 to n - 1.
Additionally, you are given a 2D integer array offers where offers[i] = [starti, endi, goldi], indicating that ith buyer wants to buy all the houses from starti to endi for goldi amount of gold.
As a salesman, your goal is to maximize your earnings by strategically selecting and selling houses to buyers.
Return the maximum amount of gold you can earn.
Note that different buyers can't buy the same house, and some houses may remain unsold.
","Example 1:
Input: n = 5, offers = [[0,0,1],[0,2,2],[1,3,2]]
Output: 3
Explanation: There are 5 houses numbered from 0 to 4 and there are 3 purchase offers.
We sell houses in the range [0,0] to 1st buyer for 1 gold and houses in the range [1,3] to 3rd buyer for 2 golds.
It can be proven that 3 is the maximum amount of gold we can achieve.
Example 2:
Input: n = 5, offers = [[0,0,1],[0,2,10],[1,3,2]]
Output: 10
Explanation: There are 5 houses numbered from 0 to 4 and there are 3 purchase offers.
We sell houses in the range [0,2] to 2nd buyer for 10 golds.
It can be proven that 10 is the maximum amount of gold we can achieve.
","class Solution:
    def maximizeTheProfit(self, n: int, offers: List[List[int]]) -> int:
        offers.sort(key=lambda a: a[1])
        ends = [o[1] for o in offers]
        m = len(offers)
        dp = [0]*m
        for i in range(m):
            s, e, g = offers[i]
            j = bisect_right(ends, s-1)
            bestPrevDp = dp[j-1] if i > 0 else 0
            dp[i] = max(dp[i-1] if i > 0 else 0, bestPrevDp + g)
        return dp[-1]",True
Minimum Absolute Difference Between Elements With Constraint,"You are given a 0-indexed integer array nums and an integer x.
Find the minimum absolute difference between two elements in the array that are at least x indices apart.
In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.
Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.
","Example 1:
Input: nums = [4,3,2,4], x = 2
Output: 0
Explanation: We can select nums[0] = 4 and nums[3] = 4. 
They are at least 2 indices apart, and their absolute difference is the minimum, 0. 
It can be shown that 0 is the optimal answer.
Example 2:
Input: nums = [5,3,2,10,15], x = 1
Output: 1
Explanation: We can select nums[1] = 3 and nums[2] = 2.
They are at least 1 index apart, and their absolute difference is the minimum, 1.
It can be shown that 1 is the optimal answer.
Example 3:
Input: nums = [1,2,3,4], x = 3
Output: 3
Explanation: We can select nums[0] = 1 and nums[3] = 4.
They are at least 3 indices apart, and their absolute difference is the minimum, 3.
It can be shown that 3 is the optimal answer.
","class Solution:
    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:
        minimum = inf
        allowed = []
        for i in range(x, len(nums)):
            insort(allowed, nums[i-x])
            at = bisect_left(allowed, nums[i])
            if at > 0:
                minimum = min(minimum, nums[i] - allowed[at-1])
            if at < len(allowed):
                minimum = min(minimum, allowed[at] - nums[i])
        return minimum",True
Construct Product Matrix,"Given a 0-indexed 2D integer matrix grid of size n * m, we define a 0-indexed 2D matrix p of size n * m as the product matrix of grid if the following condition is met:
Each element p[i][j] is calculated as the product of all elements in grid except for the element grid[i][j]. This product is then taken modulo 12345.
Return the product matrix of grid.
","Example 1:
Input: grid = [[1,2],[3,4]]
Output: [[24,12],[8,6]]
Explanation: p[0][0] = grid[0][1] * grid[1][0] * grid[1][1] = 2 * 3 * 4 = 24
p[0][1] = grid[0][0] * grid[1][0] * grid[1][1] = 1 * 3 * 4 = 12
p[1][0] = grid[0][0] * grid[0][1] * grid[1][1] = 1 * 2 * 4 = 8
p[1][1] = grid[0][0] * grid[0][1] * grid[1][0] = 1 * 2 * 3 = 6
So the answer is [[24,12],[8,6]].
Example 2:
Input: grid = [[12345],[2],[1]]
Output: [[2],[0],[0]]
Explanation: p[0][0] = grid[0][1] * grid[0][2] = 2 * 1 = 2.
p[0][1] = grid[0][0] * grid[0][2] = 12345 * 1 = 12345. 12345 % 12345 = 0. So p[0][1] = 0.
p[0][2] = grid[0][0] * grid[0][1] = 12345 * 2 = 24690. 24690 % 12345 = 0. So p[0][2] = 0.
So the answer is [[2],[0],[0]].
","class Solution {
public:
    vector<vector<int>> constructProductMatrix(vector<vector<int>>& grid) {
        //2 option h
        //yaa to division operator lgake inverse modulo khel lo
        //yaa fir pre suf pro se pro nikaalo
        int mod=12345;
        int n=grid.size();
        int m=grid[0].size();
        vector<vector<int>>t(n,vector<int>(m));
        t[0][0]=1;
        vector<long long >ans(n*m);
        vector<long long int>nums(n*m);
        long long  k=0;
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<m;j++)
            {
                nums[k++]=grid[i][j];
            }
        }
        ans[0]=1;
        long long pro=1;
        for(int i=1;i<n*m;i++)
        {
            pro=pro%12345*nums[i-1]%12345;
            ans[i]=pro%mod;
        }
        pro=1;
        for(int i=n*m-2;i>=0;i--)
        {
            pro=(pro%mod*nums[i+1]%mod)%mod;
            ans[i]=(ans[i]%mod*pro%mod)%mod;
        }
        k=0;
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<m;j++)
            {
                t[i][j]=ans[k++];
            }
        }
        return t;
    }
};",False
Minimum Operations to Collect Elements,"You are given an array nums of positive integers and an integer k.
In one operation, you can remove the last element of the array and add it to your collection.
Return the minimum number of operations needed to collect elements 1, 2, ..., k.
","Example 1:
Input: nums = [3,1,5,4,2], k = 2
Output: 4
Explanation: After 4 operations, we collect elements 2, 4, 5, and 1, in this order. Our collection contains elements 1 and 2. Hence, the answer is 4.
Example 2:
Input: nums = [3,1,5,4,2], k = 5
Output: 5
Explanation: After 5 operations, we collect elements 2, 4, 5, 1, and 3, in this order. Our collection contains elements 1 through 5. Hence, the answer is 5.
Example 3:
Input: nums = [3,2,5,3,1], k = 3
Output: 4
Explanation: After 4 operations, we collect elements 1, 3, 5, and 2, in this order. Our collection contains elements 1 through 3. Hence, the answer is 4.
","class Solution:
    def minOperations(self, nums: List[int], k: int) -> int:
        
                                                #  Example: nums = [3,1,5,4,2]   k=2
        s = cnt = 0                             #           goal = (1<<3)-2 = 6 = '110'
        goal = (1<<(k+1)) - 2

        while nums:                             #   num    s    cnt
                                                #   –––   –––   ––– 
            cnt+= 1                             #    2    100    1
            if (num:=nums.pop()) <= k:          #    4    100    2
                s|= (1<<num)                    #    5    100    3
                                                #    1    110    4 <--return 4
            if  s == goal: return cnt",True
Split Array Into Maximum Number of Subarrays,"You are given an array nums consisting of non-negative integers.
We define the score of subarray nums[l..r] such that l <= r as nums[l] AND nums[l + 1] AND ... AND nums[r] where AND is the bitwise AND operation.
Consider splitting the array into one or more subarrays such that the following conditions are satisfied:
Each element of the array belongs to exactly one subarray.
The sum of scores of the subarrays is the minimum possible.
Return the maximum number of subarrays in a split that satisfies the conditions above.
A subarray is a contiguous part of an array.
","Example 1:
Input: nums = [1,0,2,0,1,2]
Output: 3
Explanation: We can split the array into the following subarrays:
- [1,0]. The score of this subarray is 1 AND 0 = 0.
- [2,0]. The score of this subarray is 2 AND 0 = 0.
- [1,2]. The score of this subarray is 1 AND 2 = 0.
The sum of scores is 0 + 0 + 0 = 0, which is the minimum possible score that we can obtain.
It can be shown that we cannot split the array into more than 3 subarrays with a total score of 0. So we return 3.
Example 2:
Input: nums = [5,7,1,3]
Output: 1
Explanation: We can split the array into one subarray: [5,7,1,3] with a score of 1, which is the minimum possible score that we can obtain.
It can be shown that we cannot split the array into more than 1 subarray with a total score of 1. So we return 1.
","class Solution {
    public int maxSubarrays(int[] nums) {
        
        int min=nums[0];
        for(int i=1;i<nums.length;++i){
            min&=nums[i];
        }

        if(min>0) return 1;

        int ans=1;
        int temp=nums[0];
        for(int i=1;i<nums.length;++i){
            if(temp==0){
                ans++;
                temp=nums[i];
            }
            else
                temp&=nums[i];
            if(i==nums.length-1 && temp>0)
                ans--;
        }
        return ans;
    }
}",False
Sum of Values at Indices With K Set Bits,"You are given a 0-indexed integer array nums and an integer k.
Return an integer that denotes the sum of elements in nums whose corresponding indices have exactly k set bits in their binary representation.
The set bits in an integer are the 1's present when it is written in binary.
For example, the binary representation of 21 is 10101, which has 3 set bits.
","Example 1:
Input: nums = [5,10,1,5,2], k = 1
Output: 13
Explanation: The binary representation of the indices are: 
0 = 0002
1 = 0012
2 = 0102
3 = 0112
4 = 1002 
Indices 1, 2, and 4 have k = 1 set bits in their binary representation.
Hence, the answer is nums[1] + nums[2] + nums[4] = 13.
Example 2:
Input: nums = [4,3,2,1], k = 2
Output: 1
Explanation: The binary representation of the indices are:
0 = 002
1 = 012
2 = 102
3 = 112
Only index 3 has k = 2 set bits in its binary representation.
Hence, the answer is nums[3] = 1.
","class Solution:
    def sumIndicesWithKSetBits(self, nums: List[int], k: int) -> int:
        return sum(x for i, x in enumerate(nums) if bin(i).count('1') == k)",True
Minimum Number of Operations to Make Array Empty,"You are given a 0-indexed array nums consisting of positive integers.
There are two types of operations that you can apply on the array any number of times:
Choose two elements with equal values and delete them from the array.
Choose three elements with equal values and delete them from the array.
Return the minimum number of operations required to make the array empty, or -1 if it is not possible.
","Example 1:
Input: nums = [2,3,3,2,2,4,2,3,4]
Output: 4
Explanation: We can apply the following operations to make the array empty:
- Apply the first operation on the elements at indices 0 and 3. The resulting array is nums = [3,3,2,4,2,3,4].
- Apply the first operation on the elements at indices 2 and 4. The resulting array is nums = [3,3,4,3,4].
- Apply the second operation on the elements at indices 0, 1, and 3. The resulting array is nums = [4,4].
- Apply the first operation on the elements at indices 0 and 1. The resulting array is nums = [].
It can be shown that we cannot make the array empty in less than 4 operations.
Example 2:
Input: nums = [2,1,2,2,3,3]
Output: -1
Explanation: It is impossible to empty the array.
","class Solution:
    def minOperations(self, nums: List[int]) -> int:
        count=Counter(nums).values()
        ans=0
        for i in count:
            if i==1:
                return -1
            else:
                ans+=i//3 + (i%3!=0)
        return ans            ",True
Maximum Number of Alloys,"You are the owner of a company that creates alloys using various types of metals. There are n different types of metals available, and you have access to k machines that can be used to create alloys. Each machine requires a specific amount of each metal type to create an alloy.
For the ith machine to create an alloy, it needs composition[i][j] units of metal of type j. Initially, you have stock[i] units of metal type i, and purchasing one unit of metal type i costs cost[i] coins.
Given integers n, k, budget, a 1-indexed 2D array composition, and 1-indexed arrays stock and cost, your goal is to maximize the number of alloys the company can create while staying within the budget of budget coins.
All alloys must be created with the same machine.
Return the maximum number of alloys that the company can create.
","Example 1:
Input: n = 3, k = 2, budget = 15, composition = [[1,1,1],[1,1,10]], stock = [0,0,0], cost = [1,2,3]
Output: 2
Explanation: It is optimal to use the 1st machine to create alloys.
To create 2 alloys we need to buy the:
- 2 units of metal of the 1st type.
- 2 units of metal of the 2nd type.
- 2 units of metal of the 3rd type.
In total, we need 2 * 1 + 2 * 2 + 2 * 3 = 12 coins, which is smaller than or equal to budget = 15.
Notice that we have 0 units of metal of each type and we have to buy all the required units of metal.
It can be proven that we can create at most 2 alloys.
Example 2:
Input: n = 3, k = 2, budget = 15, composition = [[1,1,1],[1,1,10]], stock = [0,0,100], cost = [1,2,3]
Output: 5
Explanation: It is optimal to use the 2nd machine to create alloys.
To create 5 alloys we need to buy:
- 5 units of metal of the 1st type.
- 5 units of metal of the 2nd type.
- 0 units of metal of the 3rd type.
In total, we need 5 * 1 + 5 * 2 + 0 * 3 = 15 coins, which is smaller than or equal to budget = 15.
It can be proven that we can create at most 5 alloys.
Example 3:
Input: n = 2, k = 3, budget = 10, composition = [[2,1],[1,2],[1,1]], stock = [1,1], cost = [5,5]
Output: 2
Explanation: It is optimal to use the 3rd machine to create alloys.
To create 2 alloys we need to buy the:
- 1 unit of metal of the 1st type.
- 1 unit of metal of the 2nd type.
In total, we need 1 * 5 + 1 * 5 = 10 coins, which is smaller than or equal to budget = 10.
It can be proven that we can create at most 2 alloys.
","class Solution {
public:
    bool solve(int mid,int i,int n, int k, int budget, vector<vector<int>>& composition, vector<int>& stock, vector<int>& cost)
    {   
        long long c=0;
        vector<long long>v;
        for(int x=0;x<n;x++)
        {
            long long y=mid*(long long)composition[i][x];
            v.push_back(y);
        }
        for(int x=0;x<n;x++)
        {   
            if(v[x]-stock[x]>0)
                v[x]=v[x]-stock[x];
            else
                v[x]=0;
            c=c+v[x]*cost[x];
            if(c>budget)
                break;
        }
        return c<=budget;
    }
    int maxNumberOfAlloys(int n, int k, int budget, vector<vector<int>>& composition, vector<int>& stock, vector<int>& cost) {
        int l=0,h=1e9;
        int ans=0;
        for(int i=0;i<composition.size();i++)
        {   
            int l=0,h=1e9;
            int s=0;
            while(l<=h)
            {
                int mid=l+(h-l)/2;
                if(solve(mid,i,n,k,budget,composition,stock,cost))
                {
                    s=mid;
                    l=mid+1;
                }
                else
                    h=mid-1;
            }
            ans=max(ans,s);
        }
        return ans;
    }
};",False
Length of the Longest Subsequence That Sums to Target,"You are given a 0-indexed array of integers nums, and an integer target.
Return the length of the longest subsequence of nums that sums up to target. If no such subsequence exists, return -1.
A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.
","Example 1:
Input: nums = [1,2,3,4,5], target = 9
Output: 3
Explanation: There are 3 subsequences with a sum equal to 9: [4,5], [1,3,5], and [2,3,4]. The longest subsequences are [1,3,5], and [2,3,4]. Hence, the answer is 3.
Example 2:
Input: nums = [4,1,3,2,1,5], target = 7
Output: 4
Explanation: There are 5 subsequences with a sum equal to 7: [4,3], [4,1,2], [4,2,1], [1,1,5], and [1,3,2,1]. The longest subsequence is [1,3,2,1]. Hence, the answer is 4.
Example 3:
Input: nums = [1,1,5,4,5], target = 3
Output: -1
Explanation: It can be shown that nums has no subsequence that sums up to 3.
","class Solution {
public:
int dp[1001][1001];
int solve(int ind,int target,vector<int>&nums,int n){
    if(target<0)
    return -1e5;
    if(target==0){
        return 0;
    }
    if(ind==n)
    return -1e5;
    if(dp[ind][target]!=-1)
    return dp[ind][target];
    int nontake=solve(ind+1,target,nums,n);
    int take=1+solve(ind+1,target-nums[ind],nums,n);
    return dp[ind][target]=max(take,nontake);
}
    int lengthOfLongestSubsequence(vector<int>& nums, int target) {
        int n=nums.size();
        memset(dp,-1,sizeof(dp));
        int ans=solve(0,target,nums,n);
        if(ans>=-1e5 && ans<=-1e4)
        return -1;
        return ans;
    }
};",False
Beautiful Towers I,"You are given an array heights of n integers representing the number of bricks in n consecutive towers. Your task is to remove some bricks to form a mountain-shaped tower arrangement. In this arrangement, the tower heights are non-decreasing, reaching a maximum peak value with one or multiple consecutive towers and then non-increasing.
Return the maximum possible sum of heights of a mountain-shaped tower arrangement.
","Example 1:
Input: heights = [5,3,4,1,1]
Output: 13
Explanation:
We remove some bricks to make heights = [5,3,3,1,1], the peak is at index 0.
Example 2:
Input: heights = [6,5,3,9,2,7]
Output: 22
Explanation:
We remove some bricks to make heights = [3,3,3,9,2,2], the peak is at index 3.
Example 3:
Input: heights = [3,2,5,5,2,3]
Output: 18
Explanation:
We remove some bricks to make heights = [2,2,5,5,2,2], the peak is at index 2 or 3.
","class Solution:
    def maximumSumOfHeights(self, maxHeights: List[int]) -> int:

        # for each possible peek, compute maximum sum of heights;
        # this is achieved by maintaining a monotonic stack with 
        # heights and counts 
        
        def find_peak(arr):

            stack, acc = [], 0
            peeks = []

            for height in arr:
                count = 1
                while stack and height <= stack[-1][0]:
                    h, c = stack.pop()
                    acc -= h * c
                    count += c
                stack.append((height, count))
                acc += height * count
                peeks.append(acc)
            return peeks

        # precompute sums both from both tails (forward and reverse)
        fwd = [0] + find_peak(maxHeights)
        rev = find_peak(maxHeights[::-1])[::-1] + [0]

        # the answer is the maximum sum for two tails
        return max(f + r for f, r in zip(fwd, rev))",True
Longest Unequal Adjacent Groups Subsequence I,"You are given a string array words and a binary array groups both of length n, where words[i] is associated with groups[i].
Your task is to select the longest alternating
subsequence
from words. A subsequence of words is alternating if for any two consecutive strings in the sequence, their corresponding elements in the binary array groups differ. Essentially, you are to choose strings such that adjacent elements have non-matching corresponding bits in the groups array.
Formally, you need to find the longest subsequence of an array of indices [0, 1, ..., n - 1] denoted as [i0, i1, ..., ik-1], such that groups[ij] != groups[ij+1] for each 0 <= j < k - 1 and then find the words corresponding to these indices.
Return the selected subsequence. If there are multiple answers, return any of them.
Note: The elements in words are distinct.
","Example 1:
Input: words = [""e"",""a"",""b""], groups = [0,0,1]
Output: [""e"",""b""]
Explanation: A subsequence that can be selected is [""e"",""b""] because groups[0] != groups[2]. Another subsequence that can be selected is [""a"",""b""] because groups[1] != groups[2]. It can be demonstrated that the length of the longest subsequence of indices that satisfies the condition is 2.
Example 2:
Input: words = [""a"",""b"",""c"",""d""], groups = [1,0,1,1]
Output: [""a"",""b"",""c""]
Explanation: A subsequence that can be selected is [""a"",""b"",""c""] because groups[0] != groups[1] and groups[1] != groups[2]. Another subsequence that can be selected is [""a"",""b"",""d""] because groups[0] != groups[1] and groups[1] != groups[3]. It can be shown that the length of the longest subsequence of indices that satisfies the condition is 3.
",,False
Minimum Processing Time,"You have a certain number of processors, each having 4 cores. The number of tasks to be executed is four times the number of processors. Each task must be assigned to a unique core, and each core can only be used once.
You are given an array processorTime representing the time each processor becomes available and an array tasks representing how long each task takes to complete. Return the minimum time needed to complete all tasks.
","Example 1:
Input: processorTime = [8,10], tasks = [2,2,3,1,8,7,4,5]
Output: 16
Explanation:
Assign the tasks at indices 4, 5, 6, 7 to the first processor which becomes available at time = 8, and the tasks at indices 0, 1, 2, 3 to the second processor which becomes available at time = 10. 
The time taken by the first processor to finish the execution of all tasks is max(8 + 8, 8 + 7, 8 + 4, 8 + 5) = 16.
The time taken by the second processor to finish the execution of all tasks is max(10 + 2, 10 + 2, 10 + 3, 10 + 1) = 13.
Example 2:
Input: processorTime = [10,20], tasks = [2,3,1,2,5,8,4,3]
Output: 23
Explanation:
Assign the tasks at indices 1, 4, 5, 6 to the first processor and the others to the second processor.
The time taken by the first processor to finish the execution of all tasks is max(10 + 3, 10 + 5, 10 + 8, 10 + 4) = 18.
The time taken by the second processor to finish the execution of all tasks is max(20 + 2, 20 + 1, 20 + 2, 20 + 3) = 23.
","class Solution:
    def minProcessingTime(self, processorTime: List[int], tasks: List[int]) -> int:
        tasks, processorTime, ans = sorted(tasks), sorted(processorTime), 0
        for i in processorTime:
            ans = max(ans, i + max(tasks[-4:]))
            tasks = tasks[:-4]
        return ans
",True
Maximum Value of an Ordered Triplet II,"You are given a 0-indexed integer array nums.
Return the maximum value over all triplets of indices (i, j, k) such that i < j < k. If all such triplets have a negative value, return 0.
The value of a triplet of indices (i, j, k) is equal to (nums[i] - nums[j]) * nums[k].
","Example 1:
Input: nums = [12,6,1,2,7]
Output: 77
Explanation: The value of the triplet (0, 2, 4) is (nums[0] - nums[2]) * nums[4] = 77.
It can be shown that there are no ordered triplets of indices with a value greater than 77. 
Example 2:
Input: nums = [1,10,3,4,19]
Output: 133
Explanation: The value of the triplet (1, 2, 4) is (nums[1] - nums[2]) * nums[4] = 133.
It can be shown that there are no ordered triplets of indices with a value greater than 133.
Example 3:
Input: nums = [1,2,3]
Output: 0
Explanation: The only ordered triplet of indices (0, 1, 2) has a negative value of (nums[0] - nums[1]) * nums[2] = -3. Hence, the answer would be 0.
",,False
Maximum Value of an Ordered Triplet I,"You are given a 0-indexed integer array nums.
Return the maximum value over all triplets of indices (i, j, k) such that i < j < k. If all such triplets have a negative value, return 0.
The value of a triplet of indices (i, j, k) is equal to (nums[i] - nums[j]) * nums[k].
","Example 1:
Input: nums = [12,6,1,2,7]
Output: 77
Explanation: The value of the triplet (0, 2, 4) is (nums[0] - nums[2]) * nums[4] = 77.
It can be shown that there are no ordered triplets of indices with a value greater than 77. 
Example 2:
Input: nums = [1,10,3,4,19]
Output: 133
Explanation: The value of the triplet (1, 2, 4) is (nums[1] - nums[2]) * nums[4] = 133.
It can be shown that there are no ordered triplets of indices with a value greater than 133.
Example 3:
Input: nums = [1,2,3]
Output: 0
Explanation: The only ordered triplet of indices (0, 1, 2) has a negative value of (nums[0] - nums[1]) * nums[2] = -3. Hence, the answer would be 0.
","class Solution:
    def maximumTripletValue(self, nums: List[int], mx = 0) -> int:

        pref = accumulate(nums, max)
        suff = list(accumulate(nums[::-1], max))[::-1]

        return max(0,*((J-I) * K for I, J, K 
                                  in zip(nums[1:],pref,suff[2:])))",True
Last Visited Integers,"Given an integer array nums where nums[i] is either a positive integer or -1. We need to find for each -1 the respective positive integer, which we call the last visited integer.
To achieve this goal, let's define two empty arrays: seen and ans.
Start iterating from the beginning of the array nums.
If a positive integer is encountered, prepend it to the front of seen.
If -1 is encountered, let k be the number of consecutive -1s seen so far (including the current -1),
If k is less than or equal to the length of seen, append the k-th element of seen to ans.
If k is strictly greater than the length of seen, append -1 to ans.
Return the array ans.
","Example 1:
Input: nums = [1,2,-1,-1,-1]
Output: [2,1,-1]
Explanation:
Start with seen = [] and ans = [].
Process nums[0]: The first element in nums is 1. We prepend it to the front of seen. Now, seen == [1].
Process nums[1]: The next element is 2. We prepend it to the front of seen. Now, seen == [2, 1].
Process nums[2]: The next element is -1. This is the first occurrence of -1, so k == 1. We look for the first element in seen. We append 2 to ans. Now, ans == [2].
Process nums[3]: Another -1. This is the second consecutive -1, so k == 2. The second element in seen is 1, so we append 1 to ans. Now, ans == [2, 1].
Process nums[4]: Another -1, the third in a row, making k = 3. However, seen only has two elements ([2, 1]). Since k is greater than the number of elements in seen, we append -1 to ans. Finally, ans == [2, 1, -1].
Example 2:
Input: nums = [1,-1,2,-1,-1]
Output: [1,2,1]
Explanation:
Start with seen = [] and ans = [].
Process nums[0]: The first element in nums is 1. We prepend it to the front of seen. Now, seen == [1].
Process nums[1]: The next element is -1. This is the first occurrence of -1, so k == 1. We look for the first element in seen, which is 1. Append 1 to ans. Now, ans == [1].
Process nums[2]: The next element is 2. Prepend this to the front of seen. Now, seen == [2, 1].
Process nums[3]: The next element is -1. This -1 is not consecutive to the first -1 since 2 was in between. Thus, k resets to 1. The first element in seen is 2, so append 2 to ans. Now, ans == [1, 2].
Process nums[4]: Another -1. This is consecutive to the previous -1, so k == 2. The second element in seen is 1, append 1 to ans. Finally, ans == [1, 2, 1].
","class Solution:
    def lastVisitedIntegers(self, words: List[str]) -> List[int]:
        stack = []
        position = -1
        result = []
        for elem in words:
            if elem == 'prev':
                if position == -1:
                    result.append(-1)
                else:
                    result.append(stack[position])
                    position -= 1 
            else:
                stack.append(int(elem))
                position = len(stack) - 1
        
        return result",True
Find Indices With Index and Value Difference I,"You are given a 0-indexed integer array nums having length n, an integer indexDifference, and an integer valueDifference.
Your task is to find two indices i and j, both in the range [0, n - 1], that satisfy the following conditions:
abs(i - j) >= indexDifference, and
abs(nums[i] - nums[j]) >= valueDifference
Return an integer array answer, where answer = [i, j] if there are two such indices, and answer = [-1, -1] otherwise. If there are multiple choices for the two indices, return any of them.
Note: i and j may be equal.
","Example 1:
Input: nums = [5,1,4,1], indexDifference = 2, valueDifference = 4
Output: [0,3]
Explanation: In this example, i = 0 and j = 3 can be selected.
abs(0 - 3) >= 2 and abs(nums[0] - nums[3]) >= 4.
Hence, a valid answer is [0,3].
[3,0] is also a valid answer.
Example 2:
Input: nums = [2,1], indexDifference = 0, valueDifference = 0
Output: [0,0]
Explanation: In this example, i = 0 and j = 0 can be selected.
abs(0 - 0) >= 0 and abs(nums[0] - nums[0]) >= 0.
Hence, a valid answer is [0,0].
Other valid answers are [0,1], [1,0], and [1,1].
Example 3:
Input: nums = [1,2,3], indexDifference = 2, valueDifference = 4
Output: [-1,-1]
Explanation: In this example, it can be shown that it is impossible to find two indices that satisfy both conditions.
Hence, [-1,-1] is returned.
","class Solution:
    def findIndices(self, nums: List[int], indexDifference: int, valueDifference: int) -> List[int]:
        a = 0
        b = indexDifference
        while (a<len(nums)-indexDifference):
            if abs(nums[b] - nums[a]) >= valueDifference:
                return [a,b]
            elif not (abs(nums[b] - nums[a]) >= valueDifference) and b<len(nums)-1:
                b=b+1
            elif b == len(nums) - 1:
                a =a + 1
                b = a + indexDifference
            
        return [-1,-1]
        
",True
Find Indices With Index and Value Difference II,"You are given a 0-indexed integer array nums having length n, an integer indexDifference, and an integer valueDifference.
Your task is to find two indices i and j, both in the range [0, n - 1], that satisfy the following conditions:
abs(i - j) >= indexDifference, and
abs(nums[i] - nums[j]) >= valueDifference
Return an integer array answer, where answer = [i, j] if there are two such indices, and answer = [-1, -1] otherwise. If there are multiple choices for the two indices, return any of them.
Note: i and j may be equal.
","Example 1:
Input: nums = [5,1,4,1], indexDifference = 2, valueDifference = 4
Output: [0,3]
Explanation: In this example, i = 0 and j = 3 can be selected.
abs(0 - 3) >= 2 and abs(nums[0] - nums[3]) >= 4.
Hence, a valid answer is [0,3].
[3,0] is also a valid answer.
Example 2:
Input: nums = [2,1], indexDifference = 0, valueDifference = 0
Output: [0,0]
Explanation: In this example, i = 0 and j = 0 can be selected.
abs(0 - 0) >= 0 and abs(nums[0] - nums[0]) >= 0.
Hence, a valid answer is [0,0].
Other valid answers are [0,1], [1,0], and [1,1].
Example 3:
Input: nums = [1,2,3], indexDifference = 2, valueDifference = 4
Output: [-1,-1]
Explanation: In this example, it can be shown that it is impossible to find two indices that satisfy both conditions.
Hence, [-1,-1] is returned.
","class Solution:
    def findIndices(self, nums: List[int], indexDifference: int, valueDifference: int) -> List[int]:
        
        H1=[(nums[i],i) for i in range(indexDifference,len(nums))] # it will give me the smallest to largest (min heap)
        H2=[(-1*nums[i],i) for i in range(indexDifference,len(nums))] # it will give me the largest to smallest (max heap)
        heapq.heapify(H1)
        heapq.heapify(H2)
        for i in range(len(nums)-indexDifference):
            while abs(H1[0][1]-i)<indexDifference:
                heapq.heappop(H1)
            while abs(H2[0][1]-i)<indexDifference:
                heapq.heappop(H2)
            if abs(H1[0][0]-nums[i])>=valueDifference:
                return [i,H1[0][1]]
            if abs(-1*H2[0][0]-nums[i])>=valueDifference:
                return [i,H2[0][1]]
        return [-1,-1]",True
Minimum Equal Sum of Two Arrays After Replacing Zeros,"You are given two arrays nums1 and nums2 consisting of positive integers.
You have to replace all the 0's in both arrays with strictly positive integers such that the sum of elements of both arrays becomes equal.
Return the minimum equal sum you can obtain, or -1 if it is impossible.
","Example 1:
Input: nums1 = [3,2,0,1,0], nums2 = [6,5,0]
Output: 12
Explanation: We can replace 0's in the following way:
- Replace the two 0's in nums1 with the values 2 and 4. The resulting array is nums1 = [3,2,2,1,4].
- Replace the 0 in nums2 with the value 1. The resulting array is nums2 = [6,5,1].
Both arrays have an equal sum of 12. It can be shown that it is the minimum sum we can obtain.
Example 2:
Input: nums1 = [2,0,2,0], nums2 = [1,4]
Output: -1
Explanation: It is impossible to make the sum of both arrays equal.
","class Solution:
    def minSum(self, nums1: List[int], nums2: List[int]) -> int:
        # Calculate number of 0 in each array
        numOfZeros1 = nums1.count(0)
        numOfZeros2 = nums2.count(0)
        
       # Calculate sum of each array
        sum1 = sum(nums1)
        sum2 = sum(nums2)

        # Calculate min and max possible sum of each array after replacing all 0
        minNums1 = sum1 + numOfZeros1
        minNums2 = sum2 + numOfZeros2
        maxNums1 = inf if numOfZeros1 > 0 else sum1
        maxNums2 = inf if numOfZeros2 > 0 else sum2

        # If max sum of an array < min sum of the other array -> Impossible to have equal sum
        if maxNums1 < minNums2 or maxNums2 < minNums1:
            return -1
        
        # Return max of min possible sum of 2 arrays, so both arrays can each to that sum
        return max(minNums1, minNums2)
",True
Minimum Sum of Mountain Triplets I,"You are given a 0-indexed array nums of integers.
A triplet of indices (i, j, k) is a mountain if:
i < j < k
nums[i] < nums[j] and nums[k] < nums[j]
Return the minimum possible sum of a mountain triplet of nums. If no such triplet exists, return -1.
","Example 1:
Input: nums = [8,6,1,5,3]
Output: 9
Explanation: Triplet (2, 3, 4) is a mountain triplet of sum 9 since: 
- 2 < 3 < 4
- nums[2] < nums[3] and nums[4] < nums[3]
And the sum of this triplet is nums[2] + nums[3] + nums[4] = 9. It can be shown that there are no mountain triplets with a sum of less than 9.
Example 2:
Input: nums = [5,4,8,7,10,2]
Output: 13
Explanation: Triplet (1, 3, 5) is a mountain triplet of sum 13 since: 
- 1 < 3 < 5
- nums[1] < nums[3] and nums[5] < nums[3]
And the sum of this triplet is nums[1] + nums[3] + nums[5] = 13. It can be shown that there are no mountain triplets with a sum of less than 13.
Example 3:
Input: nums = [6,5,4,3,4,5]
Output: -1
Explanation: It can be shown that there are no mountain triplets in nums.
","class Solution:
    def minimumSum(self, nums: List[int]) -> int:
        
        if(len(nums) < 3):
            return -1
        
        min_sum = float('inf')
        
        for i in range(1,len(nums)-1):
            left_min = min(nums[:i])              # Maximum element on right side 
            right_min = min(nums[i+1:])           # Maximum element on left side 
            
            if(nums[i] > left_min and nums[i] > right_min):
                min_sum = min(min_sum , left_min + nums[i] + right_min)
                
                
        if(min_sum != float(""inf"")):
            return min_sum
        else:
            return -1",True
Minimum Increment Operations to Make Array Beautiful,"You are given a 0-indexed integer array nums having length n, and an integer k.
You can perform the following increment operation any number of times (including zero):
Choose an index i in the range [0, n - 1], and increase nums[i] by 1.
An array is considered beautiful if, for any subarray with a size of 3 or more, its maximum element is greater than or equal to k.
Return an integer denoting the minimum number of increment operations needed to make nums beautiful.
A subarray is a contiguous non-empty sequence of elements within an array.
","Example 1:
Input: nums = [2,3,0,0,2], k = 4
Output: 3
Explanation: We can perform the following increment operations to make nums beautiful:
Choose index i = 1 and increase nums[1] by 1 -> [2,4,0,0,2].
Choose index i = 4 and increase nums[4] by 1 -> [2,4,0,0,3].
Choose index i = 4 and increase nums[4] by 1 -> [2,4,0,0,4].
The subarrays with a size of 3 or more are: [2,4,0], [4,0,0], [0,0,4], [2,4,0,0], [4,0,0,4], [2,4,0,0,4].
In all the subarrays, the maximum element is equal to k = 4, so nums is now beautiful.
It can be shown that nums cannot be made beautiful with fewer than 3 increment operations.
Hence, the answer is 3.
Example 2:
Input: nums = [0,1,3,3], k = 5
Output: 2
Explanation: We can perform the following increment operations to make nums beautiful:
Choose index i = 2 and increase nums[2] by 1 -> [0,1,4,3].
Choose index i = 2 and increase nums[2] by 1 -> [0,1,5,3].
The subarrays with a size of 3 or more are: [0,1,5], [1,5,3], [0,1,5,3].
In all the subarrays, the maximum element is equal to k = 5, so nums is now beautiful.
It can be shown that nums cannot be made beautiful with fewer than 2 increment operations.
Hence, the answer is 2.
Example 3:
Input: nums = [1,1,2], k = 1
Output: 0
Explanation: The only subarray with a size of 3 or more in this example is [1,1,2].
The maximum element, 2, is already greater than k = 1, so we don't need any increment operation.
Hence, the answer is 0.
","class Solution {
public:
    long long minIncrementOperations(vector<int>& nums, int k) {
        int n = nums.size();
        vector<long long> dp(n + 1, 1e18); // Initialize a dynamic programming (DP) array with a large value.
        dp[0] = 0; // Initialize the base case.

        for (int i = 1; i <= n; i++) {
            long long required = max(0, k - nums[i - 1]); // Calculate the required increment for the current element.

            // Iterate through a specific range of previous elements to find the minimum cost.
            for (int j = i - 1; j >= max(0, i - 3); j--) {
                dp[i] = min(dp[j], dp[i]); // Update the DP array with the minimum cost.
            }
            dp[i] += required; // Add the required increment to the current DP state.
        }

        // Return the minimum cost from the last three states in the DP array.
        return min({dp[n], dp[n - 1], dp[n - 2]});
    }
};


",False
Find the K-or of an Array,"You are given an integer array nums, and an integer k. Let's introduce K-or operation by extending the standard bitwise OR. In K-or, a bit position in the result is set to 1 if at least k numbers in nums have a 1 in that position.
Return the K-or of nums.
","Example 1:
Input: nums = [7,12,9,8,9,15], k = 4
Output: 9
Explanation:
Represent numbers in binary:
Number Bit 3 Bit 2 Bit 1 Bit 0
7 0 1 1 1
12 1 1 0 0
9 1 0 0 1
8 1 0 0 0
9 1 0 0 1
15 1 1 1 1
Result = 9 1 0 0 1
Bit 0 is set in 7, 9, 9, and 15. Bit 3 is set in 12, 9, 8, 9, and 15.
Only bits 0 and 3 qualify. The result is (1001)2 = 9.
Example 2:
Input: nums = [2,12,1,11,4,5], k = 6
Output: 0
Explanation: No bit appears as 1 in all six array numbers, as required for K-or with k = 6. Thus, the result is 0.
Example 3:
Input: nums = [10,8,5,9,11,6,8], k = 1
Output: 15
Explanation: Since k == 1, the 1-or of the array is equal to the bitwise OR of all its elements. Hence, the answer is 10 OR 8 OR 5 OR 9 OR 11 OR 6 OR 8 = 15.
","class Solution:
    def findKOr(self, nums: List[int], k: int) -> int:

        nums = enumerate(zip_longest(*map(
                   lambda x: bin(x)[-1:1:-1],nums),fillvalue = '0'))

        return sum((1<<i)for i,arr in nums if arr.count('1') >= k)",True
Minimum Sum of Mountain Triplets II,"You are given a 0-indexed array nums of integers.
A triplet of indices (i, j, k) is a mountain if:
i < j < k
nums[i] < nums[j] and nums[k] < nums[j]
Return the minimum possible sum of a mountain triplet of nums. If no such triplet exists, return -1.
","Example 1:
Input: nums = [8,6,1,5,3]
Output: 9
Explanation: Triplet (2, 3, 4) is a mountain triplet of sum 9 since: 
- 2 < 3 < 4
- nums[2] < nums[3] and nums[4] < nums[3]
And the sum of this triplet is nums[2] + nums[3] + nums[4] = 9. It can be shown that there are no mountain triplets with a sum of less than 9.
Example 2:
Input: nums = [5,4,8,7,10,2]
Output: 13
Explanation: Triplet (1, 3, 5) is a mountain triplet of sum 13 since: 
- 1 < 3 < 5
- nums[1] < nums[3] and nums[5] < nums[3]
And the sum of this triplet is nums[1] + nums[3] + nums[5] = 13. It can be shown that there are no mountain triplets with a sum of less than 13.
Example 3:
Input: nums = [6,5,4,3,4,5]
Output: -1
Explanation: It can be shown that there are no mountain triplets in nums.
",,False
Minimum Operations to Maximize Last Elements in Arrays,"You are given two 0-indexed integer arrays, nums1 and nums2, both having length n.
You are allowed to perform a series of operations (possibly none).
In an operation, you select an index i in the range [0, n - 1] and swap the values of nums1[i] and nums2[i].
Your task is to find the minimum number of operations required to satisfy the following conditions:
nums1[n - 1] is equal to the maximum value among all elements of nums1, i.e., nums1[n - 1] = max(nums1[0], nums1[1], ..., nums1[n - 1]).
nums2[n - 1] is equal to the maximum value among all elements of nums2, i.e., nums2[n - 1] = max(nums2[0], nums2[1], ..., nums2[n - 1]).
Return an integer denoting the minimum number of operations needed to meet both conditions, or -1 if it is impossible to satisfy both conditions.
","Example 1:
Input: nums1 = [1,2,7], nums2 = [4,5,3]
Output: 1
Explanation: In this example, an operation can be performed using index i = 2.
When nums1[2] and nums2[2] are swapped, nums1 becomes [1,2,3] and nums2 becomes [4,5,7].
Both conditions are now satisfied.
It can be shown that the minimum number of operations needed to be performed is 1.
So, the answer is 1.
Example 2:
Input: nums1 = [2,3,4,5,9], nums2 = [8,8,4,4,4]
Output: 2
Explanation: In this example, the following operations can be performed:
First operation using index i = 4.
When nums1[4] and nums2[4] are swapped, nums1 becomes [2,3,4,5,4], and nums2 becomes [8,8,4,4,9].
Another operation using index i = 3.
When nums1[3] and nums2[3] are swapped, nums1 becomes [2,3,4,4,4], and nums2 becomes [8,8,4,5,9].
Both conditions are now satisfied.
It can be shown that the minimum number of operations needed to be performed is 2.
So, the answer is 2.   
Example 3:
Input: nums1 = [1,5,4], nums2 = [2,5,3]
Output: -1
Explanation: In this example, it is not possible to satisfy both conditions. 
So, the answer is -1.
","class Solution:
    def minOperations(self, nums1, nums2):
        dp1, dp2 = 0, 0 

        for i,j in zip(nums1,nums2):
            if max(i,j) > max(nums1[-1],nums2[-1]): return -1 
            if min(i,j) > min(nums1[-1],nums2[-1]): return -1
            if i > nums1[-1] or j > nums2[-1]: dp1 += 1
            if i > nums2[-1] or j > nums1[-1]: dp2 += 1

        return min(dp1,dp2)",True
Find Words Containing Character,"You are given a 0-indexed array of strings words and a character x.
Return an array of indices representing the words that contain the character x.
Note that the returned array may be in any order.
","Example 1:
Input: words = [""leet"",""code""], x = ""e""
Output: [0,1]
Explanation: ""e"" occurs in both words: ""leet"", and ""code"". Hence, we return indices 0 and 1.
Example 2:
Input: words = [""abc"",""bcd"",""aaaa"",""cbc""], x = ""a""
Output: [0,2]
Explanation: ""a"" occurs in ""abc"", and ""aaaa"". Hence, we return indices 0 and 2.
Example 3:
Input: words = [""abc"",""bcd"",""aaaa"",""cbc""], x = ""z""
Output: []
Explanation: ""z"" does not occur in any of the words. Hence, we return an empty array.
","class Solution {
    public List<Integer> findWordsContaining(String[] words, char x) {
        List<Integer> ans = new ArrayList<>();
       for(int i=0;i<words.length;i++){
           for(int j = 0; j < words[i].length(); j++){
               if(words[i].charAt(j) == x){
                   ans.add(i); 
                   break; 
               }

           }
              
       }
       
       return ans;

    }
}",False
High-Access Employees,"You are given a 2D 0-indexed array of strings, access_times, with size n. For each i where 0 <= i <= n - 1, access_times[i][0] represents the name of an employee, and access_times[i][1] represents the access time of that employee. All entries in access_times are within the same day.
The access time is represented as four digits using a 24-hour time format, for example, ""0800"" or ""2250"".
An employee is said to be high-access if he has accessed the system three or more times within a one-hour period.
Times with exactly one hour of difference are not considered part of the same one-hour period. For example, ""0815"" and ""0915"" are not part of the same one-hour period.
Access times at the start and end of the day are not counted within the same one-hour period. For example, ""0005"" and ""2350"" are not part of the same one-hour period.
Return a list that contains the names of high-access employees with any order you want.
","Example 1:
Input: access_times = [[""a"",""0549""],[""b"",""0457""],[""a"",""0532""],[""a"",""0621""],[""b"",""0540""]]
Output: [""a""]
Explanation: ""a"" has three access times in the one-hour period of [05:32, 06:31] which are 05:32, 05:49, and 06:21.
But ""b"" does not have more than two access times at all.
So the answer is [""a""].
Example 2:
Input: access_times = [[""d"",""0002""],[""c"",""0808""],[""c"",""0829""],[""e"",""0215""],[""d"",""1508""],[""d"",""1444""],[""d"",""1410""],[""c"",""0809""]]
Output: [""c"",""d""]
Explanation: ""c"" has three access times in the one-hour period of [08:08, 09:07] which are 08:08, 08:09, and 08:29.
""d"" has also three access times in the one-hour period of [14:10, 15:09] which are 14:10, 14:44, and 15:08.
However, ""e"" has just one access time, so it can not be in the answer and the final answer is [""c"",""d""].
Example 3:
Input: access_times = [[""cd"",""1025""],[""ab"",""1025""],[""cd"",""1046""],[""cd"",""1055""],[""ab"",""1124""],[""ab"",""1120""]]
Output: [""ab"",""cd""]
Explanation: ""ab"" has three access times in the one-hour period of [10:25, 11:24] which are 10:25, 11:20, and 11:24.
""cd"" has also three access times in the one-hour period of [10:25, 11:24] which are 10:25, 10:46, and 10:55.
So the answer is [""ab"",""cd""].
","class Solution:
    def findHighAccessEmployees(self, access_times: List[List[str]]) -> List[str]:
        answ=[]
        d={}
        for name,time in access_times:
            if name not in d:
                d[name]=[]
            time=int(time[:2])*60 + int(time[2:])
            d[name].append(time)
        for name,times in d.items():
            if 2<len(times):
                times.sort()
                for a,b in zip(times,times[2:]):
                    if b-a<60:
                        answ.append(name)
                        break
        return answ   ",True
Find Common Elements Between Two Arrays,"You are given two integer arrays nums1 and nums2 of sizes n and m, respectively. Calculate the following values:
answer1 : the number of indices i such that nums1[i] exists in nums2.
answer2 : the number of indices i such that nums2[i] exists in nums1.
Return [answer1,answer2].
","Example 1:
Input: nums1 = [2,3,2], nums2 = [1,2]
Output: [2,1]
Explanation:
Example 2:
Input: nums1 = [4,3,2,3,1], nums2 = [2,2,5,2,3,6]
Output: [3,4]
Explanation:
The elements at indices 1, 2, and 3 in nums1 exist in nums2 as well. So answer1 is 3.
The elements at indices 0, 1, 3, and 4 in nums2 exist in nums1. So answer2 is 4.
Example 3:
Input: nums1 = [3,4,2,3], nums2 = [1,5]
Output: [0,0]
Explanation:
No numbers are common between nums1 and nums2, so answer is [0,0].
",,False
Count Subarrays Where Max Element Appears at Least K Times,"You are given an integer array nums and a positive integer k.
Return the number of subarrays where the maximum element of nums appears at least k times in that subarray.
A subarray is a contiguous sequence of elements within an array.
","Example 1:
Input: nums = [1,3,2,3,3], k = 2
Output: 6
Explanation: The subarrays that contain the element 3 at least 2 times are: [1,3,2,3], [1,3,2,3,3], [3,2,3], [3,2,3,3], [2,3,3] and [3,3].
Example 2:
Input: nums = [1,4,2,1], k = 3
Output: 0
Explanation: No subarray contains the element 4 at least 3 times.
","class Solution {
    public long countSubarrays(int[] nums, int k) {
        int maxVal = 0;

        for (int val : nums) {
            maxVal = Math.max(maxVal, val);
        }

        int left = 0;
        int count = 0;
        long res = 0;
        for (int val : nums) {
            if (val == maxVal) {
                count++;
            }

            while (count >= k) {
                if (nums[left++] == maxVal) {
                    count--;
                } 
            }

            res += left;
        }

        return res;
    }
}",False
Matrix Similarity After Cyclic Shifts,"You are given an m x n integer matrix mat and an integer k. The matrix rows are 0-indexed.
The following proccess happens k times:
Even-indexed rows (0, 2, 4, ...) are cyclically shifted to the left.

Odd-indexed rows (1, 3, 5, ...) are cyclically shifted to the right.

Return true if the final modified matrix after k steps is identical to the original matrix, and false otherwise.
","Example 1:
Input: mat = [[1,2,3],[4,5,6],[7,8,9]], k = 4
Output: false
Explanation:
In each step left shift is applied to rows 0 and 2 (even indices), and right shift to row 1 (odd index).
Example 2:
Input: mat = [[1,2,1,2],[5,5,5,5],[6,3,6,3]], k = 2
Output: true
Explanation:
Example 3:
Input: mat = [[2,2],[2,2]], k = 3
Output: true
Explanation:
As all the values are equal in the matrix, even after performing cyclic shifts the matrix will remain the same.
","class Solution:
    def areSimilar(self, mat: List[List[int]], k: int) -> bool:
        m = len(mat)
        n = len(mat[0])
        k2 = k % n
        
        if k2 == 0:
            return True
        
        mat2 = []
        
        for i in range(m):
            row = mat[i]
            if i % 2 == 0:
                row2 = row[k2:] + row[:k2]
                mat2.append(row2)
            else:
                row2 = row[-k2:] + row[:n - k2]
                mat2.append(row2)
        
        return mat2 == mat
                
                ",True
Count Tested Devices After Test Operations,"You are given a 0-indexed integer array batteryPercentages having length n, denoting the battery percentages of n 0-indexed devices.
Your task is to test each device i in order from 0 to n - 1, by performing the following test operations:
If batteryPercentages[i] is greater than 0:
Increment the count of tested devices.
Decrease the battery percentage of all devices with indices j in the range [i + 1, n - 1] by 1, ensuring their battery percentage never goes below 0, i.e, batteryPercentages[j] = max(0, batteryPercentages[j] - 1).
Move to the next device.
Otherwise, move to the next device without performing any test.
Return an integer denoting the number of devices that will be tested after performing the test operations in order.
","Example 1:
Input: batteryPercentages = [1,1,2,1,3]
Output: 3
Explanation: Performing the test operations in order starting from device 0:
At device 0, batteryPercentages[0] > 0, so there is now 1 tested device, and batteryPercentages becomes [1,0,1,0,2].
At device 1, batteryPercentages[1] == 0, so we move to the next device without testing.
At device 2, batteryPercentages[2] > 0, so there are now 2 tested devices, and batteryPercentages becomes [1,0,1,0,1].
At device 3, batteryPercentages[3] == 0, so we move to the next device without testing.
At device 4, batteryPercentages[4] > 0, so there are now 3 tested devices, and batteryPercentages stays the same.
So, the answer is 3.
Example 2:
Input: batteryPercentages = [0,1,2]
Output: 2
Explanation: Performing the test operations in order starting from device 0:
At device 0, batteryPercentages[0] == 0, so we move to the next device without testing.
At device 1, batteryPercentages[1] > 0, so there is now 1 tested device, and batteryPercentages becomes [0,1,1].
At device 2, batteryPercentages[2] > 0, so there are now 2 tested devices, and batteryPercentages stays the same.
So, the answer is 2.
","class Solution:
    def countTestedDevices(self, batteryPercentages: List[int]) -> int:
        res = 0
        delta = 0
        for i,p in enumerate(batteryPercentages):
            if p - delta > 0:
                delta += 1
                res += 1
        return res
        ",True
Find the Peaks,"You are given a 0-indexed array mountain. Your task is to find all the peaks in the mountain array.
Return an array that consists of indices of peaks in the given array in any order.
Notes:
A peak is defined as an element that is strictly greater than its neighboring elements.
The first and last elements of the array are not a peak.
","Example 1:
Input: mountain = [2,4,4]
Output: []
Explanation: mountain[0] and mountain[2] can not be a peak because they are first and last elements of the array.
mountain[1] also can not be a peak because it is not strictly greater than mountain[2].
So the answer is [].
Example 2:
Input: mountain = [1,4,3,8,5]
Output: [1,3]
Explanation: mountain[0] and mountain[4] can not be a peak because they are first and last elements of the array.
mountain[2] also can not be a peak because it is not strictly greater than mountain[3] and mountain[1].
But mountain [1] and mountain[3] are strictly greater than their neighboring elements.
So the answer is [1,3].
","class Solution:
    def findPeaks(self, mountain: List[int]) -> List[int]:

        return [idx+1 for  idx, (a,b,c) in enumerate(zip(mountain, 
                            mountain[1:], mountain[2:])) if a<b>c]",True
Length of Longest Subarray With at Most K Frequency,"You are given an integer array nums and an integer k.
The frequency of an element x is the number of times it occurs in an array.
An array is called good if the frequency of each element in this array is less than or equal to k.
Return the length of the longest good subarray of nums.
A subarray is a contiguous non-empty sequence of elements within an array.
","Example 1:
Input: nums = [1,2,3,1,2,3,1,2], k = 2
Output: 6
Explanation: The longest possible good subarray is [1,2,3,1,2,3] since the values 1, 2, and 3 occur at most twice in this subarray. Note that the subarrays [2,3,1,2,3,1] and [3,1,2,3,1,2] are also good.
It can be shown that there are no good subarrays with length more than 6.
Example 2:
Input: nums = [1,2,1,2,1,2,1,2], k = 1
Output: 2
Explanation: The longest possible good subarray is [1,2] since the values 1 and 2 occur at most once in this subarray. Note that the subarray [2,1] is also good.
It can be shown that there are no good subarrays with length more than 2.
Example 3:
Input: nums = [5,5,5,5,5,5,5], k = 4
Output: 4
Explanation: The longest possible good subarray is [5,5,5,5] since the value 5 occurs 4 times in this subarray.
It can be shown that there are no good subarrays with length more than 4.
","class Solution:
    def maxSubarrayLength(self, nums: List[int], k: int) -> int:
        n=len(nums)
        start=0
        end=0
        ans=0
        freq={}
        while end<n:
            freq[nums[end]]=freq.get(nums[end],0)+1
            while freq[nums[end]]>k:
                freq[nums[start]]-=1
                start+=1
            ans=max(ans,end-start+1)
            end+=1  
        return ans      ",True
Minimum Number Game,"You are given a 0-indexed integer array nums of even length and there is also an empty array arr. Alice and Bob decided to play a game where in every round Alice and Bob will do one move. The rules of the game are as follows:
Every round, first Alice will remove the minimum element from nums, and then Bob does the same.
Now, first Bob will append the removed element in the array arr, and then Alice does the same.
The game continues until nums becomes empty.
Return the resulting array arr.
","Example 1:
Input: nums = [5,4,2,3]
Output: [3,2,5,4]
Explanation: In round one, first Alice removes 2 and then Bob removes 3. Then in arr firstly Bob appends 3 and then Alice appends 2. So arr = [3,2].
At the begining of round two, nums = [5,4]. Now, first Alice removes 4 and then Bob removes 5. Then both append in arr which becomes [3,2,5,4].
Example 2:
Input: nums = [2,5]
Output: [5,2]
Explanation: In round one, first Alice removes 2 and then Bob removes 5. Then in arr firstly Bob appends and then Alice appends. So arr = [5,2].
","class Solution:
    def numberGame(self, nums: List[int]) -> List[int]:
        #This is a sorted array.
        nums=sorted(nums) 
        # Swap each pair via loop
        for i in range(0,len(nums),2):
            nums[i],nums[i+1]=nums[i+1],nums[i]
        #Return the final array
        return nums    
        ",True
Find Missing and Repeated Values,"You are given a 0-indexed 2D integer matrix grid of size n * n with values in the range [1, n2]. Each integer appears exactly once except a which appears twice and b which is missing. The task is to find the repeating and missing numbers a and b.
Return a 0-indexed integer array ans of size 2 where ans[0] equals to a and ans[1] equals to b.
","Example 1:
Input: grid = [[1,3],[2,2]]
Output: [2,4]
Explanation: Number 2 is repeated and number 4 is missing so the answer is [2,4].
Example 2:
Input: grid = [[9,1,7],[8,9,2],[3,4,6]]
Output: [9,5]
Explanation: Number 9 is repeated and number 5 is missing so the answer is [9,5].
","class Solution:
    def findMissingAndRepeatedValues(self, grid: List[List[int]], ans = [0,0]) -> List[int]:

        n= len(ctr:= Counter(chain(*grid)))+1 

        for num in range(1, n+1):
            if ctr[num] == 1: continue
            ans[1-ctr[num]//2] = num

        return ans",True
Minimum Number of Coins to be Added,"You are given a 0-indexed integer array coins, representing the values of the coins available, and an integer target.
An integer x is obtainable if there exists a subsequence of coins that sums to x.
Return the minimum number of coins of any value that need to be added to the array so that every integer in the range [1, target] is obtainable.
A subsequence of an array is a new non-empty array that is formed from the original array by deleting some (possibly none) of the elements without disturbing the relative positions of the remaining elements.
","Example 1:
Input: coins = [1,4,10], target = 19
Output: 2
Explanation: We need to add coins 2 and 8. The resulting array will be [1,2,4,8,10].
It can be shown that all integers from 1 to 19 are obtainable from the resulting array, and that 2 is the minimum number of coins that need to be added to the array. 
Example 2:
Input: coins = [1,4,10,5,7,19], target = 19
Output: 1
Explanation: We only need to add the coin 2. The resulting array will be [1,2,4,5,7,10,19].
It can be shown that all integers from 1 to 19 are obtainable from the resulting array, and that 1 is the minimum number of coins that need to be added to the array. 
Example 3:
Input: coins = [1,1,1], target = 20
Output: 3
Explanation: We need to add coins 4, 8, and 16. The resulting array will be [1,1,1,4,8,16].
It can be shown that all integers from 1 to 20 are obtainable from the resulting array, and that 3 is the minimum number of coins that need to be added to the array.
","class Solution:
    def minimumAddedCoins(self, coins: List[int], target: int) -> int:
        amounts = defaultdict(int)
        for coin in coins:
            amounts[coin] += coin
        count = _sum = 0
        for i in range(1, target+1):
            if i in amounts:
                _sum += amounts[i]
            elif i > _sum:
                count += 1
                _sum += i
        return count",True
Smallest Missing Integer Greater Than Sequential Prefix Sum,"You are given a 0-indexed array of integers nums.
A prefix nums[0..i] is sequential if, for all 1 <= j <= i, nums[j] = nums[j - 1] + 1. In particular, the prefix consisting only of nums[0] is sequential.
Return the smallest integer x missing from nums such that x is greater than or equal to the sum of the longest sequential prefix.
","Example 1:
Input: nums = [1,2,3,2,5]
Output: 6
Explanation: The longest sequential prefix of nums is [1,2,3] with a sum of 6. 6 is not in the array, therefore 6 is the smallest missing integer greater than or equal to the sum of the longest sequential prefix.
Example 2:
Input: nums = [3,4,5,1,12,14,13]
Output: 15
Explanation: The longest sequential prefix of nums is [3,4,5] with a sum of 12. 12, 13, and 14 belong to the array while 15 does not. Therefore 15 is the smallest missing integer greater than or equal to the sum of the longest sequential prefix.
","class Solution {
public:
    int missingInteger(vector<int>& nums) {
        int sum=nums[0];
        for(int j=1;j<nums.size();j++)
        {
            if(nums[j]==nums[j-1]+1)
            sum=sum+nums[j];
            else
            break;
        }

        // Approach 1 :

        // sort(nums.begin(),nums.end());
        // for(int i=0;i<nums.size();i++)
        // if(nums[i]==sum)
        // sum++;
        
        //Approach 2 : 
        
        while(true)
        {
            bool k=false;
            for(int i=0;i<nums.size();i++)
            {
                if(nums[i]==sum)
                k=true;
            }
            if(k==false)
            return sum;
            sum++;
        }

        return -1;
        
    }
};",False
Divide Array Into Arrays With Max Difference,"You are given an integer array nums of size n and a positive integer k.
Divide the array into one or more arrays of size 3 satisfying the following conditions:
Each element of nums should be in exactly one array.
The difference between any two elements in one array is less than or equal to k.
Return a 2D array containing all the arrays. If it is impossible to satisfy the conditions, return an empty array. And if there are multiple answers, return any of them.
","Example 1:
Input: nums = [1,3,4,8,7,9,3,5,1], k = 2
Output: [[1,1,3],[3,4,5],[7,8,9]]
Explanation: We can divide the array into the following arrays: [1,1,3], [3,4,5] and [7,8,9].
The difference between any two elements in each array is less than or equal to 2.
Note that the order of elements is not important.
Example 2:
Input: nums = [1,3,3,2,7,3], k = 3
Output: []
Explanation: It is not possible to divide the array satisfying all the conditions.
","class Solution:
    def divideArray(self, nums: List[int], k: int) -> List[List[int]]:
        nums.sort()     

        if max(i-j for i, j in zip(nums[2::3],nums[::3])) > k: 
            return []
            
        return zip(nums[::3],nums[1::3],nums[2::3])




        '''
        :: is used for slicing sequences such as lists or strings. 
        The syntax for slicing is [start:stop:step]. 
        If start is not provided, it defaults to the beginning of the sequence. 
        If stop is not provided, it defaults to the end of the sequence. 
        If step is not provided, it defaults to 1.

        nums[::3] means “take every third element from nums, starting from the first element”. 
        Similarly, nums[1::3] means “take every third element from nums, 
        starting from the second element”, 
        and nums[2::3] means “take every third element from nums, 
        starting from the third element”.

        So, if nums is [0, 1, 2, 3, 4, 5, 6, 7, 8], then nums[::3] would be [0, 3, 6], 
        nums[1::3] would be [1, 4, 7], and nums[2::3] would be [2, 5, 8].
        '''


",True
Count Elements With Maximum Frequency,"You are given an array nums consisting of positive integers.
Return the total frequencies of elements in nums such that those elements all have the maximum frequency.
The frequency of an element is the number of occurrences of that element in the array.
","Example 1:
Input: nums = [1,2,2,3,1,4]
Output: 4
Explanation: The elements 1 and 2 have a frequency of 2 which is the maximum frequency in the array.
So the number of elements in the array with maximum frequency is 4.
Example 2:
Input: nums = [1,2,3,4,5]
Output: 5
Explanation: All elements of the array have a frequency of 1 which is the maximum.
So the number of elements in the array with maximum frequency is 5.
","class Solution:
    def maxFrequencyElements(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return 1
        m = max(nums)

        # Encode frequencies
        for i in range(len(nums)):
            nums[nums[i] % 101 % len(nums)] += pow(101, ((nums[i] % 101) // len(nums) + 1))

        # Find max frequency
        m_freq = 0
        pow_num = 101
        for i in range(1,m+1):
            if i % len(nums) == 0:
                pow_num *= 101
            if (nums[i % len(nums)] // pow_num) % 101 > m_freq:
                m_freq = (nums[i % len(nums)] // pow_num) % 101

        # Count amount of elements at max frequency
        pow_num = 101
        tot = 0
        for i in range(1,m+1):
            if i % len(nums) == 0:
                pow_num *= 101
            if (nums[i % len(nums)] // pow_num) % 101 == m_freq:
                tot += m_freq

        return tot
",True
Minimize Length of Array Using Operations,"You are given a 0-indexed integer array nums containing positive integers.
Your task is to minimize the length of nums by performing the following operations any number of times (including zero):
Select two distinct indices i and j from nums, such that nums[i] > 0 and nums[j] > 0.
Insert the result of nums[i] % nums[j] at the end of nums.
Delete the elements at indices i and j from nums.
Return an integer denoting the minimum length of nums after performing the operation any number of times.
","Example 1:
Input: nums = [1,4,3,1]
Output: 1
Explanation: One way to minimize the length of the array is as follows:
Operation 1: Select indices 2 and 1, insert nums[2] % nums[1] at the end and it becomes [1,4,3,1,3], then delete elements at indices 2 and 1.
nums becomes [1,1,3].
Operation 2: Select indices 1 and 2, insert nums[1] % nums[2] at the end and it becomes [1,1,3,1], then delete elements at indices 1 and 2.
nums becomes [1,1].
Operation 3: Select indices 1 and 0, insert nums[1] % nums[0] at the end and it becomes [1,1,0], then delete elements at indices 1 and 0.
nums becomes [0].
The length of nums cannot be reduced further. Hence, the answer is 1.
It can be shown that 1 is the minimum achievable length. 
Example 2:
Input: nums = [5,5,5,10,5]
Output: 2
Explanation: One way to minimize the length of the array is as follows:
Operation 1: Select indices 0 and 3, insert nums[0] % nums[3] at the end and it becomes [5,5,5,10,5,5], then delete elements at indices 0 and 3.
nums becomes [5,5,5,5]. 
Operation 2: Select indices 2 and 3, insert nums[2] % nums[3] at the end and it becomes [5,5,5,5,0], then delete elements at indices 2 and 3. 
nums becomes [5,5,0]. 
Operation 3: Select indices 0 and 1, insert nums[0] % nums[1] at the end and it becomes [5,5,0,0], then delete elements at indices 0 and 1.
nums becomes [0,0].
The length of nums cannot be reduced further. Hence, the answer is 2.
It can be shown that 2 is the minimum achievable length. 
Example 3:
Input: nums = [2,3,4]
Output: 1
Explanation: One way to minimize the length of the array is as follows: 
Operation 1: Select indices 1 and 2, insert nums[1] % nums[2] at the end and it becomes [2,3,4,3], then delete elements at indices 1 and 2.
nums becomes [2,3].
Operation 2: Select indices 1 and 0, insert nums[1] % nums[0] at the end and it becomes [2,3,1], then delete elements at indices 1 and 0.
nums becomes [1].
The length of nums cannot be reduced further. Hence, the answer is 1.
It can be shown that 1 is the minimum achievable length.
","class Solution:
    def minimumArrayLength(self, nums: List[int]) -> int:
        nums.sort()
        
        cnt = 1
        for num in nums[1:]:
            if num == nums[0]: cnt += 1
            else: 
                if num % nums[0] != 0: return 1
        return (cnt+1)//2",True
Check if Bitwise OR Has Trailing Zeros,"You are given an array of positive integers nums.
You have to check if it is possible to select two or more elements in the array such that the bitwise OR of the selected elements has at least one trailing zero in its binary representation.
For example, the binary representation of 5, which is ""101"", does not have any trailing zeros, whereas the binary representation of 4, which is ""100"", has two trailing zeros.
Return true if it is possible to select two or more elements whose bitwise OR has trailing zeros, return false otherwise.
","Example 1:
Input: nums = [1,2,3,4,5]
Output: true
Explanation: If we select the elements 2 and 4, their bitwise OR is 6, which has the binary representation ""110"" with one trailing zero.
Example 2:
Input: nums = [2,4,8,16]
Output: true
Explanation: If we select the elements 2 and 4, their bitwise OR is 6, which has the binary representation ""110"" with one trailing zero.
Other possible ways to select elements to have trailing zeroes in the binary representation of their bitwise OR are: (2, 8), (2, 16), (4, 8), (4, 16), (8, 16), (2, 4, 8), (2, 4, 16), (2, 8, 16), (4, 8, 16), and (2, 4, 8, 16).
Example 3:
Input: nums = [1,3,5,7,9]
Output: false
Explanation: There is no possible way to select two or more elements to have trailing zeros in the binary representation of their bitwise OR.
","class Solution:
    def hasTrailingZeros(self, nums: List[int]) -> bool:
        even = 0
		
        for n in nums:
            if n%2 == 0: 
                even += 1
        
		return even>=2",True
Minimum Number of Operations to Make Array XOR Equal to K,"You are given a 0-indexed integer array nums and a positive integer k.
You can apply the following operation on the array any number of times:
Choose any element of the array and flip a bit in its binary representation. Flipping a bit means changing a 0 to 1 or vice versa.
Return the minimum number of operations required to make the bitwise XOR of all elements of the final array equal to k.
Note that you can flip leading zero bits in the binary representation of elements. For example, for the number (101)2 you can flip the fourth bit and obtain (1101)2.
","Example 1:
Input: nums = [2,1,3,4], k = 1
Output: 2
Explanation: We can do the following operations:
- Choose element 2 which is 3 == (011)2, we flip the first bit and we obtain (010)2 == 2. nums becomes [2,1,2,4].
- Choose element 0 which is 2 == (010)2, we flip the third bit and we obtain (110)2 = 6. nums becomes [6,1,2,4].
The XOR of elements of the final array is (6 XOR 1 XOR 2 XOR 4) == 1 == k.
It can be shown that we cannot make the XOR equal to k in less than 2 operations.
Example 2:
Input: nums = [2,0,2,0], k = 0
Output: 0
Explanation: The XOR of elements of the array is (2 XOR 0 XOR 2 XOR 0) == 0 == k. So no operation is needed.
","class Solution:
  def minOperations(self, nums: List[int], k: int) -> int:
    return functools.reduce(operator.xor, nums, k).bit_count()",True
Maximum Area of Longest Diagonal Rectangle,"You are given a 2D 0-indexed integer array dimensions.
For all indices i, 0 <= i < dimensions.length, dimensions[i][0] represents the length and dimensions[i][1] represents the width of the rectangle i.
Return the area of the rectangle having the longest diagonal. If there are multiple rectangles with the longest diagonal, return the area of the rectangle having the maximum area.
","Example 1:
Input: dimensions = [[9,3],[8,6]]
Output: 48
Explanation: 
For index = 0, length = 9 and width = 3. Diagonal length = sqrt(9 * 9 + 3 * 3) = sqrt(90) ≈ 9.487.
For index = 1, length = 8 and width = 6. Diagonal length = sqrt(8 * 8 + 6 * 6) = sqrt(100) = 10.
So, the rectangle at index 1 has a greater diagonal length therefore we return area = 8 * 6 = 48.
Example 2:
Input: dimensions = [[3,4],[4,3]]
Output: 12
Explanation: Length of diagonal is the same for both which is 5, so maximum area = 12.
",,False
Find Polygon With the Largest Perimeter,"You are given an array of positive integers nums of length n.
A polygon is a closed plane figure that has at least 3 sides. The longest side of a polygon is smaller than the sum of its other sides.
Conversely, if you have k (k >= 3) positive real numbers a1, a2, a3, ..., ak where a1 <= a2 <= a3 <= ... <= ak and a1 + a2 + a3 + ... + ak-1 > ak, then there always exists a polygon with k sides whose lengths are a1, a2, a3, ..., ak.
The perimeter of a polygon is the sum of lengths of its sides.
Return the largest possible perimeter of a polygon whose sides can be formed from nums, or -1 if it is not possible to create a polygon.
","Example 1:
Input: nums = [5,5,5]
Output: 15
Explanation: The only possible polygon that can be made from nums has 3 sides: 5, 5, and 5. The perimeter is 5 + 5 + 5 = 15.
Example 2:
Input: nums = [1,12,1,2,5,50,3]
Output: 12
Explanation: The polygon with the largest perimeter which can be made from nums has 5 sides: 1, 1, 2, 3, and 5. The perimeter is 1 + 1 + 2 + 3 + 5 = 12.
We cannot have a polygon with either 12 or 50 as the longest side because it is not possible to include 2 or more smaller sides that have a greater sum than either of them.
It can be shown that the largest possible perimeter is 12.
Example 3:
Input: nums = [5,5,50]
Output: -1
Explanation: There is no possible way to form a polygon from nums, as a polygon has at least 3 sides and 50 > 5 + 5.
","class Solution {
public:
    long long largestPerimeter(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        long long sum = 0;
        long long ans = -1;
        
        for(int i=0;i<nums.size();i++){
            if(nums[i]<sum)ans = nums[i] + sum;
            sum+=nums[i];
        }
        
        return ans;
    }
};




",False
Maximum Good Subarray Sum,"You are given an array nums of length n and a positive integer k.
A
subarray
of nums is called good if the absolute difference between its first and last element is exactly k, in other words, the subarray nums[i..j] is good if |nums[i] - nums[j]| == k.
Return the maximum sum of a good subarray of nums. If there are no good subarrays, return 0.
","Example 1:
Input: nums = [1,2,3,4,5,6], k = 1
Output: 11
Explanation: The absolute difference between the first and last element must be 1 for a good subarray. All the good subarrays are: [1,2], [2,3], [3,4], [4,5], and [5,6]. The maximum subarray sum is 11 for the subarray [5,6].
Example 2:
Input: nums = [-1,3,2,4,5], k = 3
Output: 11
Explanation: The absolute difference between the first and last element must be 3 for a good subarray. All the good subarrays are: [-1,3,2], and [2,4,5]. The maximum subarray sum is 11 for the subarray [2,4,5].
Example 3:
Input: nums = [-1,-2,-3,-4], k = 2
Output: -6
Explanation: The absolute difference between the first and last element must be 2 for a good subarray. All the good subarrays are: [-1,-2,-3], and [-2,-3,-4]. The maximum subarray sum is -6 for the subarray [-1,-2,-3].
","class Solution:
    def maximumSubarraySum(self, nums: List[int], k: int) -> int:
        prefix_left = defaultdict(lambda: inf)
        res = -inf
        cur = 0 

        for x in nums:
            prefix_left[x] = min(prefix_left[x], cur)
            cur += x

            if x-k in prefix_left:
                res = max(res, cur - prefix_left[x-k])
            if x+k in prefix_left:
                res = max(res, cur - prefix_left[x+k])

        return res if res!=-inf else 0
            ",True
Number of Subarrays That Match a Pattern I,"You are given a 0-indexed integer array nums of size n, and a 0-indexed integer array pattern of size m consisting of integers -1, 0, and 1.
A
subarray
nums[i..j] of size m + 1 is said to match the pattern if the following conditions hold for each element pattern[k]:
nums[i + k + 1] > nums[i + k] if pattern[k] == 1.
nums[i + k + 1] == nums[i + k] if pattern[k] == 0.
nums[i + k + 1] < nums[i + k] if pattern[k] == -1.
Return the count of subarrays in nums that match the pattern.
","Example 1:
Input: nums = [1,2,3,4,5,6], pattern = [1,1]
Output: 4
Explanation: The pattern [1,1] indicates that we are looking for strictly increasing subarrays of size 3. In the array nums, the subarrays [1,2,3], [2,3,4], [3,4,5], and [4,5,6] match this pattern.
Hence, there are 4 subarrays in nums that match the pattern.
Example 2:
Input: nums = [1,4,4,1,3,5,5,3], pattern = [1,0,-1]
Output: 2
Explanation: Here, the pattern [1,0,-1] indicates that we are looking for a sequence where the first number is smaller than the second, the second is equal to the third, and the third is greater than the fourth. In the array nums, the subarrays [1,4,4,1], and [3,5,5,3] match this pattern.
Hence, there are 2 subarrays in nums that match the pattern.
","class Solution {
    public int countMatchingSubarrays(int[] nums, int[] pattern) {
        int n = nums.length;  // Size of the input array nums
        int m = pattern.length;  // Size of the pattern array
        int count = 0;  // Initialize the count of matching subarrays

        // Iterate through all possible starting indices of the subarray
        for (int i = 0; i < n; i++) {
            // Iterate through all possible ending indices of the subarray
            for (int j = i; j < n; j++) {
                // Check if the size of the current subarray is equal to m + 1
                if (j - i + 1 == m + 1) {
                    int l = i;  // Initialize a variable for tracking the current index in the subarray
                    int flag = 0;  // Initialize a flag to track if the subarray matches the pattern

                    // Iterate through the pattern and compare it with the subarray elements
                    for (int k = 0; k < m; k++, l++) {
                        // Check for the matching conditions based on the pattern values
                        if (pattern[k] == 1 && nums[l + 1] > nums[l]) {
                            // If pattern[k] is 1, check for strictly increasing condition
                            continue;
                        } else if (pattern[k] == 0 && nums[l + 1] == nums[l]) {
                            // If pattern[k] is 0, check for equal condition
                            continue;
                        } else if (pattern[k] == -1 && nums[l + 1] < nums[l]) {
                            // If pattern[k] is -1, check for strictly decreasing condition
                            continue;
                        } else {
                            // If any condition fails, set the flag and break out of the loop
                            flag = 1;
                            break;
                        }
                    }

                    // If the flag is still 0, the subarray matches the pattern, so increment the count
                    if (flag == 0) {
                        count++;
                    }
                }
            }
        }

        // Return the final count of matching subarrays
        return count;
    }
}
",False
Find the Number of Ways to Place People I,"You are given a 2D array points of size n x 2 representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi].
We define the right direction as positive x-axis (increasing x-coordinate) and the left direction as negative x-axis (decreasing x-coordinate). Similarly, we define the up direction as positive y-axis (increasing y-coordinate) and the down direction as negative y-axis (decreasing y-coordinate)
You have to place n people, including Alice and Bob, at these points such that there is exactly one person at every point. Alice wants to be alone with Bob, so Alice will build a rectangular fence with Alice's position as the upper left corner and Bob's position as the lower right corner of the fence (Note that the fence might not enclose any area, i.e. it can be a line). If any person other than Alice and Bob is either inside the fence or on the fence, Alice will be sad.
Return the number of pairs of points where you can place Alice and Bob, such that Alice does not become sad on building the fence.
Note that Alice can only build a fence with Alice's position as the upper left corner, and Bob's position as the lower right corner. For example, Alice cannot build either of the fences in the picture below with four corners (1, 1), (1, 3), (3, 1), and (3, 3), because:
With Alice at (3, 3) and Bob at (1, 1), Alice's position is not the upper left corner and Bob's position is not the lower right corner of the fence.
With Alice at (1, 3) and Bob at (1, 1), Bob's position is not the lower right corner of the fence.

","Example 1:

Input: points = [[1,1],[2,2],[3,3]]
Output: 0
Explanation: There is no way to place Alice and Bob such that Alice can build a fence with Alice's position as the upper left corner and Bob's position as the lower right corner. Hence we return 0. 
Example 2:

Input: points = [[6,2],[4,4],[2,6]]
Output: 2
Explanation: There are two ways to place Alice and Bob such that Alice will not be sad:
- Place Alice at (4, 4) and Bob at (6, 2).
- Place Alice at (2, 6) and Bob at (4, 4).
You cannot place Alice at (2, 6) and Bob at (6, 2) because the person at (4, 4) will be inside the fence.
Example 3:

Input: points = [[3,1],[1,3],[1,1]]
Output: 2
Explanation: There are two ways to place Alice and Bob such that Alice will not be sad:
- Place Alice at (1, 1) and Bob at (3, 1).
- Place Alice at (1, 3) and Bob at (1, 1).
You cannot place Alice at (1, 3) and Bob at (3, 1) because the person at (1, 1) will be on the fence.
Note that it does not matter if the fence encloses any area, the first and second fences in the image are valid.
","class Solution:
    def numberOfPairs(self, points: List[List[int]]) -> int:
        points.sort(key=lambda x: (x[0],-x[1]))
        cnt = 0
        for i in range(len(points)):
            y = -inf
            for j in range(i+1,len(points)):
                if  points[i][1] >= points[j][1] > y:
                    cnt += 1
                    y = points[j][1]
        return cnt",True
Find if Array Can Be Sorted,"You are given a 0-indexed array of positive integers nums.
In one operation, you can swap any two adjacent elements if they have the same number of
set bits
. You are allowed to do this operation any number of times (including zero).
Return true if you can sort the array, else return false.
","Example 1:
Input: nums = [8,4,2,30,15]
Output: true
Explanation: Let's look at the binary representation of every element. The numbers 2, 4, and 8 have one set bit each with binary representation ""10"", ""100"", and ""1000"" respectively. The numbers 15 and 30 have four set bits each with binary representation ""1111"" and ""11110"".
We can sort the array using 4 operations:
- Swap nums[0] with nums[1]. This operation is valid because 8 and 4 have one set bit each. The array becomes [4,8,2,30,15].
- Swap nums[1] with nums[2]. This operation is valid because 8 and 2 have one set bit each. The array becomes [4,2,8,30,15].
- Swap nums[0] with nums[1]. This operation is valid because 4 and 2 have one set bit each. The array becomes [2,4,8,30,15].
- Swap nums[3] with nums[4]. This operation is valid because 30 and 15 have four set bits each. The array becomes [2,4,8,15,30].
The array has become sorted, hence we return true.
Note that there may be other sequences of operations which also sort the array.
Example 2:
Input: nums = [1,2,3,4,5]
Output: true
Explanation: The array is already sorted, hence we return true.
Example 3:
Input: nums = [3,16,8,4,2]
Output: false
Explanation: It can be shown that it is not possible to sort the input array using any number of operations.
","class Solution:
    def canSortArray(self, nums: List[int]) -> bool:
        i = last = 0
        while i < len(nums):
            x = nums[i].bit_count()
            Min = Max = nums[i]
            j = i + 1
            while j < len(nums) and nums[j].bit_count() == x:
                Min = min(Min, nums[j])
                Max = max(Max, nums[j])
                j += 1
            if last > Min: return False
            i, last = j, Max
        return True",True
Earliest Second to Mark Indices I,"You are given two 1-indexed integer arrays, nums and, changeIndices, having lengths n and m, respectively.
Initially, all indices in nums are unmarked. Your task is to mark all indices in nums.
In each second, s, in order from 1 to m (inclusive), you can perform one of the following operations:
Choose an index i in the range [1, n] and decrement nums[i] by 1.
If nums[changeIndices[s]] is equal to 0, mark the index changeIndices[s].
Do nothing.
Return an integer denoting the earliest second in the range [1, m] when all indices in nums can be marked by choosing operations optimally, or -1 if it is impossible.
","Example 1:
Input: nums = [2,2,0], changeIndices = [2,2,2,2,3,2,2,1]
Output: 8
Explanation: In this example, we have 8 seconds. The following operations can be performed to mark all indices:
Second 1: Choose index 1 and decrement nums[1] by one. nums becomes [1,2,0].
Second 2: Choose index 1 and decrement nums[1] by one. nums becomes [0,2,0].
Second 3: Choose index 2 and decrement nums[2] by one. nums becomes [0,1,0].
Second 4: Choose index 2 and decrement nums[2] by one. nums becomes [0,0,0].
Second 5: Mark the index changeIndices[5], which is marking index 3, since nums[3] is equal to 0.
Second 6: Mark the index changeIndices[6], which is marking index 2, since nums[2] is equal to 0.
Second 7: Do nothing.
Second 8: Mark the index changeIndices[8], which is marking index 1, since nums[1] is equal to 0.
Now all indices have been marked.
It can be shown that it is not possible to mark all indices earlier than the 8th second.
Hence, the answer is 8.
Example 2:
Input: nums = [1,3], changeIndices = [1,1,1,2,1,1,1]
Output: 6
Explanation: In this example, we have 7 seconds. The following operations can be performed to mark all indices:
Second 1: Choose index 2 and decrement nums[2] by one. nums becomes [1,2].
Second 2: Choose index 2 and decrement nums[2] by one. nums becomes [1,1].
Second 3: Choose index 2 and decrement nums[2] by one. nums becomes [1,0].
Second 4: Mark the index changeIndices[4], which is marking index 2, since nums[2] is equal to 0.
Second 5: Choose index 1 and decrement nums[1] by one. nums becomes [0,0].
Second 6: Mark the index changeIndices[6], which is marking index 1, since nums[1] is equal to 0.
Now all indices have been marked.
It can be shown that it is not possible to mark all indices earlier than the 6th second.
Hence, the answer is 6.
Example 3:
Input: nums = [0,1], changeIndices = [2,2,2]
Output: -1
Explanation: In this example, it is impossible to mark all indices because index 1 isn't in changeIndices.
Hence, the answer is -1.
","class Solution:
    def earliestSecondToMarkIndices(self, nums: List[int], changeIndices: List[int]) -> int:
        n = len(nums)
        m = len(changeIndices)

        # decreased indices for convenience
        for i in range(m):
            changeIndices[i] -= 1
        
        def isGood(pos):
            used = [False]*n
            # points - how many points are reserved on the left side
            # for already used numbers
            points = 0
            for i in range(pos, -1, -1):
                if used[changeIndices[i]]:
                    points = max(0, points-1)
                    continue
                num = changeIndices[i]
                used[num] = True
                if nums[num] > (i-points):
                    return False
                points += nums[num]
            # all numbers should be marked
            return used.count(False) == 0
        
        # binary search
        lo = 0
        hi = m - 1
        
        best = -1
        while lo <= hi:
            mid = (lo+hi) // 2
            
            if isGood(mid):
                best = mid+1
                hi = mid-1
            else:
                lo = mid+1
        
        return best    ",True
Find the Maximum Number of Elements in Subset,"You are given an array of positive integers nums.
You need to select a
subset
of nums which satisfies the following condition:
You can place the selected elements in a 0-indexed array such that it follows the pattern: [x, x2, x4, ..., xk/2, xk, xk/2, ..., x4, x2, x] (Note that k can be be any non-negative power of 2). For example, [2, 4, 16, 4, 2] and [3, 9, 3] follow the pattern while [2, 4, 8, 4, 2] does not.
Return the maximum number of elements in a subset that satisfies these conditions.
","Example 1:
Input: nums = [5,4,1,2,2]
Output: 3
Explanation: We can select the subset {4,2,2}, which can be placed in the array as [2,4,2] which follows the pattern and 22 == 4. Hence the answer is 3.
Example 2:
Input: nums = [1,3,2,4]
Output: 1
Explanation: We can select the subset {1}, which can be placed in the array as [1] which follows the pattern. Hence the answer is 1. Note that we could have also selected the subsets {2}, {3}, or {4}, there may be multiple subsets which provide the same answer. 
","class Solution:
    def maximumLength(self, nums: List[int]) -> int:
        freq = defaultdict(int)
        for num in nums:
            freq[num]+=1
        @cache
        def build(n):
            up = n**2
            if up not in freq or freq[n]==1:
                return 1
            if up == n:
                return freq[n]-1 if freq[n]%2==0 else freq[n]
            if freq[up]==1:
                return 3
            return build(up)+2
        ret=1
        for num in freq.keys():
            ret=max(ret, build(num))
        return ret
            
'''
[1,1,1,1,1]
[5,4,1,2,2]
[1,3,2,4]
[1,1]
[14,14,196,196,38416,38416]
[1,1,1,1,1,1,1,1,1,1,2,4,8,16,32,64,128,256,512,1024]

'''",True
Mark Elements on Array by Performing Queries,"You are given a 0-indexed array nums of size n consisting of positive integers.
You are also given a 2D array queries of size m where queries[i] = [indexi, ki].
Initially all elements of the array are unmarked.
You need to apply m queries on the array in order, where on the ith query you do the following:
Mark the element at index indexi if it is not already marked.
Then mark ki unmarked elements in the array with the smallest values. If multiple such elements exist, mark the ones with the smallest indices. And if less than ki unmarked elements exist, then mark all of them.
Return an array answer of size m where answer[i] is the sum of unmarked elements in the array after the ith query.
","Example 1:
Input: nums = [1,2,2,1,2,3,1], queries = [[1,2],[3,3],[4,2]]
Output: [8,3,0]
Explanation:
We do the following queries on the array:
Mark the element at index 1, and 2 of the smallest unmarked elements with the smallest indices if they exist, the marked elements now are nums = [1,2,2,1,2,3,1]. The sum of unmarked elements is 2 + 2 + 3 + 1 = 8.
Mark the element at index 3, since it is already marked we skip it. Then we mark 3 of the smallest unmarked elements with the smallest indices, the marked elements now are nums = [1,2,2,1,2,3,1]. The sum of unmarked elements is 3.
Mark the element at index 4, since it is already marked we skip it. Then we mark 2 of the smallest unmarked elements with the smallest indices if they exist, the marked elements now are nums = [1,2,2,1,2,3,1]. The sum of unmarked elements is 0.
Example 2:
Input: nums = [1,4,2,3], queries = [[0,1]]
Output: [7]
Explanation: We do one query which is mark the element at index 0 and mark the smallest element among unmarked elements. The marked elements will be nums = [1,4,2,3], and the sum of unmarked elements is 4 + 3 = 7.
","class Solution:
    def unmarkedSumArray(self, nums: List[int], 
                               queries: List[List[int]]) -> List[int]:

        n, sm = len(nums), sum(nums)
        unmarked, ans = set(range(n)), []

        heap = list(zip(nums,range(len(nums))))
        heapify(heap)

        for idx, k in queries:

            if idx in unmarked:
                sm -= nums[idx]
                unmarked.discard(idx)

            while k and heap:

                num, idx = heappop(heap) 

                if idx in unmarked:               
                    unmarked.discard(idx)
                    k-= 1
                    sm-= num

            ans.append(sm)

        return ans",True
Apply Operations to Make String Empty,"You are given a string s.
Consider performing the following operation until s becomes empty:
For every alphabet character from 'a' to 'z', remove the first occurrence of that character in s (if it exists).
For example, let initially s = ""aabcbbca"". We do the following operations:
Remove the underlined characters s = ""aabcbbca"". The resulting string is s = ""abbca"".
Remove the underlined characters s = ""abbca"". The resulting string is s = ""ba"".
Remove the underlined characters s = ""ba"". The resulting string is s = """".
Return the value of the string s right before applying the last operation. In the example above, answer is ""ba"".
","Example 1:
Input: s = ""aabcbbca""
Output: ""ba""
Explanation: Explained in the statement.
Example 2:
Input: s = ""abcd""
Output: ""abcd""
Explanation: We do the following operation:
- Remove the underlined characters s = ""abcd"". The resulting string is s = """".
The string just before the last operation is ""abcd"".
",,False
Count Prefix and Suffix Pairs I,"You are given a 0-indexed string array words.
Let's define a boolean function isPrefixAndSuffix that takes two strings, str1 and str2:
isPrefixAndSuffix(str1, str2) returns true if str1 is both a
prefix
and a
suffix
of str2, and false otherwise.
For example, isPrefixAndSuffix(""aba"", ""ababa"") is true because ""aba"" is a prefix of ""ababa"" and also a suffix, but isPrefixAndSuffix(""abc"", ""abcd"") is false.
Return an integer denoting the number of index pairs (i, j) such that i < j, and isPrefixAndSuffix(words[i], words[j]) is true.
","Example 1:
Input: words = [""a"",""aba"",""ababa"",""aa""]
Output: 4
Explanation: In this example, the counted index pairs are:
i = 0 and j = 1 because isPrefixAndSuffix(""a"", ""aba"") is true.
i = 0 and j = 2 because isPrefixAndSuffix(""a"", ""ababa"") is true.
i = 0 and j = 3 because isPrefixAndSuffix(""a"", ""aa"") is true.
i = 1 and j = 2 because isPrefixAndSuffix(""aba"", ""ababa"") is true.
Therefore, the answer is 4.
Example 2:
Input: words = [""pa"",""papa"",""ma"",""mama""]
Output: 2
Explanation: In this example, the counted index pairs are:
i = 0 and j = 1 because isPrefixAndSuffix(""pa"", ""papa"") is true.
i = 2 and j = 3 because isPrefixAndSuffix(""ma"", ""mama"") is true.
Therefore, the answer is 2.  
Example 3:
Input: words = [""abab"",""ab""]
Output: 0
Explanation: In this example, the only valid index pair is i = 0 and j = 1, and isPrefixAndSuffix(""abab"", ""ab"") is false.
Therefore, the answer is 0.
","class Solution:
    def countPrefixSuffixPairs(self, w: List[str]) -> int:
        count = 0
        for i in range(len(w)):
            t = len(w[i])
            for j in range(i+1,len(w)):
                if len(w[j])>=t:
                    if w[j][:t]==w[i] and w[j][-t:]==w[i]:
                        count+=1
        return count
                
        ",True
Ant on the Boundary,"An ant is on a boundary. It sometimes goes left and sometimes right.
You are given an array of non-zero integers nums. The ant starts reading nums from the first element of it to its end. At each step, it moves according to the value of the current element:
If nums[i] < 0, it moves left by -nums[i] units.
If nums[i] > 0, it moves right by nums[i] units.
Return the number of times the ant returns to the boundary.
Notes:
There is an infinite space on both sides of the boundary.
We check whether the ant is on the boundary only after it has moved |nums[i]| units. In other words, if the ant crosses the boundary during its movement, it does not count.
","Example 1:
Input: nums = [2,3,-5]
Output: 1
Explanation: After the first step, the ant is 2 steps to the right of the boundary.
After the second step, the ant is 5 steps to the right of the boundary.
After the third step, the ant is on the boundary.
So the answer is 1.
Example 2:
Input: nums = [3,2,-3,-4]
Output: 0
Explanation: After the first step, the ant is 3 steps to the right of the boundary.
After the second step, the ant is 5 steps to the right of the boundary.
After the third step, the ant is 2 steps to the right of the boundary.
After the fourth step, the ant is 2 steps to the left of the boundary.
The ant never returned to the boundary, so the answer is 0.
","class Solution:
    def returnToBoundaryCount(self, nums: List[int]) -> int:
        answ,pos=0,0
        for num in nums:
            pos+=num
            answ+=pos==0
        return answ    ",True
Most Frequent Prime,"You are given a m x n 0-indexed 2D matrix mat. From every cell, you can create numbers in the following way:
There could be at most 8 paths from the cells namely: east, south-east, south, south-west, west, north-west, north, and north-east.
Select a path from them and append digits in this path to the number being formed by traveling in this direction.
Note that numbers are generated at every step, for example, if the digits along the path are 1, 9, 1, then there will be three numbers generated along the way: 1, 19, 191.
Return the most frequent
prime number
greater than 10 out of all the numbers created by traversing the matrix or -1 if no such prime number exists. If there are multiple prime numbers with the highest frequency, then return the largest among them.
Note: It is invalid to change the direction during the move.
","Example 1:

Input: mat = [[1,1],[9,9],[1,1]]
Output: 19
Explanation: 
From cell (0,0) there are 3 possible directions and the numbers greater than 10 which can be created in those directions are:
East: [11], South-East: [19], South: [19,191].
Numbers greater than 10 created from the cell (0,1) in all possible directions are: [19,191,19,11].
Numbers greater than 10 created from the cell (1,0) in all possible directions are: [99,91,91,91,91].
Numbers greater than 10 created from the cell (1,1) in all possible directions are: [91,91,99,91,91].
Numbers greater than 10 created from the cell (2,0) in all possible directions are: [11,19,191,19].
Numbers greater than 10 created from the cell (2,1) in all possible directions are: [11,19,19,191].
The most frequent prime number among all the created numbers is 19.
Example 2:
Input: mat = [[7]]
Output: -1
Explanation: The only number which can be formed is 7. It is a prime number however it is not greater than 10, so return -1.
Example 3:
Input: mat = [[9,7,8],[4,6,5],[2,8,6]]
Output: 97
Explanation: 
Numbers greater than 10 created from the cell (0,0) in all possible directions are: [97,978,96,966,94,942].
Numbers greater than 10 created from the cell (0,1) in all possible directions are: [78,75,76,768,74,79].
Numbers greater than 10 created from the cell (0,2) in all possible directions are: [85,856,86,862,87,879].
Numbers greater than 10 created from the cell (1,0) in all possible directions are: [46,465,48,42,49,47].
Numbers greater than 10 created from the cell (1,1) in all possible directions are: [65,66,68,62,64,69,67,68].
Numbers greater than 10 created from the cell (1,2) in all possible directions are: [56,58,56,564,57,58].
Numbers greater than 10 created from the cell (2,0) in all possible directions are: [28,286,24,249,26,268].
Numbers greater than 10 created from the cell (2,1) in all possible directions are: [86,82,84,86,867,85].
Numbers greater than 10 created from the cell (2,2) in all possible directions are: [68,682,66,669,65,658].
The most frequent prime number among all the created numbers is 97.
","class Solution:
    def mostFrequentPrime(self, mat: List[List[int]]) -> int:

        nums = []
        m,n, d = range(len(mat)),range(len(mat[0])), (-1,0,1)
        
        def isPrime(num):
            if num < 10 or num%2 == 0: return False
            for i in range(3, isqrt(num)+1, 2):
                if num %i == 0: return False
            return True
        
        for x, y, dx,dy in product(m,n, d,d):
                if dx == 0 == dy: continue
                X, Y, num = x+dx, y+dy, mat[x][y]

                while X in m and Y in n:
                    nums.append(num:= num*10 + mat[X][Y])
                    X+= dx
                    Y+= dy      
        
        return max(filter(isPrime, ctr:= Counter(nums)), 
                key = lambda x: (ctr[x], x), default = -1)",True
Maximum Palindromes After Operations,"You are given a 0-indexed string array words having length n and containing 0-indexed strings.
You are allowed to perform the following operation any number of times (including zero):
Choose integers i, j, x, and y such that 0 <= i, j < n, 0 <= x < words[i].length, 0 <= y < words[j].length, and swap the characters words[i][x] and words[j][y].
Return an integer denoting the maximum number of
palindromes
words can contain, after performing some operations.
Note: i and j may be equal during an operation.
","Example 1:
Input: words = [""abbb"",""ba"",""aa""]
Output: 3
Explanation: In this example, one way to get the maximum number of palindromes is:
Choose i = 0, j = 1, x = 0, y = 0, so we swap words[0][0] and words[1][0]. words becomes [""bbbb"",""aa"",""aa""].
All strings in words are now palindromes.
Hence, the maximum number of palindromes achievable is 3.
Example 2:
Input: words = [""abc"",""ab""]
Output: 2
Explanation: In this example, one way to get the maximum number of palindromes is: 
Choose i = 0, j = 1, x = 1, y = 0, so we swap words[0][1] and words[1][0]. words becomes [""aac"",""bb""].
Choose i = 0, j = 0, x = 1, y = 2, so we swap words[0][1] and words[0][2]. words becomes [""aca"",""bb""].
Both strings are now palindromes.
Hence, the maximum number of palindromes achievable is 2.
Example 3:
Input: words = [""cd"",""ef"",""a""]
Output: 1
Explanation: In this example, there is no need to perform any operation.
There is one palindrome in words ""a"".
It can be shown that it is not possible to get more than one palindrome after any number of operations.
Hence, the answer is 1.
",,False
Maximum Number of Operations With the Same Score II,"Given an array of integers called nums, you can perform any of the following operation while nums contains at least 2 elements:
Choose the first two elements of nums and delete them.
Choose the last two elements of nums and delete them.
Choose the first and the last elements of nums and delete them.
The score of the operation is the sum of the deleted elements.
Your task is to find the maximum number of operations that can be performed, such that all operations have the same score.
Return the maximum number of operations possible that satisfy the condition mentioned above.
","Example 1:
Input: nums = [3,2,1,2,3,4]
Output: 3
Explanation: We perform the following operations:
- Delete the first two elements, with score 3 + 2 = 5, nums = [1,2,3,4].
- Delete the first and the last elements, with score 1 + 4 = 5, nums = [2,3].
- Delete the first and the last elements, with score 2 + 3 = 5, nums = [].
We are unable to perform any more operations as nums is empty.
Example 2:
Input: nums = [3,2,6,1,4]
Output: 2
Explanation: We perform the following operations:
- Delete the first two elements, with score 3 + 2 = 5, nums = [6,1,4].
- Delete the last two elements, with score 1 + 4 = 5, nums = [6].
It can be proven that we can perform at most 2 operations.
","class Solution:
    def maxOperations(self, nums: List[int]) -> int:

        @cache
        def dfs(l, r, scr):
            if l >= r: return 0

            ans = 0
            left = nums[l] + nums[l+1]
            right = nums[r] + nums[r-1]
            mid = nums[l] + nums[r]

            if scr==0 or scr == left:
                ans = max(ans, 1 + dfs(l+2, r, max(scr, left)))
            if scr == 0 or scr == right:
                ans = max(ans, 1 + dfs(l, r-2, max(scr, right)))
            if scr == 0 or scr == mid:
                ans = max(ans, 1+ dfs(l+1, r-1, max(scr, mid)))
            return ans

        return dfs(0, len(nums) -1, 0)
        ",True
Type of Triangle,"You are given a 0-indexed integer array nums of size 3 which can form the sides of a triangle.
A triangle is called equilateral if it has all sides of equal length.
A triangle is called isosceles if it has exactly two sides of equal length.
A triangle is called scalene if all its sides are of different lengths.
Return a string representing the type of triangle that can be formed or ""none"" if it cannot form a triangle.
","Example 1:
Input: nums = [3,3,3]
Output: ""equilateral""
Explanation: Since all the sides are of equal length, therefore, it will form an equilateral triangle.
Example 2:
Input: nums = [3,4,5]
Output: ""scalene""
Explanation: 
nums[0] + nums[1] = 3 + 4 = 7, which is greater than nums[2] = 5.
nums[0] + nums[2] = 3 + 5 = 8, which is greater than nums[1] = 4.
nums[1] + nums[2] = 4 + 5 = 9, which is greater than nums[0] = 3. 
Since the sum of the two sides is greater than the third side for all three cases, therefore, it can form a triangle.
As all the sides are of different lengths, it will form a scalene triangle.
","class Solution:
    def triangleType(self, nums: List[int]) -> str:
        if nums[0]==nums[1]==nums[2]:
            return ""equilateral""
        elif (nums[0]+nums[1] > nums[2])  and (nums[0]+nums[2] > nums[1]) and (nums[1]+nums[2] > nums[0]):
            if nums[0]==nums[1] or nums[0]==nums[2] or nums[1]==nums[2]:
                return ""isosceles""
            else:
                return ""scalene""
        else:
            return ""none""",True
Find the Largest Area of Square Inside Two Rectangles,"There exist n rectangles in a 2D plane. You are given two 0-indexed 2D integer arrays bottomLeft and topRight, both of size n x 2, where bottomLeft[i] and topRight[i] represent the bottom-left and top-right coordinates of the ith rectangle respectively.
You can select a region formed from the intersection of two of the given rectangles. You need to find the largest area of a square that can fit inside this region if you select the region optimally.
Return the largest possible area of a square, or 0 if there do not exist any intersecting regions between the rectangles.
","Example 1:

Input: bottomLeft = [[1,1],[2,2],[3,1]], topRight = [[3,3],[4,4],[6,6]]
Output: 1
Explanation: A square with side length 1 can fit inside either the intersecting region of rectangle 0 and rectangle 1, or the intersecting region of rectangle 1 and rectangle 2. Hence the largest area is side * side which is 1 * 1 == 1.
It can be shown that a square with a greater side length can not fit inside any intersecting region.
Example 2:

Input: bottomLeft = [[1,1],[2,2],[1,2]], topRight = [[3,3],[4,4],[3,4]]
Output: 1
Explanation: A square with side length 1 can fit inside either the intersecting region of rectangle 0 and rectangle 1, the intersecting region of rectangle 1 and rectangle 2, or the intersection region of all 3 rectangles. Hence the largest area is side * side which is 1 * 1 == 1.
It can be shown that a square with a greater side length can not fit inside any intersecting region.
Note that the region can be formed by the intersection of more than 2 rectangles.
Example 3:

Input: bottomLeft = [[1,1],[3,3],[3,1]], topRight = [[2,2],[4,4],[4,2]]
Output: 0
Explanation: No pair of rectangles intersect, hence, we return 0.
","class Solution:
    def largestSquareArea(self, bottomLeft: List[List[int]], topRight: List[List[int]]) -> int:
        n = len(bottomLeft)
        res = 0
        for i in range(n):
            for j in range(i+1, n):
                w = max(0, min(topRight[i][0], topRight[j][0]) - max(bottomLeft[i][0], bottomLeft[j][0]))                
                h = max(0, min(topRight[i][1], topRight[j][1]) - max(bottomLeft[i][1], bottomLeft[j][1]))
                res = max(res, min(w, h)**2)
        return res
                    
        
        ",True
Find the Length of the Longest Common Prefix,"You are given two arrays with positive integers arr1 and arr2.
A prefix of a positive integer is an integer formed by one or more of its digits, starting from its leftmost digit. For example, 123 is a prefix of the integer 12345, while 234 is not.
A common prefix of two integers a and b is an integer c, such that c is a prefix of both a and b. For example, 5655359 and 56554 have a common prefix 565 while 1223 and 43456 do not have a common prefix.
You need to find the length of the longest common prefix between all pairs of integers (x, y) such that x belongs to arr1 and y belongs to arr2.
Return the length of the longest common prefix among all pairs. If no common prefix exists among them, return 0.
","Example 1:
Input: arr1 = [1,10,100], arr2 = [1000]
Output: 3
Explanation: There are 3 pairs (arr1[i], arr2[j]):
- The longest common prefix of (1, 1000) is 1.
- The longest common prefix of (10, 1000) is 10.
- The longest common prefix of (100, 1000) is 100.
The longest common prefix is 100 with a length of 3.
Example 2:
Input: arr1 = [1,2,3], arr2 = [4,4,4]
Output: 0
Explanation: There exists no common prefix for any pair (arr1[i], arr2[j]), hence we return 0.
Note that common prefixes between elements of the same array do not count.
","class Solution:
    def longestCommonPrefix(self, arr1, arr2):
        dict1, max_len = collections.defaultdict(int), 0

        for i in range(len(arr1)):
            str1 = """"
            for j in str(arr1[i]):
                str1 += j  
                dict1[str1] += 1 

        for i in range(len(arr2)):
            str2 = """"
            for j in str(arr2[i]):
                str2 += j 
                if str2 in dict1:
                    max_len = max(max_len,len(str2))


        return max_len   


        ",True
Modify the Matrix,"Given a 0-indexed m x n integer matrix matrix, create a new 0-indexed matrix called answer. Make answer equal to matrix, then replace each element with the value -1 with the maximum element in its respective column.
Return the matrix answer.
","Example 1:

Input: matrix = [[1,2,-1],[4,-1,6],[7,8,9]]
Output: [[1,2,9],[4,8,6],[7,8,9]]
Explanation: The diagram above shows the elements that are changed (in blue).
- We replace the value in the cell [1][1] with the maximum value in the column 1, that is 8.
- We replace the value in the cell [0][2] with the maximum value in the column 2, that is 9.
Example 2:

Input: matrix = [[3,-1],[5,2]]
Output: [[3,2],[5,2]]
Explanation: The diagram above shows the elements that are changed (in blue).
","class Solution:
	def modifiedMatrix(self, matrix: List[List[int]]) -> List[List[int]]:

		max_columns = []

		rows = len(matrix)

		cols = len(matrix[0])

		for j in range(cols):

			max_element = -1000

			for i in range(rows):

				max_element = max(max_element , matrix[i][j])

			max_columns.append(max_element)

		for i in range(rows):

			for j in range(cols):

				if matrix[i][j] == -1:

					matrix[i][j] = max_columns[j]

		return matrix
		
Time Complexity : O(R * C)
Space Complexity : O(C)",True
Minimum Operations to Exceed Threshold Value I,"You are given a 0-indexed integer array nums, and an integer k.
In one operation, you can remove one occurrence of the smallest element of nums.
Return the minimum number of operations needed so that all elements of the array are greater than or equal to k.
","Example 1:
Input: nums = [2,11,10,1,3], k = 10
Output: 3
Explanation: After one operation, nums becomes equal to [2, 11, 10, 3].
After two operations, nums becomes equal to [11, 10, 3].
After three operations, nums becomes equal to [11, 10].
At this stage, all the elements of nums are greater than or equal to 10 so we can stop.
It can be shown that 3 is the minimum number of operations needed so that all elements of the array are greater than or equal to 10.
Example 2:
Input: nums = [1,1,2,4,9], k = 1
Output: 0
Explanation: All elements of the array are greater than or equal to 1 so we do not need to apply any operations on nums.
Example 3:
Input: nums = [1,1,2,4,9], k = 9
Output: 4
Explanation: only a single element of nums is greater than or equal to 9 so we need to apply the operations 4 times on nums.
","class Solution:
    def minOperations(self, nums: List[int], k: int) -> int:
        return bisect_left(sorted(nums), k)",True
Minimum Operations to Exceed Threshold Value II,"You are given a 0-indexed integer array nums, and an integer k.
In one operation, you will:
Take the two smallest integers x and y in nums.
Remove x and y from nums.
Add min(x, y) * 2 + max(x, y) anywhere in the array.
Note that you can only apply the described operation if nums contains at least two elements.
Return the minimum number of operations needed so that all elements of the array are greater than or equal to k.
","Example 1:
Input: nums = [2,11,10,1,3], k = 10
Output: 2
Explanation: In the first operation, we remove elements 1 and 2, then add 1 * 2 + 2 to nums. nums becomes equal to [4, 11, 10, 3].
In the second operation, we remove elements 3 and 4, then add 3 * 2 + 4 to nums. nums becomes equal to [10, 11, 10].
At this stage, all the elements of nums are greater than or equal to 10 so we can stop.
It can be shown that 2 is the minimum number of operations needed so that all elements of the array are greater than or equal to 10.
Example 2:
Input: nums = [1,1,2,4,9], k = 20
Output: 4
Explanation: After one operation, nums becomes equal to [2, 4, 9, 3].
After two operations, nums becomes equal to [7, 4, 9].
After three operations, nums becomes equal to [15, 9].
After four operations, nums becomes equal to [33].
At this stage, all the elements of nums are greater than 20 so we can stop.
It can be shown that 4 is the minimum number of operations needed so that all elements of the array are greater than or equal to 20.
",,False
Apple Redistribution into Boxes,"You are given an array apple of size n and an array capacity of size m.
There are n packs where the ith pack contains apple[i] apples. There are m boxes as well, and the ith box has a capacity of capacity[i] apples.
Return the minimum number of boxes you need to select to redistribute these n packs of apples into boxes.
Note that, apples from the same pack can be distributed into different boxes.
","Example 1:
Input: apple = [1,3,2], capacity = [4,3,1,5,2]
Output: 2
Explanation: We will use boxes with capacities 4 and 5.
It is possible to distribute the apples as the total capacity is greater than or equal to the total number of apples.
Example 2:
Input: apple = [5,5,5], capacity = [2,4,2,7]
Output: 4
Explanation: We will need to use all the boxes.
","class Solution:
    def minimumBoxes(self, apple: List[int], capacity: List[int]) -> int:
        n = len(capacity)
        heapq.heapify(apple)
        capacity = [-c for c in capacity]
        heapq.heapify(capacity)
        s1 = s2 = 0
        while apple:
            s1 += heapq.heappop(apple)
            while s2 < s1:
                s2 -= heapq.heappop(capacity)
        return n - len(capacity)",True
Count Submatrices with Top-Left Element and Sum Less Than k,"You are given a 0-indexed integer matrix grid and an integer k.
Return the number of
submatrices
that contain the top-left element of the grid, and have a sum less than or equal to k.
","Example 1:

Input: grid = [[7,6,3],[6,6,1]], k = 18
Output: 4
Explanation: There are only 4 submatrices, shown in the image above, that contain the top-left element of grid, and have a sum less than or equal to 18.
Example 2:

Input: grid = [[7,2,9],[1,5,0],[2,6,6]], k = 20
Output: 6
Explanation: There are only 6 submatrices, shown in the image above, that contain the top-left element of grid, and have a sum less than or equal to 20.
","class Solution:
    def countSubmatrices(self, grid: List[List[int]], k: int) -> int:
        
        grid = map(accumulate, grid)
        grid = map(accumulate, zip(*grid))

        return sum(map(lambda x: x <= k, chain(*grid)))",True
Distribute Elements Into Two Arrays I,"You are given a 1-indexed array of distinct integers nums of length n.
You need to distribute all the elements of nums between two arrays arr1 and arr2 using n operations. In the first operation, append nums[1] to arr1. In the second operation, append nums[2] to arr2. Afterwards, in the ith operation:
If the last element of arr1 is greater than the last element of arr2, append nums[i] to arr1. Otherwise, append nums[i] to arr2.
The array result is formed by concatenating the arrays arr1 and arr2. For example, if arr1 == [1,2,3] and arr2 == [4,5,6], then result = [1,2,3,4,5,6].
Return the array result.
","Example 1:
Input: nums = [2,1,3]
Output: [2,3,1]
Explanation: After the first 2 operations, arr1 = [2] and arr2 = [1].
In the 3rd operation, as the last element of arr1 is greater than the last element of arr2 (2 > 1), append nums[3] to arr1.
After 3 operations, arr1 = [2,3] and arr2 = [1].
Hence, the array result formed by concatenation is [2,3,1].
Example 2:
Input: nums = [5,4,3,8]
Output: [5,3,4,8]
Explanation: After the first 2 operations, arr1 = [5] and arr2 = [4].
In the 3rd operation, as the last element of arr1 is greater than the last element of arr2 (5 > 4), append nums[3] to arr1, hence arr1 becomes [5,3].
In the 4th operation, as the last element of arr2 is greater than the last element of arr1 (4 > 3), append nums[4] to arr2, hence arr2 becomes [4,8].
After 4 operations, arr1 = [5,3] and arr2 = [4,8].
Hence, the array result formed by concatenation is [5,3,4,8].
","class Solution:
    def resultArray(self, num: List[int]) -> List[int]:
        arr1 = []
        arr2 = []
        if len(num)==0 or len(num) == 1:
            return num
        arr1.append(num[0])
        arr2.append(num[1])
        for i in num[2:]:
            if arr1[-1] > arr2[-1]:
                arr1.append(i)
            else:
                arr2.append(i)
        return arr1+arr2",True
Maximize Happiness of Selected Children,"You are given an array happiness of length n, and a positive integer k.
There are n children standing in a queue, where the ith child has happiness value happiness[i]. You want to select k children from these n children in k turns.
In each turn, when you select a child, the happiness value of all the children that have not been selected till now decreases by 1. Note that the happiness value cannot become negative and gets decremented only if it is positive.
Return the maximum sum of the happiness values of the selected children you can achieve by selecting k children.
","Example 1:
Input: happiness = [1,2,3], k = 2
Output: 4
Explanation: We can pick 2 children in the following way:
- Pick the child with the happiness value == 3. The happiness value of the remaining children becomes [0,1].
- Pick the child with the happiness value == 1. The happiness value of the remaining child becomes [0]. Note that the happiness value cannot become less than 0.
The sum of the happiness values of the selected children is 3 + 1 = 4.
Example 2:
Input: happiness = [1,1,1,1], k = 2
Output: 1
Explanation: We can pick 2 children in the following way:
- Pick any child with the happiness value == 1. The happiness value of the remaining children becomes [0,0,0].
- Pick the child with the happiness value == 0. The happiness value of the remaining child becomes [0,0].
The sum of the happiness values of the selected children is 1 + 0 = 1.
Example 3:
Input: happiness = [2,3,4,5], k = 1
Output: 5
Explanation: We can pick 1 child in the following way:
- Pick the child with the happiness value == 5. The happiness value of the remaining children becomes [1,2,3].
The sum of the happiness values of the selected children is 5.
","class Solution
{
public
    long maximumHappinessSum(int[] happiness, int k)
    {
        Arrays.sort(happiness); // Sort the happiness values in ascending order
        long totalHappiness = 0, happinessReduced = 0;
        int len = happiness.length;

        // Traverse the sorted happiness values in reverse order
        for (int i = len - 1; k > 0; i--, k--)
        {
            // If reducing the happiness value by the current track value makes it non-positive, return the total happiness
            if (happiness[i] - happinessReduced <= 0)
                return totalHappiness;
            totalHappiness += happiness[i] - happinessReduced; // Add the current maximum happiness value to the total
            happinessReduced++;                                // Increment the track value
        }

        return totalHappiness; // Return the total maximum happiness sum
    }
}",False
Minimum Levels to Gain More Points,"You are given a binary array possible of length n.
Alice and Bob are playing a game that consists of n levels. Some of the levels in the game are impossible to clear while others can always be cleared. In particular, if possible[i] == 0, then the ith level is impossible to clear for both the players. A player gains 1 point on clearing a level and loses 1 point if the player fails to clear it.
At the start of the game, Alice will play some levels in the given order starting from the 0th level, after which Bob will play for the rest of the levels.
Alice wants to know the minimum number of levels she should play to gain more points than Bob, if both players play optimally to maximize their points.
Return the minimum number of levels Alice should play to gain more points. If this is not possible, return -1.
Note that each player must play at least 1 level.
","Example 1:
Input: possible = [1,0,1,0]
Output: 1
Explanation:
Let's look at all the levels that Alice can play up to:
If Alice plays only level 0 and Bob plays the rest of the levels, Alice has 1 point, while Bob has -1 + 1 - 1 = -1 point.
If Alice plays till level 1 and Bob plays the rest of the levels, Alice has 1 - 1 = 0 points, while Bob has 1 - 1 = 0 points.
If Alice plays till level 2 and Bob plays the rest of the levels, Alice has 1 - 1 + 1 = 1 point, while Bob has -1 point.
Alice must play a minimum of 1 level to gain more points.
Example 2:
Input: possible = [1,1,1,1,1]
Output: 3
Explanation:
Let's look at all the levels that Alice can play up to:
If Alice plays only level 0 and Bob plays the rest of the levels, Alice has 1 point, while Bob has 4 points.
If Alice plays till level 1 and Bob plays the rest of the levels, Alice has 2 points, while Bob has 3 points.
If Alice plays till level 2 and Bob plays the rest of the levels, Alice has 3 points, while Bob has 2 points.
If Alice plays till level 3 and Bob plays the rest of the levels, Alice has 4 points, while Bob has 1 point.
Alice must play a minimum of 3 levels to gain more points.
Example 3:
Input: possible = [0,0]
Output: -1
Explanation:
The only possible way is for both players to play 1 level each. Alice plays level 0 and loses 1 point. Bob plays level 1 and loses 1 point. As both players have equal points, Alice can't gain more points than Bob.
","class Solution:
    def minimumLevels(self, possible: List[int]) -> int:
        ans=0
        left=[0]*(len(possible))
        right=[0]*(len(possible))
        acc=0
        for i in range(len(possible)):
            if possible[i]==1:
                acc+=possible[i]
            else:acc-=1
            left[i]=acc
        acc=0
        for i in range(len(possible)-1,-1,-1):
            if possible[i]==1:
                acc+=possible[i]
            else:acc-=1
            right[i]=acc
        f=0   
        for i in range(0,len(possible)-1):
            if left[i]-right[i+1]>0:
                return i+1
        

        return -1 
        
                  
        ",True
Shortest Uncommon Substring in an Array,"You are given an array arr of size n consisting of non-empty strings.
Find a string array answer of size n such that:
answer[i] is the shortest
substring
of arr[i] that does not occur as a substring in any other string in arr. If multiple such substrings exist, answer[i] should be the
lexicographically smallest
. And if no such substring exists, answer[i] should be an empty string.
Return the array answer.
","Example 1:
Input: arr = [""cab"",""ad"",""bad"",""c""]
Output: [""ab"","""",""ba"",""""]
Explanation: We have the following:
- For the string ""cab"", the shortest substring that does not occur in any other string is either ""ca"" or ""ab"", we choose the lexicographically smaller substring, which is ""ab"".
- For the string ""ad"", there is no substring that does not occur in any other string.
- For the string ""bad"", the shortest substring that does not occur in any other string is ""ba"".
- For the string ""c"", there is no substring that does not occur in any other string.
Example 2:
Input: arr = [""abc"",""bcd"",""abcd""]
Output: ["""","""",""abcd""]
Explanation: We have the following:
- For the string ""abc"", there is no substring that does not occur in any other string.
- For the string ""bcd"", there is no substring that does not occur in any other string.
- For the string ""abcd"", the shortest substring that does not occur in any other string is ""abcd"".
","class Solution:
    def shortestSubstrings(self, arr: List[str]) -> List[str]:
        res = ['']*len(arr)
        
        for index,s in enumerate(arr):
            substrings=sorted([s[i: j] for i in range(len(s)) for j in range(i + 1, len(s) + 1)],key=len)
            for i1,s1 in enumerate(arr):
                if index!=i1:
                    for k in range(len(substrings)):
                        if substrings[k] in s1:
                            substrings[k]=''
                            
            for l in substrings:
                if l!='' and res[index]=='':
                    res[index] = l
                    
                if res[index]!='' and len(res[index])==len(l) and l<res[index]:
                    res[index]=l
                        

        return res
                        
            

                ",True
Most Frequent IDs,"The problem involves tracking the frequency of IDs in a collection that changes over time. You have two integer arrays, nums and freq, of equal length n. Each element in nums represents an ID, and the corresponding element in freq indicates how many times that ID should be added to or removed from the collection at each step.
Addition of IDs: If freq[i] is positive, it means freq[i] IDs with the value nums[i] are added to the collection at step i.
Removal of IDs: If freq[i] is negative, it means -freq[i] IDs with the value nums[i] are removed from the collection at step i.
Return an array ans of length n, where ans[i] represents the count of the most frequent ID in the collection after the ith step. If the collection is empty at any step, ans[i] should be 0 for that step.
","Example 1:
Input: nums = [2,3,2,1], freq = [3,2,-3,1]
Output: [3,3,2,2]
Explanation:
After step 0, we have 3 IDs with the value of 2. So ans[0] = 3.
After step 1, we have 3 IDs with the value of 2 and 2 IDs with the value of 3. So ans[1] = 3.
After step 2, we have 2 IDs with the value of 3. So ans[2] = 2.
After step 3, we have 2 IDs with the value of 3 and 1 ID with the value of 1. So ans[3] = 2.
Example 2:
Input: nums = [5,5,3], freq = [2,-2,1]
Output: [2,0,1]
Explanation:
After step 0, we have 2 IDs with the value of 5. So ans[0] = 2.
After step 1, there are no IDs. So ans[1] = 0.
After step 2, we have 1 ID with the value of 3. So ans[2] = 1.
",,False
Find the Sum of Encrypted Integers,"You are given an integer array nums containing positive integers. We define a function encrypt such that encrypt(x) replaces every digit in x with the largest digit in x. For example, encrypt(523) = 555 and encrypt(213) = 333.
Return the sum of encrypted elements.
","Example 1:
Input: nums = [1,2,3]
Output: 6
Explanation: The encrypted elements are [1,2,3]. The sum of encrypted elements is 1 + 2 + 3 == 6.
Example 2:
Input: nums = [10,21,31]
Output: 66
Explanation: The encrypted elements are [11,22,33]. The sum of encrypted elements is 11 + 22 + 33 == 66.
","class Solution:
    def sumOfEncryptedInt(self, nums: List[int]) -> int:
        sum1=0
        for i in nums:
            if i>=10:
                i=str(i)
                i=list(i)
                d=max(i)
                c=d*len(i)
                sum1+=int(c)
            else:
                sum1+=i
        return sum1",True
Longest Strictly Increasing or Strictly Decreasing Subarray,"You are given an array of integers nums. Return the length of the longest
subarray
of nums which is either
strictly increasing
or
strictly decreasing
.
","Example 1:
Input: nums = [1,4,3,3,2]
Output: 2
Explanation:
The strictly increasing subarrays of nums are [1], [2], [3], [3], [4], and [1,4].
The strictly decreasing subarrays of nums are [1], [2], [3], [3], [4], [3,2], and [4,3].
Hence, we return 2.
Example 2:
Input: nums = [3,3,3,3]
Output: 1
Explanation:
The strictly increasing subarrays of nums are [3], [3], [3], and [3].
The strictly decreasing subarrays of nums are [3], [3], [3], and [3].
Hence, we return 1.
Example 3:
Input: nums = [3,2,1]
Output: 3
Explanation:
The strictly increasing subarrays of nums are [3], [2], and [1].
The strictly decreasing subarrays of nums are [3], [2], [1], [3,2], [2,1], and [3,2,1].
Hence, we return 3.
","class Solution {
    public int longestMonotonicSubarray(int[] nums) {
        int maxLength = 1;
        int incLength = 1;
        int decLength = 1;
        for(int i = 1; i < nums.length; i++) {
            if(nums[i] > nums[i - 1]) {
                incLength++;
                decLength = 1;
            } else if(nums[i] < nums[i - 1]) {
                decLength++;
                incLength = 1;
            } else {
                incLength = 1;
                decLength = 1;
            }
            maxLength = Math.max(maxLength, Math.max(incLength, decLength));
        }
        return maxLength;
    }
}",False
Maximum Prime Difference,"You are given an integer array nums.
Return an integer that is the maximum distance between the indices of two (not necessarily different) prime numbers in nums.
","Example 1:
Input: nums = [4,2,9,5,3]
Output: 3
Explanation: nums[1], nums[3], and nums[4] are prime. So the answer is |4 - 1| = 3.
Example 2:
Input: nums = [4,8,2,8]
Output: 0
Explanation: nums[2] is prime. Because there is just one prime number, the answer is |2 - 2| = 0.
","class Solution:
    
    def is_prime(self, num: int) -> bool:
        if num < 2:
            return False
        for i in range(2, int(num**0.5)+1):
            if(num%i == 0):
                return False
        return True
    
    def maximumPrimeDifference(self, nums: List[int]) -> int:
        prime = []
        for i, num in enumerate(nums):
            if self.is_prime(num):
                prime.append(i)
        
        if len(prime) < 2:
            return 0
        return prime[-1]-prime[0]",True
Count Alternating Subarrays,"You are given a
binary array
nums.
We call a
subarray
alternating if no two adjacent elements in the subarray have the same value.
Return the number of alternating subarrays in nums.
","Example 1:
Input: nums = [0,1,1,1]
Output: 5
Explanation:
The following subarrays are alternating: [0], [1], [1], [1], and [0,1].
Example 2:
Input: nums = [1,0,1,0]
Output: 10
Explanation:
Every subarray of the array is alternating. There are 10 possible subarrays that we can choose.
","class Solution:
    def countAlternatingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [1] * n
        
        for i in range(1, n):
            if nums[i-1] != nums[i]:
                dp[i] = dp[i - 1] + 1
        
        return sum(dp)",True
Shortest Subarray With OR at Least K I,"You are given an array nums of non-negative integers and an integer k.
An array is called special if the bitwise OR of all of its elements is at least k.
Return the length of the shortest special non-empty
subarray
of nums, or return -1 if no special subarray exists.
","Example 1:
Input: nums = [1,2,3], k = 2
Output: 1
Explanation:
The subarray [3] has OR value of 3. Hence, we return 1.
Example 2:
Input: nums = [2,1,8], k = 10
Output: 3
Explanation:
The subarray [2,1,8] has OR value of 11. Hence, we return 3.
Example 3:
Input: nums = [1,2], k = 0
Output: 1
Explanation:
The subarray [1] has OR value of 1. Hence, we return 1.
","class Solution:
    def minimumSubarrayLength(self, nums: List[int], k: int) -> int:

        acc = nums

        for i in range(1,len(nums)+1):

            if max(acc) >= k: return i
            acc = [x|y for x,y in zip(acc, nums[i:])]
 
        return -1 ",True
Taking Maximum Energy From the Mystic Dungeon,"In a mystic dungeon, n magicians are standing in a line. Each magician has an attribute that gives you energy. Some magicians can give you negative energy, which means taking energy from you.
You have been cursed in such a way that after absorbing energy from magician i, you will be instantly transported to magician (i + k). This process will be repeated until you reach the magician where (i + k) does not exist.
In other words, you will choose a starting point and then teleport with k jumps until you reach the end of the magicians' sequence, absorbing all the energy during the journey.
You are given an array energy and an integer k. Return the maximum possible energy you can gain.
","Example 1:
Input: energy = [5,2,-10,-5,1], k = 3
Output: 3
Explanation: We can gain a total energy of 3 by starting from magician 1 absorbing 2 + 1 = 3.
Example 2:
Input: energy = [-2,-3,-1], k = 2
Output: -1
Explanation: We can gain a total energy of -1 by starting from magician 2.
",,False
Minimum Operations to Make Median of Array Equal to K,"You are given an integer array nums and a non-negative integer k. In one operation, you can increase or decrease any element by 1.
Return the minimum number of operations needed to make the median of nums equal to k.
The median of an array is defined as the middle element of the array when it is sorted in non-decreasing order. If there are two choices for a median, the larger of the two values is taken.
","Example 1:
Input: nums = [2,5,6,8,5], k = 4
Output: 2
Explanation:
We can subtract one from nums[1] and nums[4] to obtain [2, 4, 6, 8, 4]. The median of the resulting array is equal to k.
Example 2:
Input: nums = [2,5,6,8,5], k = 7
Output: 3
Explanation:
We can add one to nums[1] twice and add one to nums[2] once to obtain [2, 7, 7, 8, 5].
Example 3:
Input: nums = [1,2,3,4,5,6], k = 4
Output: 0
Explanation:
The median of the array is already equal to k.
","class Solution:
    def minOperationsToMakeMedianK(self, nums: List[int], k: int) -> int:
        nums.sort()
        n = len(nums)
        median = nums[n//2]
        count = 0
        if median == k:
            return 0
        elif median > k:
            i = 0
            diff = median - k
            while i <= n//2:
                if nums[i]+diff > median:
                    count += abs(nums[i]-k)
                i += 1
        else:
            i = n-1
            diff = k - median
            while i >= n//2:
                if nums[i]-diff < median:
                    count += abs(nums[i]-k)
                i -= 1
        return count",True
Right Triangles,"You are given a 2D boolean matrix grid.
Return an integer that is the number of right triangles that can be made with the 3 elements of grid such that all of them have a value of 1.
Note:
A collection of 3 elements of grid is a right triangle if one of its elements is in the same row with another element and in the same column with the third element. The 3 elements do not have to be next to each other.
","Example 1:
0 1 0
0 1 1
0 1 0
0 1 0
0 1 1
0 1 0
Input: grid = [[0,1,0],[0,1,1],[0,1,0]]
Output: 2
Explanation:
There are two right triangles.
Example 2:
1 0 0 0
0 1 0 1
1 0 0 0
Input: grid = [[1,0,0,0],[0,1,0,1],[1,0,0,0]]
Output: 0
Explanation:
There are no right triangles.
Example 3:
1 0 1
1 0 0
1 0 0
1 0 1
1 0 0
1 0 0
Input: grid = [[1,0,1],[1,0,0],[1,0,0]]
Output: 2
Explanation:
There are two right triangles.
","class Solution:
    def numberOfRightTriangles(self, grid: List[List[int]]) -> int:
        totalTriangles = 0
        rows, cols = len(grid), len(grid[0])
        prefixColSum, prefixRowSum = [0] * cols, [0] * rows
        postfixColSum, postfixRowSum = [0] * cols, [0] * rows

        for index, row in enumerate(grid):
            postfixRowSum[index] = sum(row)

        for col in range(cols):
            currSum = 0
            for row in range(rows):
                currSum += grid[row][col]
            postfixColSum[col] = currSum
        
        for row in range(rows):
            for col in range(cols):
                if grid[row][col] == 1:
                    postfixRowSum[row] -= 1
                    postfixColSum[col] -= 1

                    totalTriangles += \
                        prefixRowSum[row] * prefixColSum[col]  +\
                        prefixRowSum[row] * postfixColSum[col] +\
                        postfixRowSum[row] * prefixColSum[col] +\
                        postfixRowSum[row] * postfixColSum[col]

                    prefixRowSum[row] += 1
                    prefixColSum[col] += 1
        
        return totalTriangles",True
Minimum Time to Visit Disappearing Nodes,"There is an undirected graph of n nodes. You are given a 2D array edges, where edges[i] = [ui, vi, lengthi] describes an edge between node ui and node vi with a traversal time of lengthi units.
Additionally, you are given an array disappear, where disappear[i] denotes the time when the node i disappears from the graph and you won't be able to visit it.
Notice that the graph might be disconnected and might contain multiple edges.
Return the array answer, with answer[i] denoting the minimum units of time required to reach node i from node 0. If node i is unreachable from node 0 then answer[i] is -1.
","Example 1:

Input: n = 3, edges = [[0,1,2],[1,2,1],[0,2,4]], disappear = [1,1,5]
Output: [0,-1,4]
Explanation:
We are starting our journey from node 0, and our goal is to find the minimum time required to reach each node before it disappears.
For node 0, we don't need any time as it is our starting point.
For node 1, we need at least 2 units of time to traverse edges[0]. Unfortunately, it disappears at that moment, so we won't be able to visit it.
For node 2, we need at least 4 units of time to traverse edges[2].
Example 2:

Input: n = 3, edges = [[0,1,2],[1,2,1],[0,2,4]], disappear = [1,3,5]
Output: [0,2,3]
Explanation:
We are starting our journey from node 0, and our goal is to find the minimum time required to reach each node before it disappears.
For node 0, we don't need any time as it is the starting point.
For node 1, we need at least 2 units of time to traverse edges[0].
For node 2, we need at least 3 units of time to traverse edges[0] and edges[1].
Example 3:
Input: n = 2, edges = [[0,1,1]], disappear = [1,1]
Output: [0,-1]
Explanation:
Exactly when we reach node 1, it disappears.
","class Solution:
    def buildAdjList(self, totalNodes, edges):
        adjList = [{} for _ in range(totalNodes)]

        for fromNode, toNode, dist in edges:
            # print(fromNode, toNode, dist)
            newDist = dist
            if toNode in adjList[fromNode]:
                newDist = min(adjList[fromNode][toNode], dist)
            adjList[fromNode][toNode] = newDist
            adjList[toNode][fromNode] = newDist
        
        return adjList
            
    def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:
        adjList = self.buildAdjList(n, edges)
        # print(adjList)
        
        pq = [[0, 0]] # [edge, steps]
        visited = set()

        result = [inf] * n
        
        while pq:
            steps, node = heapq.heappop(pq)
            
            if node in visited or steps > disappear[node]:
                continue
            
            result[node] = min(steps, result[node])
            

            visited.update((node,))
            for adjNode, dist in adjList[node].items():
                newSteps = steps + dist
                if adjNode in visited or newSteps >= disappear[adjNode]:
                    continue
                heapq.heappush(pq, [newSteps, adjNode])
            
        for i in range(n):
            if result[i] == inf:
                result[i] = -1
        return result",True
Minimum Rectangles to Cover Points,"You are given a 2D integer array points, where points[i] = [xi, yi]. You are also given an integer w. Your task is to cover all the given points with rectangles.
Each rectangle has its lower end at some point (x1, 0) and its upper end at some point (x2, y2), where x1 <= x2, y2 >= 0, and the condition x2 - x1 <= w must be satisfied for each rectangle.
A point is considered covered by a rectangle if it lies within or on the boundary of the rectangle.
Return an integer denoting the minimum number of rectangles needed so that each point is covered by at least one rectangle.
Note: A point may be covered by more than one rectangle.
","Example 1:

Input: points = [[2,1],[1,0],[1,4],[1,8],[3,5],[4,6]], w = 1
Output: 2
Explanation:
The image above shows one possible placement of rectangles to cover the points:
A rectangle with a lower end at (1, 0) and its upper end at (2, 8)
A rectangle with a lower end at (3, 0) and its upper end at (4, 8)
Example 2:

Input: points = [[0,0],[1,1],[2,2],[3,3],[4,4],[5,5],[6,6]], w = 2
Output: 3
Explanation:
The image above shows one possible placement of rectangles to cover the points:
A rectangle with a lower end at (0, 0) and its upper end at (2, 2)
A rectangle with a lower end at (3, 0) and its upper end at (5, 5)
A rectangle with a lower end at (6, 0) and its upper end at (6, 6)
Example 3:

Input: points = [[2,3],[1,2]], w = 0
Output: 2
Explanation:
The image above shows one possible placement of rectangles to cover the points:
A rectangle with a lower end at (1, 0) and its upper end at (1, 2)
A rectangle with a lower end at (2, 0) and its upper end at (2, 3)
",,False
Maximum Difference Score in a Grid,"You are given an m x n matrix grid consisting of positive integers. You can move from a cell in the matrix to any other cell that is either to the bottom or to the right (not necessarily adjacent). The score of a move from a cell with the value c1 to a cell with the value c2 is c2 - c1.
You can start at any cell, and you have to make at least one move.
Return the maximum total score you can achieve.
","Example 1:

Input: grid = [[9,5,7,3],[8,9,6,1],[6,7,14,3],[2,5,3,1]]
Output: 9
Explanation: We start at the cell (0, 1), and we perform the following moves:
- Move from the cell (0, 1) to (2, 1) with a score of 7 - 5 = 2.
- Move from the cell (2, 1) to (2, 2) with a score of 14 - 7 = 7.
The total score is 2 + 7 = 9.
Example 2:

Input: grid = [[4,3,2],[3,2,1]]
Output: -1
Explanation: We start at the cell (0, 0), and we perform one move: (0, 0) to (0, 1). The score is 3 - 4 = -1.
",,False
Find the Integer Added to Array I,"You are given two arrays of equal length, nums1 and nums2.
Each element in nums1 has been increased (or decreased in the case of negative) by an integer, represented by the variable x.
As a result, nums1 becomes equal to nums2. Two arrays are considered equal when they contain the same integers with the same frequencies.
Return the integer x.
","Example 1:
Input: nums1 = [2,6,4], nums2 = [9,7,5]
Output: 3
Explanation:
The integer added to each element of nums1 is 3.
Example 2:
Input: nums1 = [10], nums2 = [5]
Output: -5
Explanation:
The integer added to each element of nums1 is -5.
Example 3:
Input: nums1 = [1,1,1,1], nums2 = [1,1,1,1]
Output: 0
Explanation:
The integer added to each element of nums1 is 0.
","class Solution:
    def addedInteger(self, nums1: List[int], nums2: List[int]) -> int:
        nums1.sort()
        nums2.sort()
        return nums2[0] - nums1[0]",True
Make a Square with the Same Color,"You are given a 2D matrix grid of size 3 x 3 consisting only of characters 'B' and 'W'. Character 'W' represents the white color, and character 'B' represents the black color.
Your task is to change the color of at most one cell so that the matrix has a 2 x 2 square where all cells are of the same color.
Return true if it is possible to create a 2 x 2 square of the same color, otherwise, return false.
","

Example 1:
                 
Input: grid = [[""B"",""W"",""B""],[""B"",""W"",""W""],[""B"",""W"",""B""]]
Output: true
Explanation:
It can be done by changing the color of the grid[0][2].
Example 2:
                 
Input: grid = [[""B"",""W"",""B""],[""W"",""B"",""W""],[""B"",""W"",""B""]]
Output: false
Explanation:
It cannot be done by changing at most one cell.
Example 3:
                 
Input: grid = [[""B"",""W"",""B""],[""B"",""W"",""W""],[""B"",""W"",""W""]]
Output: true
Explanation:
The grid already contains a 2 x 2 square of the same color.
","class Solution:
    def canMakeSquare(self, grid: List[List[str]]) -> bool:
        for i in range(2):
            for j in range(2):
                submatrix = (
                    grid[i][j],
                    grid[i + 1][j],
                    grid[i][j + 1],
                    grid[i + 1][j + 1],
                )
                if sum([cell == ""B"" for cell in submatrix]) != 2:
                    return True

        return False
",True
Find the Integer Added to Array II,"You are given two integer arrays nums1 and nums2.
From nums1 two elements have been removed, and all other elements have been increased (or decreased in the case of negative) by an integer, represented by the variable x.
As a result, nums1 becomes equal to nums2. Two arrays are considered equal when they contain the same integers with the same frequencies.
Return the minimum possible integer x that achieves this equivalence.
","Example 1:
Input: nums1 = [4,20,16,12,8], nums2 = [14,18,10]
Output: -2
Explanation:
After removing elements at indices [0,4] and adding -2, nums1 becomes [18,14,10].
Example 2:
Input: nums1 = [3,5,5,3], nums2 = [7,7]
Output: 2
Explanation:
After removing elements at indices [0,3] and adding 2, nums1 becomes [7,7].
","class Solution:
    def minimumAddedInteger(self, nums1: List[int], nums2: List[int]) -> int:
        min2 = min(nums2)
        c, b, a = [min2 - val for val in heapq.nsmallest(3, nums1)]
        nums2 = Counter(nums2)
        for x in (a, b, c):
            if nums2 <= Counter(val + x for val in nums1):
                return x",True
Check if Grid Satisfies Conditions,"You are given a 2D matrix grid of size m x n. You need to check if each cell grid[i][j] is:
Equal to the cell below it, i.e. grid[i][j] == grid[i + 1][j] (if it exists).
Different from the cell to its right, i.e. grid[i][j] != grid[i][j + 1] (if it exists).
Return true if all the cells satisfy these conditions, otherwise, return false.
","Example 1:
Input: grid = [[1,0,2],[1,0,2]]
Output: true
Explanation:
All the cells in the grid satisfy the conditions.
Example 2:
Input: grid = [[1,1,1],[0,0,0]]
Output: false
Explanation:
All cells in the first row are equal.
Example 3:
Input: grid = [[1],[2],[3]]
Output: false
Explanation:
Cells in the first column have different values.
","class Solution:
    def satisfiesConditions(self, grid: List[List[int]]) -> bool:
        m = len(grid)
        n = len(grid[0])

        for y in range(m - 1):
            if grid[y][0] != grid[y + 1][0]:
                return False

            for x in range(n - 1):
                if grid[y][x] == grid[y][x + 1]:
                    return False

        
        y = m - 1
        for x in range(n - 1):
            if grid[y][x] == grid[y][x + 1]:
                return False
        return True
",True
Sum of Digit Differences of All Pairs,"You are given an array nums consisting of positive integers where all integers have the same number of digits.
The digit difference between two integers is the count of different digits that are in the same position in the two integers.
Return the sum of the digit differences between all pairs of integers in nums.
","Example 1:
Input: nums = [13,23,12]
Output: 4
Explanation:
We have the following:
- The digit difference between 13 and 23 is 1.
- The digit difference between 13 and 12 is 1.
- The digit difference between 23 and 12 is 2.
So the total sum of digit differences between all pairs of integers is 1 + 1 + 2 = 4.
Example 2:
Input: nums = [10,10,10,10]
Output: 0
Explanation:
All the integers in the array are the same. So the total sum of digit differences between all pairs of integers will be 0.
",,False
Maximum Points Inside the Square,"You are given a 2D array points and a string s where, points[i] represents the coordinates of point i, and s[i] represents the tag of point i.
A valid square is a square centered at the origin (0, 0), has edges parallel to the axes, and does not contain two points with the same tag.
Return the maximum number of points contained in a valid square.
Note:
A point is considered to be inside the square if it lies on or within the square's boundaries.
The side length of the square can be zero.
","Example 1:

Input: points = [[2,2],[-1,-2],[-4,4],[-3,1],[3,-3]], s = ""abdca""
Output: 2
Explanation:
The square of side length 4 covers two points points[0] and points[1].
Example 2:

Input: points = [[1,1],[-2,-2],[-2,2]], s = ""abb""
Output: 1
Explanation:
The square of side length 2 covers one point, which is points[0].
Example 3:
Input: points = [[1,1],[-1,-1],[2,-2]], s = ""ccd""
Output: 0
Explanation:
It's impossible to make any valid squares centered at the origin such that it covers only one point among points[0] and points[1].
","class Solution:
    def maxPointsInsideSquare(self, points: List[List[int]], s: str) -> int:
        d = {}
        for i in range(len(points)):
            x = [abs(x) for x in points[i]]
            x = max(x)
            y = s[i]
            if x in d:
                d[x] = d[x] + y
            else:
                d[x] = y
        d = dict(sorted(d.items()))
        result = 0
        string = """"
        for i in d:
            for y in d[i]:
                if y not in string:
                    string += y
                else:
                    return result
            result += len(d[i])
        return result

            


            


        
        ",True
Find Occurrences of an Element in an Array,"You are given an integer array nums, an integer array queries, and an integer x.
For each queries[i], you need to find the index of the queries[i]th occurrence of x in the nums array. If there are fewer than queries[i] occurrences of x, the answer should be -1 for that query.
Return an integer array answer containing the answers to all queries.
","Example 1:
Input: nums = [1,3,1,7], queries = [1,3,2,4], x = 1
Output: [0,-1,2,-1]
Explanation:
For the 1st query, the first occurrence of 1 is at index 0.
For the 2nd query, there are only two occurrences of 1 in nums, so the answer is -1.
For the 3rd query, the second occurrence of 1 is at index 2.
For the 4th query, there are only two occurrences of 1 in nums, so the answer is -1.
Example 2:
Input: nums = [1,2,3], queries = [10], x = 5
Output: [-1]
Explanation:
For the 1st query, 5 doesn't exist in nums, so the answer is -1.
",,False
Special Array II,"An array is considered special if every pair of its adjacent elements contains two numbers with different parity.
You are given an array of integer nums and a 2D integer matrix queries, where for queries[i] = [fromi, toi] your task is to check that
subarray
nums[fromi..toi] is special or not.
Return an array of booleans answer such that answer[i] is true if nums[fromi..toi] is special.
","Example 1:
Input: nums = [3,4,1,2,6], queries = [[0,4]]
Output: [false]
Explanation:
The subarray is [3,4,1,2,6]. 2 and 6 are both even.
Example 2:
Input: nums = [4,3,1,6], queries = [[0,2],[2,3]]
Output: [false,true]
Explanation:
The subarray is [4,3,1]. 3 and 1 are both odd. So the answer to this query is false.
The subarray is [1,6]. There is only one pair: (1,6) and it contains numbers with different parity. So the answer to this query is true.
","class Solution:
    def isArraySpecial(self, nums: List[int], queries: List[List[int]]) -> List[bool]:
        n = len(nums)
    
        if n == 1:
            return [True] * len(queries)  # Single element arrays are always special

        # Step 1: Create the special array
        special = [0] * (n - 1)
        for i in range(n - 1):
            if nums[i] % 2 == nums[i + 1] % 2:
                special[i] = 1

        # Step 2: Create the prefix_special array
        prefix_special = [0] * n
        for i in range(1, n):
            prefix_special[i] = prefix_special[i - 1] + special[i - 1]

        # Step 3: Evaluate each query using the prefix_special array
        result = []
        for fromi, toi in queries:
            if prefix_special[toi] - prefix_special[fromi] > 0:
                result.append(False)
            else:
                result.append(True)

        return result
    ",True
Special Array I,"An array is considered special if every pair of its adjacent elements contains two numbers with different parity.
You are given an array of integers nums. Return true if nums is a special array, otherwise, return false.
","Example 1:
Input: nums = [1]
Output: true
Explanation:
There is only one element. So the answer is true.
Example 2:
Input: nums = [2,1,4]
Output: true
Explanation:
There is only two pairs: (2,1) and (1,4), and both of them contain numbers with different parity. So the answer is true.
Example 3:
Input: nums = [4,3,1,6]
Output: false
Explanation:
nums[1] and nums[2] are both odd. So the answer is false.
",,False
Find the Number of Distinct Colors Among the Balls,"You are given an integer limit and a 2D array queries of size n x 2.
There are limit + 1 balls with distinct labels in the range [0, limit]. Initially, all balls are uncolored. For every query in queries that is of the form [x, y], you mark ball x with the color y. After each query, you need to find the number of distinct colors among the balls.
Return an array result of length n, where result[i] denotes the number of distinct colors after ith query.
Note that when answering a query, lack of a color will not be considered as a color.
","Example 1:
Input: limit = 4, queries = [[1,4],[2,5],[1,3],[3,4]]
Output: [1,2,2,3]
Explanation:
After query 0, ball 1 has color 4.
After query 1, ball 1 has color 4, and ball 2 has color 5.
After query 2, ball 1 has color 3, and ball 2 has color 5.
After query 3, ball 1 has color 3, ball 2 has color 5, and ball 3 has color 4.
Example 2:
Input: limit = 4, queries = [[0,1],[1,2],[2,2],[3,4],[4,5]]
Output: [1,2,2,3,4]
Explanation:
After query 0, ball 0 has color 1.
After query 1, ball 0 has color 1, and ball 1 has color 2.
After query 2, ball 0 has color 1, and balls 1 and 2 have color 2.
After query 3, ball 0 has color 1, balls 1 and 2 have color 2, and ball 3 has color 4.
After query 4, ball 0 has color 1, balls 1 and 2 have color 2, ball 3 has color 4, and ball 4 has color 5.
",,False
Find the Number of Good Pairs II,"You are given 2 integer arrays nums1 and nums2 of lengths n and m respectively. You are also given a positive integer k.
A pair (i, j) is called good if nums1[i] is divisible by nums2[j] * k (0 <= i <= n - 1, 0 <= j <= m - 1).
Return the total number of good pairs.
","Example 1:
Input: nums1 = [1,3,4], nums2 = [1,3,4], k = 1
Output: 5
Explanation:
The 5 good pairs are (0, 0), (1, 0), (1, 1), (2, 0), and (2, 2).
Example 2:
Input: nums1 = [1,2,4,12], nums2 = [2,4], k = 3
Output: 2
Explanation:
The 2 good pairs are (3, 0) and (3, 1).
","class Solution {
public:
    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int k) {
        unordered_map<int, int> map;
        for(auto& num : nums2)
            map[num * k]++;
        
        long long ans = 0;
        for(auto& num : nums1){
            vector<int> help;
            int b = num;
            for(int i = 1; i * i <= b; i++){
                if(b % i == 0){
                    ans += map[i];
                    if(i * i != b)
                        ans += map[b / i];
                }
            }
        }
        return ans;
    }
};",False
Find the Number of Good Pairs I,"You are given 2 integer arrays nums1 and nums2 of lengths n and m respectively. You are also given a positive integer k.
A pair (i, j) is called good if nums1[i] is divisible by nums2[j] * k (0 <= i <= n - 1, 0 <= j <= m - 1).
Return the total number of good pairs.
","Example 1:
Input: nums1 = [1,3,4], nums2 = [1,3,4], k = 1
Output: 5
Explanation:
The 5 good pairs are (0, 0), (1, 0), (1, 1), (2, 0), and (2, 2).
Example 2:
Input: nums1 = [1,2,4,12], nums2 = [2,4], k = 3
Output: 2
Explanation:
The 2 good pairs are (3, 0) and (3, 1).
","class Solution {
public:
    int numberOfPairs(vector<int>& nums1, vector<int>& nums2, int k) {
        int n = nums1.size(),m = nums2.size(), cnt=0;
        for (int i=0; i<n; ++i) {
            for (int j=0; j<m; ++j) {
                int x=nums2[j]*k;
                if(nums1[i]%x == 0) cnt++;
            }
        }
        return cnt;
    }
};",False
