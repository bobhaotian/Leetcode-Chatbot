Title,Question,Examples,Solution,Python
Two Sum,"Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
You can return the answer in any order.
","Example 1:
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
Example 2:
Input: nums = [3,2,4], target = 6
Output: [1,2]
Example 3:
Input: nums = [3,3], target = 6
Output: [0,1]
","class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        dict={}
        for i,n in enumerate(nums):
            if n in dict:
                return dict[n],i
            else:
                dict[target-n]=i
    #please upvote me it would encourage me alot
",True
Container With Most Water,"You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).
Find two lines that together with the x-axis form a container, such that the container contains the most water.
Return the maximum amount of water a container can store.
Notice that you may not slant the container.
","Example 1:

Input: height = [1,8,6,2,5,4,8,3,7]
Output: 49
Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.
Example 2:
Input: height = [1,1]
Output: 1
","class Solution:
    def maxArea(self, height: List[int]) -> int:
        max_area = 0
        left = 0
        right = len(height) - 1

        while left < right:
            max_area = max(max_area, (right - left) * min(height[left], height[right]))

            if height[left] < height[right]:
                left += 1
            else:
                right -= 1
        
        return max_area",True
3Sum,"Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.
Notice that the solution set must not contain duplicate triplets.
","Example 1:
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
Explanation: 
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
The distinct triplets are [-1,0,1] and [-1,-1,2].
Notice that the order of the output and the order of the triplets does not matter.
Example 2:
Input: nums = [0,1,1]
Output: []
Explanation: The only possible triplet does not sum up to 0.
Example 3:
Input: nums = [0,0,0]
Output: [[0,0,0]]
Explanation: The only possible triplet sums up to 0.
","class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        Arrays.sort(nums);

        for (int i = 0; i < nums.length; i++) {
            if (i > 0 && nums[i] == nums[i-1]) {
                continue;
            }
            
            int j = i + 1;
            int k = nums.length - 1;

            while (j < k) {
                int total = nums[i] + nums[j] + nums[k];

                if (total > 0) {
                    k--;
                } else if (total < 0) {
                    j++;
                } else {
                    res.add(Arrays.asList(nums[i], nums[j], nums[k]));
                    j++;

                    while (nums[j] == nums[j-1] && j < k) {
                        j++;
                    }
                }
            }
        }
        return res;        
    }
}",False
3Sum Closest,"Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.
Return the sum of the three integers.
You may assume that each input would have exactly one solution.
","Example 1:
Input: nums = [-1,2,1,-4], target = 1
Output: 2
Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
Example 2:
Input: nums = [0,0,0], target = 1
Output: 0
Explanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0).
","class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        sort(nums.begin(),nums.end());
        int diff = INT_MAX;
        int ans = 0;
        for(int i=0;i<nums.size();i++)
        {
            int first = nums[i];  //first element
            int start = i+1;
            int end  = nums.size()-1;
            while(start < end){
                if(first + nums[start] + nums[end] == target) return target;
                else if(abs(first + nums[start]+nums[end] - target) < diff)
                {
                    diff = abs(first + nums[start]+nums[end] - target);
                    ans = first + nums[start]+nums[end];
                }
                
                if(first + nums[start] + nums[end] > target)
                {
                    end--;
                }
                else{
                    start++;
                }
            }
        }
        return ans;
    }
};",False
4Sum,"Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:
0 <= a, b, c, d < n
a, b, c, and d are distinct.
nums[a] + nums[b] + nums[c] + nums[d] == target
You may return the answer in any order.
","Example 1:
Input: nums = [1,0,-1,0,-2,2], target = 0
Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
Example 2:
Input: nums = [2,2,2,2,2], target = 8
Output: [[2,2,2,2]]
",,False
Remove Duplicates from Sorted Array,"Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.
Consider the number of unique elements of nums to be k, to get accepted, you need to do the following things:
Change the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums.
Return k.
Custom Judge:
The judge will test your solution with the following code:
int[] nums = [...]; // Input array
int[] expectedNums = [...]; // The expected answer with correct length

int k = removeDuplicates(nums); // Calls your implementation

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums[i] == expectedNums[i];
}
If all assertions pass, then your solution will be accepted.
","Example 1:
Input: nums = [1,1,2]
Output: 2, nums = [1,2,_]
Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
Example 2:
Input: nums = [0,0,1,1,1,2,2,3,3,4]
Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]
Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
","class Solution {
    public int removeDuplicates(int[] nums) {
        // declare idx variable
        int idx = 1;
        // iterate with pointer on nums array
        for(int p = 1; p < nums.length; p++) {
            // check if curr and prev values are unique
            if(nums[p - 1] != nums[p]) {
                // if true swap current value to idx value
                nums[idx] = nums[p];
                // increment idx
                idx++;
            }
        }
        // return idx
        return idx;
    }
}",False
Remove Element,"Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.
Consider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:
Change the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums.
Return k.
Custom Judge:
The judge will test your solution with the following code:
int[] nums = [...]; // Input array
int val = ...; // Value to remove
int[] expectedNums = [...]; // The expected answer with correct length.
                            // It is sorted with no values equaling val.

int k = removeElement(nums, val); // Calls your implementation

assert k == expectedNums.length;
sort(nums, 0, k); // Sort the first k elements of nums
for (int i = 0; i < actualLength; i++) {
    assert nums[i] == expectedNums[i];
}
If all assertions pass, then your solution will be accepted.
","Example 1:
Input: nums = [3,2,2,3], val = 3
Output: 2, nums = [2,2,_,_]
Explanation: Your function should return k = 2, with the first two elements of nums being 2.
It does not matter what you leave beyond the returned k (hence they are underscores).
Example 2:
Input: nums = [0,1,2,2,3,0,4,2], val = 2
Output: 5, nums = [0,1,4,0,3,_,_,_]
Explanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.
Note that the five elements can be returned in any order.
It does not matter what you leave beyond the returned k (hence they are underscores).
","class Solution {
    public int removeElement(int[] nums, int val) {
        int n = nums.length;
        int count=0;
        for(int i=0; i<nums.length;i++){
            if(nums[i]!=val){
                nums[count]=nums[i];
                count++;
            }
        }return count;
    }
}",False
Next Permutation,"A permutation of an array of integers is an arrangement of its members into a sequence or linear order.
For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].
The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).
For example, the next permutation of arr = [1,2,3] is [1,3,2].
Similarly, the next permutation of arr = [2,3,1] is [3,1,2].
While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.
Given an array of integers nums, find the next permutation of nums.
The replacement must be in place and use only constant extra memory.
","Example 1:
Input: nums = [1,2,3]
Output: [1,3,2]
Example 2:
Input: nums = [3,2,1]
Output: [1,2,3]
Example 3:
Input: nums = [1,1,5]
Output: [1,5,1]
","class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int idx=-1;
        int size=nums.size();
        for(int i=size-1;i>0;i--)
        {
            if(nums[i]>nums[i-1])
            {
                idx=i;
                break;
            }
        }
        if(idx==-1)
            reverse(nums.begin(),nums.end());
        else
        {
            int prev=idx;
            for(int i=idx+1;i<size;i++)
            {
                if(nums[i]>nums[idx-1] and nums[i]<=nums[prev])
                    prev=i;
                    
            }
            swap(nums[idx-1],nums[prev]);
            reverse(nums.begin()+idx,nums.end());
        }
    }
};",False
Search in Rotated Sorted Array,"There is an integer array nums sorted in ascending order (with distinct values).
Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].
Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.
You must write an algorithm with O(log n) runtime complexity.
","Example 1:
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
Example 2:
Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
Example 3:
Input: nums = [1], target = 0
Output: -1
","class Solution {
public:
    int search(int A[], int n, int target) {
        int lo=0,hi=n-1;
        // find the index of the smallest value using binary search.
        // Loop will terminate since mid < hi, and lo or hi will shrink by at least 1.
        // Proof by contradiction that mid < hi: if mid==hi, then lo==hi and loop would have been terminated.
        while(lo<hi){
            int mid=(lo+hi)/2;
            if(A[mid]>A[hi]) lo=mid+1;
            else hi=mid;
        }
        // lo==hi is the index of the smallest value and also the number of places rotated.
        int rot=lo;
        lo=0;hi=n-1;
        // The usual binary search and accounting for rotation.
        while(lo<=hi){
            int mid=(lo+hi)/2;
            int realmid=(mid+rot)%n;
            if(A[realmid]==target)return realmid;
            if(A[realmid]<target)lo=mid+1;
            else hi=mid-1;
        }
        return -1;
    }
};",False
Find First and Last Position of Element in Sorted Array,"Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.
If target is not found in the array, return [-1, -1].
You must write an algorithm with O(log n) runtime complexity.
","Example 1:
Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]
Example 2:
Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]
Example 3:
Input: nums = [], target = 0
Output: [-1,-1]
","class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        
        def binary_search(nums, target, is_searching_left):
            left = 0
            right = len(nums) - 1
            idx = -1
            
            while left <= right:
                mid = (left + right) // 2
                
                if nums[mid] > target:
                    right = mid - 1
                elif nums[mid] < target:
                    left = mid + 1
                else:
                    idx = mid
                    if is_searching_left:
                        right = mid - 1
                    else:
                        left = mid + 1
            
            return idx
        
        left = binary_search(nums, target, True)
        right = binary_search(nums, target, False)
        
        return [left, right]
            ",True
Search Insert Position,"Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.
You must write an algorithm with O(log n) runtime complexity.
","Example 1:
Input: nums = [1,3,5,6], target = 5
Output: 2
Example 2:
Input: nums = [1,3,5,6], target = 2
Output: 1
Example 3:
Input: nums = [1,3,5,6], target = 7
Output: 4
","class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        for i in range(len(nums)):
            if nums[i]==target:
                return i
            elif nums[i]>target:
                return i   
            else:
                j=len(nums)
        return j       ",True
Valid Sudoku,"Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:
Each row must contain the digits 1-9 without repetition.
Each column must contain the digits 1-9 without repetition.
Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.
Note:
A Sudoku board (partially filled) could be valid but is not necessarily solvable.
Only the filled cells need to be validated according to the mentioned rules.
","Example 1:

Input: board = 
[[""5"",""3"",""."",""."",""7"",""."",""."",""."","".""]
,[""6"",""."",""."",""1"",""9"",""5"",""."",""."","".""]
,[""."",""9"",""8"",""."",""."",""."",""."",""6"","".""]
,[""8"",""."",""."",""."",""6"",""."",""."",""."",""3""]
,[""4"",""."",""."",""8"",""."",""3"",""."",""."",""1""]
,[""7"",""."",""."",""."",""2"",""."",""."",""."",""6""]
,[""."",""6"",""."",""."",""."",""."",""2"",""8"","".""]
,[""."",""."",""."",""4"",""1"",""9"",""."",""."",""5""]
,[""."",""."",""."",""."",""8"",""."",""."",""7"",""9""]]
Output: true
Example 2:
Input: board = 
[[""8"",""3"",""."",""."",""7"",""."",""."",""."","".""]
,[""6"",""."",""."",""1"",""9"",""5"",""."",""."","".""]
,[""."",""9"",""8"",""."",""."",""."",""."",""6"","".""]
,[""8"",""."",""."",""."",""6"",""."",""."",""."",""3""]
,[""4"",""."",""."",""8"",""."",""3"",""."",""."",""1""]
,[""7"",""."",""."",""."",""2"",""."",""."",""."",""6""]
,[""."",""6"",""."",""."",""."",""."",""2"",""8"","".""]
,[""."",""."",""."",""4"",""1"",""9"",""."",""."",""5""]
,[""."",""."",""."",""."",""8"",""."",""."",""7"",""9""]]
Output: false
Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.
",,False
Combination Sum,"Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.
The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the
frequency
of at least one of the chosen numbers is different.
The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.
","Example 1:
Input: candidates = [2,3,6,7], target = 7
Output: [[2,2,3],[7]]
Explanation:
2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.
7 is a candidate, and 7 = 7.
These are the only two combinations.
Example 2:
Input: candidates = [2,3,5], target = 8
Output: [[2,2,2,2],[2,3,3],[3,5]]
Example 3:
Input: candidates = [2], target = 1
Output: []
","class Solution {
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<int> curr;  // Current combination
        vector<vector<int>> res;  // Resultant combinations
        // DFS function to explore combinations
        dfs(candidates, target, 0, curr, res);
        return res;
    }
private:
    void dfs(vector<int>& cands, int target, int i, vector<int>& curr, vector<vector<int>>& res) {
        // Base cases
        if (i >= cands.size() || target < 0)
            return;

        if (target == 0) {
            // Valid combination found, add to result
            res.push_back(curr);
            return;
        }

        // Include the current candidate in the combination
        curr.push_back(cands[i]);
        // Explore combinations with the current candidate
        dfs(cands, target - cands[i], i, curr, res);
        // Backtrack: remove the last candidate to explore combinations without it
        curr.pop_back();
        // Explore combinations without the current candidate
        dfs(cands, target, i + 1, curr, res);
    }
};",False
Combination Sum II,"Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.
Each number in candidates may only be used once in the combination.
Note: The solution set must not contain duplicate combinations.
","Example 1:
Input: candidates = [10,1,2,7,6,1,5], target = 8
Output: 
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
Example 2:
Input: candidates = [2,5,2,1,2], target = 5
Output: 
[
[1,2,2],
[5]
]
","class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        candidates.sort()
        output = []
        stack = []

        def backtrack(i, total=0):
            if total == target:
                output.append(stack.copy())
                return

            if i >= len(candidates) or total > target:
                return
            
            stack.append(candidates[i])
            backtrack(i+1, total+candidates[i])

            stack.pop()
            while i+1 < len(candidates) and candidates[i] == candidates[i+1]:
                i += 1
            
            backtrack(i+1, total)
        
        backtrack(0)
        return output
",True
Jump Game II,"You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0].
Each element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where:
0 <= j <= nums[i] and
i + j < n
Return the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1].
","Example 1:
Input: nums = [2,3,1,1,4]
Output: 2
Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.
Example 2:
Input: nums = [2,3,0,1,4]
Output: 2
","class Solution:
    def jump(self, nums: List[int]) -> int:
        result = 0
        l = r = 0

        while r < len(nums) - 1:
            farthest = 0
            for i in range(l, r + 1):
                farthest = max(farthest, i + nums[i])
            
            l = r + 1
            r = farthest
            result += 1

        return result",True
Permutations,"Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.
","Example 1:
Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
Example 2:
Input: nums = [0,1]
Output: [[0,1],[1,0]]
Example 3:
Input: nums = [1]
Output: [[1]]
","class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        res = []
        if len(nums) == 1:
            return [nums[:]] 
        for i in nums:
            n = nums.pop(0)
            subset = self.permute(nums)
            for i in subset:
                i.append(n)
            res.extend(subset)
            nums.append(n)
        return res    ",True
Permutations II,"Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.
","Example 1:
Input: nums = [1,1,2]
Output:
[[1,1,2],
 [1,2,1],
 [2,1,1]]
Example 2:
Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
",,False
Rotate Image,"You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).
You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.
","Example 1:

Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [[7,4,1],[8,5,2],[9,6,3]]
Example 2:

Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
","class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        for(int i=0; i<(matrix.size()+1)/2; i++){
            for(int j=i; j<(matrix[0].size()+1)/2; j++){
                if(i==0 && j==0){
                    int tl=matrix[i][j], tr=matrix[i][matrix[0].size()-j-1], bl=matrix[matrix.size()-i-1][j],br=matrix[matrix.size()-i-1][matrix[0].size()-j-1];
                    matrix[i][j]=bl;
                    matrix[i][matrix[0].size()-j-1]=tl;
                    matrix[matrix.size()-i-1][j]=br;
                    matrix[matrix.size()-i-1][matrix[0].size()-j-1]=tr;
                }
                else if((matrix.size()&2) && j==matrix.size()/2){
                    int tp=matrix[i][j], lft=matrix[j][i], rgt=matrix[j][matrix.size()-1-i], btm=matrix[matrix.size()-1-i][j];
                    matrix[i][j]=lft;
                    matrix[j][matrix.size()-1-i]=tp;
                    matrix[j][i]=btm;
                    matrix[matrix.size()-1-i][j]=rgt;
                }
                else{
                    int tplft=matrix[i][j], tprgt=matrix[i][matrix.size()-1-j];
                    int btmlft=matrix[matrix.size()-1-i][j], btmrgt=matrix[matrix.size()-1-i][matrix.size()-1-j];
                    int lftbtm=matrix[j][i], lfttp=matrix[matrix.size()-1-j][i];
                    int rgttp=matrix[matrix.size()-1-j][matrix.size()-1-i], rgtbtm=matrix[j][matrix.size()-1-i];
                    matrix[i][j]=lfttp;
                    matrix[i][matrix.size()-1-j]=lftbtm;
                    matrix[matrix.size()-1-i][j]=rgttp;
                    matrix[matrix.size()-1-i][matrix.size()-1-j]=rgtbtm;
                    matrix[j][i]=btmlft;
                    matrix[matrix.size()-1-j][i]=btmrgt;
                    matrix[matrix.size()-1-j][matrix.size()-1-i]=tprgt;
                    matrix[j][matrix.size()-1-i]=tplft;

                }
                // for(auto it: matrix){
                //     for(auto it1: it)cout<<it1<<"" "";
                //     cout<<endl;
                // }cout<<endl;
            }
        }
    }
};",False
Group Anagrams,"Given an array of strings strs, group the anagrams together. You can return the answer in any order.
An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.
","Example 1:
Input: strs = [""eat"",""tea"",""tan"",""ate"",""nat"",""bat""]
Output: [[""bat""],[""nat"",""tan""],[""ate"",""eat"",""tea""]]
Example 2:
Input: strs = [""""]
Output: [[""""]]
Example 3:
Input: strs = [""a""]
Output: [[""a""]]
","class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        d = defaultdict(list)

        for s in strs:
            count = [0]*26
            for c in s:
                count[ord(c)-ord('a')]+=1
            d[tuple(count)].append(s)

        return d.values()",True
Maximum Subarray,"Given an integer array nums, find the
subarray
with the largest sum, and return its sum.
","Example 1:
Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
Explanation: The subarray [4,-1,2,1] has the largest sum 6.
Example 2:
Input: nums = [1]
Output: 1
Explanation: The subarray [1] has the largest sum 1.
Example 3:
Input: nums = [5,4,-1,7,8]
Output: 23
Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.
","class Solution:
    def maxSubArray(self, nums: List[int]) -> int:

        maxSum,  curSum = nums[0], 0 
        for num in nums:
            if curSum < 0:
                curSum = 0
            curSum = curSum + num
            maxSum = max(maxSum , curSum)
        return maxSum",True
Spiral Matrix,"Given an m x n matrix, return all elements of the matrix in spiral order.
","Example 1:

Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
Output: [1,2,3,6,9,8,7,4,5]
Example 2:

Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
Output: [1,2,3,4,8,12,11,10,9,5,6,7]
",,False
Jump Game,"You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.
Return true if you can reach the last index, or false otherwise.
","Example 1:
Input: nums = [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
Example 2:
Input: nums = [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.
","class Solution {
public:
    bool canJump(vector<int>& nums) {
        int maxIdx = nums[0];

        for (int i = 0; i < nums.size(); ++i) {
            if (maxIdx >= nums.size() - 1) return true;

            if (nums[i] == 0 and maxIdx == i) return false;

            if (i + nums[i] > maxIdx) maxIdx = i + nums[i];
        }

        return true;
    }
};",False
Merge Intervals,"Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.
","Example 1:
Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].
Example 2:
Input: intervals = [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.
","class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        i=0
        intervals.sort()
        while(i<len(intervals)-1):
            if intervals[i+1][0] >= intervals[i][0]:
                if intervals[i+1][0]<=intervals[i][1]:
                    if intervals[i+1][1]>=intervals[i][1]:
                        intervals[i][1]=intervals[i+1][1]
                    intervals.remove(intervals[i+1])
                else:
                    i=i+1
        return intervals
",True
Insert Interval,"You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.
Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).
Return intervals after the insertion.
Note that you don't need to modify intervals in-place. You can make a new array and return it.
","Example 1:
Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
Output: [[1,5],[6,9]]
Example 2:
Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
Output: [[1,2],[3,10],[12,16]]
Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].
","class Solution(object):
    def insert(self, intervals, newInterval):
        merged = []
        i = 0

        while i < len(intervals) and intervals[i][1] < newInterval[0]:
            merged.append(intervals[i])
            i += 1
        
        while i < len(intervals) and intervals[i][0] <= newInterval[1]:
            newInterval = [min(newInterval[0], intervals[i][0]), max(newInterval[1], intervals[i][1])]
            i += 1
        merged.append(newInterval)
        
        while i < len(intervals):
            merged.append(intervals[i])
            i += 1
        
        return merged",True
Spiral Matrix II,"Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.
","Example 1:

Input: n = 3
Output: [[1,2,3],[8,9,4],[7,6,5]]
Example 2:
Input: n = 1
Output: [[1]]
",,False
Unique Paths II,"You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.
An obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle.
Return the number of possible unique paths that the robot can take to reach the bottom-right corner.
The testcases are generated so that the answer will be less than or equal to 2 * 109.
","Example 1:

Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
Output: 2
Explanation: There is one obstacle in the middle of the 3x3 grid above.
There are two ways to reach the bottom-right corner:
1. Right -> Right -> Down -> Down
2. Down -> Down -> Right -> Right
Example 2:

Input: obstacleGrid = [[0,1],[0,0]]
Output: 1
","class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int r = obstacleGrid.size();
        int c = obstacleGrid[0].size();
        int a[r][c];
        bool flag = false;
        if(obstacleGrid[0][0] == 1 || obstacleGrid[r-1][c-1] == 1)
            return 0;
        for(int i = 0; i < c; i++){
            if(flag || obstacleGrid[0][i]){ //presence of obstacle in the cell or previous cells in the row
                a[0][i] = 0;
                flag = true;
            }
            else
                a[0][i] = 1;
        }

         flag = false;

        for(int j = 1; j < r; j++){
            if(flag || obstacleGrid[j][0]){//presence of obstacle in the cell or previous cells in the column
                a[j][0] = 0;
                flag = true;
            }
            else
                a[j][0] = 1;
        }
        for(int i = 1; i < r; i++)
            for(int j = 1; j < c; j++){
                if(obstacleGrid[i][j] == 1)//obstacle
                     a[i][j] = 0;
                else
                    a[i][j] = a[i][j-1] + a[i-1][j];//can reach (i, j) through (i, j-1) or (i-1, j)
            }
            return a[r-1][c-1];
    }
};",False
Minimum Path Sum,"Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.
Note: You can only move either down or right at any point in time.
","Example 1:

Input: grid = [[1,3,1],[1,5,1],[4,2,1]]
Output: 7
Explanation: Because the path 1 → 3 → 1 → 1 → 1 minimizes the sum.
Example 2:
Input: grid = [[1,2,3],[4,5,6]]
Output: 12
","class Solution(object):
    def minPathSum(self, grid,i=0,j=0):
        n = len(grid)
        m = len(grid[0])
        
        costmatrix = [[0]*m for i in range(n)]

        costmatrix[0][0] = grid[0][0]
        for i in range(1,m):
            costmatrix[0][i] = costmatrix[0][i-1] + grid[0][i]
        for i in range(1,n):
            costmatrix[i][0] = costmatrix[i-1][0] + grid[i][0]
        for i in range(1,n):
            for j in range(1,m):
                costmatrix[i][j] = min(costmatrix[i-1][j], costmatrix[i][j-1]) + grid[i][j]
        return costmatrix[n-1][m-1]
               ",True
Plus One,"You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.
Increment the large integer by one and return the resulting array of digits.
","Example 1:
Input: digits = [1,2,3]
Output: [1,2,4]
Explanation: The array represents the integer 123.
Incrementing by one gives 123 + 1 = 124.
Thus, the result should be [1,2,4].
Example 2:
Input: digits = [4,3,2,1]
Output: [4,3,2,2]
Explanation: The array represents the integer 4321.
Incrementing by one gives 4321 + 1 = 4322.
Thus, the result should be [4,3,2,2].
Example 3:
Input: digits = [9]
Output: [1,0]
Explanation: The array represents the integer 9.
Incrementing by one gives 9 + 1 = 10.
Thus, the result should be [1,0].
","class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        string_digit = """"
        for digit in digits:
            string_digit = string_digit + str(digit)
        digit_int = int(string_digit) + 1
        string_digit = str(digit_int)
        result = []
        for s in string_digit:
            result.append(int(s))
        return result
        ",True
Set Matrix Zeroes,"Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.
You must do it in place.
","Example 1:

Input: matrix = [[1,1,1],[1,0,1],[1,1,1]]
Output: [[1,0,1],[0,0,0],[1,0,1]]
Example 2:

Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]
","class Solution {
    public void setZeroes(int[][] matrix) {
       int m=matrix.length , n=matrix[0].length;
       int cols=1;
       for(int i=0;i<m;i++)
        for(int j=0;j<n;j++){
            if(matrix[i][j]==0)
                {
                 matrix[i][0]=0;
                 if(j!=0)
                    matrix[0][j]=0;   
                else
                    cols=0;
                }
        }
    
    for(int i=1;i<m;i++)
        for(int j=1;j<n;j++)
            if(matrix[i][0]==0 || matrix[0][j]==0)
                matrix[i][j]=0;

    if(matrix[0][0]==0)
        for(int j=0;j<n;j++) matrix[0][j]=0;
    if(cols==0)
        for(int i=0;i<m;i++) matrix[i][0]=0;
    }
}",False
Search a 2D Matrix,"You are given an m x n integer matrix matrix with the following two properties:
Each row is sorted in non-decreasing order.
The first integer of each row is greater than the last integer of the previous row.
Given an integer target, return true if target is in matrix or false otherwise.
You must write a solution in O(log(m * n)) time complexity.
","Example 1:

Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
Output: true
Example 2:

Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
Output: false
","class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
     
        
        int row  =-1;
        int col = matrix[0].size()-1;
        int low = 0;
        int high = matrix.size()-1;
        
        while(low<=high)
        {
            
            int mid = low + (high-low)/2;
            
            if(target>=matrix[mid][0] && target<=matrix[mid][col])
            {
                row = mid;
                break;
            }
            else if(target<matrix[mid][0])
            {
                high = mid-1;
            }
            else
            {
                low = mid+1;
            }    
            
        }
        
        if(row==-1)
        {
            return false;
        }
        
        int start = 0;
        int end = matrix[row].size()-1;
        
        while(start<=end)
        {
            
            int mid = start + (end-start)/2;
            if(matrix[row][mid]==target)
            {
                return true;
            }
            else if(matrix[row][mid]>target)
            {
                end = mid-1;
            }
            else
            {
                start = mid+1;
            } 
        }
        
        return false;
    }
};",False
Sort Colors,"Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.
We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.
You must solve this problem without using the library's sort function.
","Example 1:
Input: nums = [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
Example 2:
Input: nums = [2,0,1]
Output: [0,1,2]
","class Solution:
    def sortColors(self, nums: List[int]) -> None:
        low, mid, high = 0, 0, len(nums) - 1
        while mid <= high:
            if nums[mid] == 0:
                nums[low], nums[mid] = nums[mid], nums[low]
                mid += 1
                low += 1
            elif nums[mid] == 2:
                nums[mid], nums[high] = nums[high], nums[mid]
                high -= 1
            elif nums[mid] == 1:
                mid += 1",True
Subsets,"Given an integer array nums of unique elements, return all possible
subsets
(the power set).
The solution set must not contain duplicate subsets. Return the solution in any order.
","Example 1:
Input: nums = [1,2,3]
Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
Example 2:
Input: nums = [0]
Output: [[],[0]]
",,False
Word Search,"Given an m x n grid of characters board and a string word, return true if word exists in the grid.
The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.
","Example 1:

Input: board = [[""A"",""B"",""C"",""E""],[""S"",""F"",""C"",""S""],[""A"",""D"",""E"",""E""]], word = ""ABCCED""
Output: true
Example 2:

Input: board = [[""A"",""B"",""C"",""E""],[""S"",""F"",""C"",""S""],[""A"",""D"",""E"",""E""]], word = ""SEE""
Output: true
Example 3:

Input: board = [[""A"",""B"",""C"",""E""],[""S"",""F"",""C"",""S""],[""A"",""D"",""E"",""E""]], word = ""ABCB""
Output: false
",,False
Remove Duplicates from Sorted Array II,"Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.
Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.
Return k after placing the final result in the first k slots of nums.
Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.
Custom Judge:
The judge will test your solution with the following code:
int[] nums = [...]; // Input array
int[] expectedNums = [...]; // The expected answer with correct length

int k = removeDuplicates(nums); // Calls your implementation

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums[i] == expectedNums[i];
}
If all assertions pass, then your solution will be accepted.
","Example 1:
Input: nums = [1,1,1,2,2,3]
Output: 5, nums = [1,1,2,2,3,_]
Explanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
Example 2:
Input: nums = [0,0,1,1,1,1,2,3,3]
Output: 7, nums = [0,0,1,1,2,3,3,_,_]
Explanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).
","class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        for i in nums:
            while( nums.count(i)>2):
                nums.remove(i)
            else:
                nums
        return len(nums)",True
Search in Rotated Sorted Array II,"There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values).
Before being passed to your function, nums is rotated at an unknown pivot index k (0 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4].
Given the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums.
You must decrease the overall operation steps as much as possible.
","Example 1:
Input: nums = [2,5,6,0,0,1,2], target = 0
Output: true
Example 2:
Input: nums = [2,5,6,0,0,1,2], target = 3
Output: false
","class Solution {
public:
    bool search(vector<int>& nums, int target) {
       return find(nums.begin(),nums.end(),target)!=nums.end();
       
    }
};",False
Merge Sorted Array,"You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.
Merge nums1 and nums2 into a single array sorted in non-decreasing order.
The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.
","Example 1:
Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
Output: [1,2,2,3,5,6]
Explanation: The arrays we are merging are [1,2,3] and [2,5,6].
The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.
Example 2:
Input: nums1 = [1], m = 1, nums2 = [], n = 0
Output: [1]
Explanation: The arrays we are merging are [1] and [].
The result of the merge is [1].
Example 3:
Input: nums1 = [0], m = 0, nums2 = [1], n = 1
Output: [1]
Explanation: The arrays we are merging are [] and [1].
The result of the merge is [1].
Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.
","class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int p=m-1;
        int q=n-1;
        int r=m+n-1;
        while(q>=0){
            if(p>=0 && nums1[p]>nums2[q]){
                nums1[r--]=nums1[p--];
            }
            else{
                nums1[r--]=nums2[q--];
            }
        }
     }
}",False
Subsets II,"Given an integer array nums that may contain duplicates, return all possible
subsets
(the power set).
The solution set must not contain duplicate subsets. Return the solution in any order.
","Example 1:
Input: nums = [1,2,2]
Output: [[],[1],[1,2],[1,2,2],[2],[2,2]]
Example 2:
Input: nums = [0]
Output: [[],[0]]
",,False
Construct Binary Tree from Preorder and Inorder Traversal,"Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.
","Example 1:

Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
Output: [3,9,20,null,null,15,7]
Example 2:
Input: preorder = [-1], inorder = [-1]
Output: [-1]
",,False
Construct Binary Tree from Inorder and Postorder Traversal,"Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.
","Example 1:

Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
Output: [3,9,20,null,null,15,7]
Example 2:
Input: inorder = [-1], postorder = [-1]
Output: [-1]
","class Solution {
	public:
		TreeNode* tree(vector<int>& in,int inStart,int inEnd,vector<int>& post,int postStart,int postEnd,map<int,int>& ind){
			if(inStart>inEnd || postStart>postEnd) return NULL;
			TreeNode* root=new TreeNode(post[postEnd]);
			int inRoot=ind[root->val];
			int numsleft=inRoot-inStart;
			root->left=tree(in,inStart,inRoot-1,post,postStart,postStart+numsleft-1,ind);
			root->right=tree(in,inRoot+1,inEnd,post,postStart+numsleft,postEnd-1,ind);
			return root;        
		}

		TreeNode* buildTree(vector<int>& in, vector<int>& post) {
			if(in.size()!=post.size()) return NULL;
			map<int,int>ind;
			for(int i=0;i<in.size();i++) ind[in[i]]=i;
			return tree(in,0,in.size()-1,post,0,post.size()-1,ind);
		}
	};",False
Convert Sorted Array to Binary Search Tree,"Given an integer array nums where the elements are sorted in ascending order, convert it to a
height-balanced
binary search tree.
","Example 1:

Input: nums = [-10,-3,0,5,9]
Output: [0,-3,9,-10,null,5]
Explanation: [0,-10,5,null,-3,null,9] is also accepted:
Example 2:

Input: nums = [1,3]
Output: [3,1]
Explanation: [1,null,3] and [3,1] are both height-balanced BSTs.
",,False
Pascal's Triangle,"Given an integer numRows, return the first numRows of Pascal's triangle.
In Pascal's triangle, each number is the sum of the two numbers directly above it as shown:

","Example 1:
Input: numRows = 5
Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
Example 2:
Input: numRows = 1
Output: [[1]]
","class Solution:
    def generate(self, numRows: int) -> List[List[int]]:
        if numRows == 1:
            return [[1]]
        prev = self.generate(numRows - 1)
        fin = prev[-1]
        now = [1]
        for i in range(len(fin)-1):
            now.append(fin[i] + fin[i+1])
        now.append(1)
        prev.append(now)
        return prev",True
Pascal's Triangle II,"Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal's triangle.
In Pascal's triangle, each number is the sum of the two numbers directly above it as shown:

","Example 1:
Input: rowIndex = 3
Output: [1,3,3,1]
Example 2:
Input: rowIndex = 0
Output: [1]
Example 3:
Input: rowIndex = 1
Output: [1,1]
","class Solution {
public:
    // Calculate n choose r (nCr) using a loop
    int calculateCombination(int n, int r) {
        long long result = 1;
        for (int i = 0; i < r; i++) {
            result = result * (n - i) / (i + 1);
        }
        return result;
    }

    vector<int> getRow(int rowIndex) {
        // Initialize a vector to represent The last Row
        vector<int> lastRow;

        for (int j = 0; j <= rowIndex; j++) {
            // Calculate and insert the binomial coefficient (nCr) into the row
            lastRow.push_back(calculateCombination(rowIndex, j));
        }
        
        return lastRow;
    }
};",False
Triangle,"Given a triangle array, return the minimum path sum from top to bottom.
For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.
","Example 1:
Input: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
Output: 11
Explanation: The triangle looks like:
   2
  3 4
 6 5 7
4 1 8 3
The minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).
Example 2:
Input: triangle = [[-10]]
Output: -10
",,False
Best Time to Buy and Sell Stock,"You are given an array prices where prices[i] is the price of a given stock on the ith day.
You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.
Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.
","Example 1:
Input: prices = [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.
Example 2:
Input: prices = [7,6,4,3,1]
Output: 0
Explanation: In this case, no transactions are done and the max profit = 0.
","class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int min_price = prices[0];
        int maxprof = 0;

        for(int i=1;i<prices.size();i++){
            maxprof = max(maxprof,prices[i]-min_price);
            min_price = min(prices[i],min_price);
        }

        return maxprof;
    }
};",False
Best Time to Buy and Sell Stock II,"You are given an integer array prices where prices[i] is the price of a given stock on the ith day.
On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.
Find and return the maximum profit you can achieve.
","Example 1:
Input: prices = [7,1,5,3,6,4]
Output: 7
Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.
Total profit is 4 + 3 = 7.
Example 2:
Input: prices = [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
Total profit is 4.
Example 3:
Input: prices = [7,6,4,3,1]
Output: 0
Explanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.
","class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        def back(x):
            while x < len(prices) - 1 and prices[x] < prices[x + 1]:
                x += 1
            return x
        mx = j = i = 0
        while i < len(prices) - 1:
            p = 0
            if prices[i] < prices[i + 1]:
                j = back(i)
                mx += prices[j] - prices[i]
                i = j
                if j >= len(prices) - 1:
                    break
            i += 1
                
        return mx",True
Longest Consecutive Sequence,"Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.
You must write an algorithm that runs in O(n) time.
","Example 1:
Input: nums = [100,4,200,1,3,2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
Example 2:
Input: nums = [0,3,7,2,5,8,4,6,0,1]
Output: 9
",,False
Surrounded Regions,"Given an m x n matrix board containing 'X' and 'O', capture all regions that are 4-directionally surrounded by 'X'.
A region is captured by flipping all 'O's into 'X's in that surrounded region.
","Example 1:

Input: board = [[""X"",""X"",""X"",""X""],[""X"",""O"",""O"",""X""],[""X"",""X"",""O"",""X""],[""X"",""O"",""X"",""X""]]
Output: [[""X"",""X"",""X"",""X""],[""X"",""X"",""X"",""X""],[""X"",""X"",""X"",""X""],[""X"",""O"",""X"",""X""]]
Explanation: Notice that an 'O' should not be flipped if:
- It is on the border, or
- It is adjacent to an 'O' that should not be flipped.
The bottom 'O' is on the border, so it is not flipped.
The other three 'O' form a surrounded region, so they are flipped.
Example 2:
Input: board = [[""X""]]
Output: [[""X""]]
","class Solution:

    def solve(self, board: List[List[str]]) -> None:
        n_rows, n_cols = len(board), len(board[0])

        # all ""O""s in the border are unsurrounded, we find these, then traverse adjacent ""O""s
        def dfs(r, c):
            if r < 0 or r == n_rows or c < 0 or c == n_cols or board[r][c] != ""O"":
                return
          
            board[r][c] = ""T"" # these are unsurrounded
            dfs(r + 1, c)
            dfs(r - 1, c)
            dfs(r, c + 1)
            dfs(r, c - 1)
        
        for r in range(n_rows):
            for c in range(n_cols):
                if board[r][c] == ""O"" and (r in [0, n_rows - 1] or c in [0, n_cols - 1]):
                    dfs(r, c)

        for r in range(n_rows):
            for c in range(n_cols):
                if board[r][c] == ""O"": # surrounded, since can't reach border
                    board[r][c] = ""X""
        
        for r in range(n_rows):
            for c in range(n_cols):
                if board[r][c] == ""T"":
                    board[r][c] = ""O""

",True
Gas Station,"There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i].
You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations.
Given two integer arrays gas and cost, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique
","Example 1:
Input: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
Output: 3
Explanation:
Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 4. Your tank = 4 - 1 + 5 = 8
Travel to station 0. Your tank = 8 - 2 + 1 = 7
Travel to station 1. Your tank = 7 - 3 + 2 = 6
Travel to station 2. Your tank = 6 - 4 + 3 = 5
Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.
Therefore, return 3 as the starting index.
Example 2:
Input: gas = [2,3,4], cost = [3,4,3]
Output: -1
Explanation:
You can't start at station 0 or 1, as there is not enough gas to travel to the next station.
Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 0. Your tank = 4 - 3 + 2 = 3
Travel to station 1. Your tank = 3 - 3 + 3 = 3
You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.
Therefore, you can't travel around the circuit once no matter where you start.
","class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        if sum(gas) < sum(cost):
            # If total gas is less than total cost, it's impossible to complete the circuit.
            return -1

        start, fuel = 0, 0
        for i in range(len(gas)):
            fuel += gas[i] - cost[i]
            if fuel < 0:
                # If fuel drops below 0, start from the next station.
                start = i + 1
                fuel = 0

        return start


",True
Single Number,"Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.
You must implement a solution with a linear runtime complexity and use only constant extra space.
","Example 1:
Input: nums = [2,2,1]
Output: 1
Example 2:
Input: nums = [4,1,2,1,2]
Output: 4
Example 3:
Input: nums = [1]
Output: 1
","class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int xorr=0;
        for(int i=0; i<nums.size(); i++){
            xorr=xorr^nums[i];
        }
        return xorr;
    }
};",False
Single Number II,"Given an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return it.
You must implement a solution with a linear runtime complexity and use only constant extra space.
","Example 1:
Input: nums = [2,2,3,2]
Output: 3
Example 2:
Input: nums = [0,1,0,1,0,1,99]
Output: 99
","class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        return ((3*sum((set(nums))))-sum(nums))//2",True
Word Break,"Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.
Note that the same word in the dictionary may be reused multiple times in the segmentation.
","Example 1:
Input: s = ""leetcode"", wordDict = [""leet"",""code""]
Output: true
Explanation: Return true because ""leetcode"" can be segmented as ""leet code"".
Example 2:
Input: s = ""applepenapple"", wordDict = [""apple"",""pen""]
Output: true
Explanation: Return true because ""applepenapple"" can be segmented as ""apple pen apple"".
Note that you are allowed to reuse a dictionary word.
Example 3:
Input: s = ""catsandog"", wordDict = [""cats"",""dog"",""sand"",""and"",""cat""]
Output: false
","class Solution {
public:
    bool wordBreak(string s, vector<string>& dic) {
        vector<int> memo;
        memo.resize(s.length() + 1, 0);
        memo[s.length()] = 1;
        for (int i = s.length() - 1; i >= 0; i--) {
            bool ans = false;
            for (int j = 0; j < dic.size(); j++) {
                if (s.substr(i, dic[j].size()) == dic[j])
                    ans = ans || memo[i + dic[j].size()];
            }
            memo[i] = ans; 
        }
        return memo[0]; 
    }
};",False
Evaluate Reverse Polish Notation,"You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.
Evaluate the expression. Return an integer that represents the value of the expression.
Note that:
The valid operators are '+', '-', '*', and '/'.
Each operand may be an integer or another expression.
The division between two integers always truncates toward zero.
There will not be any division by zero.
The input represents a valid arithmetic expression in a reverse polish notation.
The answer and all the intermediate calculations can be represented in a 32-bit integer.
","Example 1:
Input: tokens = [""2"",""1"",""+"",""3"",""*""]
Output: 9
Explanation: ((2 + 1) * 3) = 9
Example 2:
Input: tokens = [""4"",""13"",""5"",""/"",""+""]
Output: 6
Explanation: (4 + (13 / 5)) = 6
Example 3:
Input: tokens = [""10"",""6"",""9"",""3"",""+"",""-11"",""*"",""/"",""*"",""17"",""+"",""5"",""+""]
Output: 22
Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
",,False
Maximum Product Subarray,"Given an integer array nums, find a
subarray
that has the largest product, and return the product.
The test cases are generated so that the answer will fit in a 32-bit integer.
","Example 1:
Input: nums = [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.
Example 2:
Input: nums = [-2,0,-1]
Output: 0
Explanation: The result cannot be 2, because [-2,-1] is not a subarray.
","class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        if not nums:
            return 0

        max_product = nums[0]
        current_max = nums[0]
        current_min = nums[0]

        for i in range(1, len(nums)):
            if nums[i] < 0:
                current_max, current_min = current_min, current_max
            
            current_max = max(nums[i], current_max * nums[i])
            current_min = min(nums[i], current_min * nums[i])

            max_product = max(max_product, current_max)

        return max_product",True
Find Minimum in Rotated Sorted Array,"Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:
[4,5,6,7,0,1,2] if it was rotated 4 times.
[0,1,2,4,5,6,7] if it was rotated 7 times.
Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].
Given the sorted rotated array nums of unique elements, return the minimum element of this array.
You must write an algorithm that runs in O(log n) time.
","Example 1:
Input: nums = [3,4,5,1,2]
Output: 1
Explanation: The original array was [1,2,3,4,5] rotated 3 times.
Example 2:
Input: nums = [4,5,6,7,0,1,2]
Output: 0
Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.
Example 3:
Input: nums = [11,13,15,17]
Output: 11
Explanation: The original array was [11,13,15,17] and it was rotated 4 times. 
","class Solution:
    def findMin(self, nums: List[int]) -> int:
        left, right = 0, len(nums) - 1

        while left < right:
            mid = (left + right) >> 1

            if nums[mid] > nums[right]:
                # Minimum element is in the right half
                left = mid + 1
            else:
                # Minimum element is in the left half (including mid)
                right = mid

        # After the loop, left (or right) should point to the minimum element
        return nums[left]",True
Find Peak Element,"A peak element is an element that is strictly greater than its neighbors.
Given a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.
You may imagine that nums[-1] = nums[n] = -∞. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.
You must write an algorithm that runs in O(log n) time.
","Example 1:
Input: nums = [1,2,3,1]
Output: 2
Explanation: 3 is a peak element and your function should return the index number 2.
Example 2:
Input: nums = [1,2,1,3,5,6,4]
Output: 5
Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.
","class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int n=nums.size();
        vector<int> gl(n,0), gr(n,0);
        multiset<int> s;
        for(int i=0;i<n;i++){
            s.insert(nums[i]);
            auto ub=upper_bound(s.begin(),s.end(),nums[i]);
            gl[i]=distance(ub,s.end());
        }
        s.clear();
        for(int i=n-1;i>=0;i--){
            s.insert(nums[i]);
            auto ub=upper_bound(s.begin(),s.end(),nums[i]);
            gr[i]=distance(ub,s.end());
        }
int ans=-1;
        for(int i=0;i<n;i++){
if(gl[i]==0&&gr[i]==0){
    ans=i;
    break;
}
        }
        return ans;
        
    }
};",False
Maximum Gap,"Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.
You must write an algorithm that runs in linear time and uses linear extra space.
","Example 1:
Input: nums = [3,6,9,1]
Output: 3
Explanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.
Example 2:
Input: nums = [10]
Output: 0
Explanation: The array contains less than 2 elements, therefore return 0.
","class Solution:
    def maximumGap(self, nums: List[int]) -> int:
        
        # Check if the list is empty or contains only one element
        if len(nums) < 2:
            return 0
        
        # Get the minimum and maximum values in the list
        min_val = min(nums)
        max_val = max(nums)
        
        # Calculate the bucket size and number of buckets
        bucket_size = max(1, (max_val - min_val) // (len(nums) - 1))
        num_buckets = (max_val - min_val) // bucket_size + 1
        
        # Initialize the buckets
        buckets = [None] * num_buckets
        
        # Put each element in its corresponding bucket
        for num in nums:
            bucket_index = (num - min_val) // bucket_size
            if not buckets[bucket_index]:
                buckets[bucket_index] = {'min': num, 'max': num}
            else:
                buckets[bucket_index]['min'] = min(buckets[bucket_index]['min'], num)
                buckets[bucket_index]['max'] = max(buckets[bucket_index]['max'], num)
        
        # Calculate the maximum gap between adjacent buckets
        max_gap = 0
        prev_max = min_val
        for bucket in buckets:
            if bucket:
                max_gap = max(max_gap, bucket['min'] - prev_max)
                prev_max = bucket['max']
        
        return max_gap
",True
Two Sum II - Input Array Is Sorted,"Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 <= numbers.length.
Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.
The tests are generated such that there is exactly one solution. You may not use the same element twice.
Your solution must use only constant extra space.
","Example 1:
Input: numbers = [2,7,11,15], target = 9
Output: [1,2]
Explanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2].
Example 2:
Input: numbers = [2,3,4], target = 6
Output: [1,3]
Explanation: The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3. We return [1, 3].
Example 3:
Input: numbers = [-1,0], target = -1
Output: [1,2]
Explanation: The sum of -1 and 0 is -1. Therefore index1 = 1, index2 = 2. We return [1, 2].
",,False
Majority Element,"Given an array nums of size n, return the majority element.
The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.
","Example 1:
Input: nums = [3,2,3]
Output: 3
Example 2:
Input: nums = [2,2,1,1,1,2,2]
Output: 2
","class Solution {
public:
  int majorityElement(vector<int> &nums) {
    int majorityElement = nums[0];
    int cnt = 1;
    for (int i = 1; i < nums.size(); i++) {
      if (nums[i] == majorityElement) {
        cnt++;
      } else {
        cnt--;
        if (cnt == 0) {
          majorityElement = nums[i + 1];
        }
      }
    }
    return majorityElement;
  }
};",False
Largest Number,"Given a list of non-negative integers nums, arrange them such that they form the largest number and return it.
Since the result may be very large, so you need to return a string instead of an integer.
","Example 1:
Input: nums = [10,2]
Output: ""210""
Example 2:
Input: nums = [3,30,34,5,9]
Output: ""9534330""
",,False
Rotate Array,"Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.
","Example 1:
Input: nums = [1,2,3,4,5,6,7], k = 3
Output: [5,6,7,1,2,3,4]
Explanation:
rotate 1 steps to the right: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]
Example 2:
Input: nums = [-1,-100,3,99], k = 2
Output: [3,99,-1,-100]
Explanation: 
rotate 1 steps to the right: [99,-1,-100,3]
rotate 2 steps to the right: [3,99,-1,-100]
","class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """"""
        Do not return anything, modify nums in-place instead.
        """"""
        
        def rev(l, r):
            while l < r:
                nums[l], nums[r] = nums[r], nums[l]
                l += 1
                r -= 1
        
        n = len(nums)
        k %= n  # Handle cases where k > n
        
        rev(0, n-1)  # Reverse the entire array
        rev(0, k-1)  # Reverse the first k elements
        rev(k, n-1)  # Reverse the remaining elements",True
House Robber,"You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.
Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.
","Example 1:
Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
Example 2:
Input: nums = [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
Total amount you can rob = 2 + 9 + 1 = 12.
","class Solution {
public:
    int dp[1500];
    int dfs(int i,int n,vector<int>&nums){
        if(i>=n)
            return 0;
        auto &res=dp[i];
        if(res!=-1)
            return res;
        
        int choix1=nums[i]+dfs(i+2,n,nums);
        int choix2=dfs(i+1,n,nums);
        return res=max(choix2,choix1);
    
    }
    int rob(vector<int>& nums) {
        //memset(dp,-1,sizeof dp);
        int n=nums.size();
        dp[0]=nums[0];
        if(n==1)
            return nums[0];
        if(n==2)
            return max(nums[0],nums[1]);
        dp[1]=nums[1];
        for(int i=2;i<n;i++){
            dp[i]=dp[i-1];
            for(int j=i-2;j>=0;j--){
                dp[i]=max(dp[i],dp[j]+nums[i]);
            }
        }
        return dp[n-1];
    }
};",False
Number of Islands,"Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.
An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.
","Example 1:
Input: grid = [
  [""1"",""1"",""1"",""1"",""0""],
  [""1"",""1"",""0"",""1"",""0""],
  [""1"",""1"",""0"",""0"",""0""],
  [""0"",""0"",""0"",""0"",""0""]
]
Output: 1
Example 2:
Input: grid = [
  [""1"",""1"",""0"",""0"",""0""],
  [""1"",""1"",""0"",""0"",""0""],
  [""0"",""0"",""1"",""0"",""0""],
  [""0"",""0"",""0"",""1"",""1""]
]
Output: 3
","class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        
        vis = set()

        def dfs(i,j):
            if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j] != '1':
                return

            if (i,j) in vis:
                return

            vis.add((i,j))

            dfs(i+1,j)
            dfs(i,j+1)
            dfs(i-1,j)
            dfs(i,j-1)

        ans = 0

        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == '1' and (i,j) not in vis:
                    dfs(i,j)
                    ans+=1
        return ans",True
Count Primes,"Given an integer n, return the number of prime numbers that are strictly less than n.
","Example 1:
Input: n = 10
Output: 4
Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.
Example 2:
Input: n = 0
Output: 0
Example 3:
Input: n = 1
Output: 0
","class Solution {
public:
    int countPrimes(int n) {
        vector<bool>prime(n+1,true);
        prime[0]=prime[1]=false;
        int c=0;
        for(int i=2;i<n;i++){
            if(prime[i]){
                c++;
                for(int j=2*i;j<n;j=j+i){
                    prime[j]=0;
                }
            }

        }
        return c;
    }
};",False
Minimum Size Subarray Sum,"Given an array of positive integers nums and a positive integer target, return the minimal length of a
subarray
whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.
","Example 1:
Input: target = 7, nums = [2,3,1,2,4,3]
Output: 2
Explanation: The subarray [4,3] has the minimal length under the problem constraint.
Example 2:
Input: target = 4, nums = [1,4,4]
Output: 1
Example 3:
Input: target = 11, nums = [1,1,1,1,1,1,1,1]
Output: 0
","class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int ans=INT_MAX;
        int sum=0;
        int l=0;
        for(int i=0;i<nums.size();i++){
            sum+=nums[i];
            while(sum>=target){
                ans=min(ans,i-l+1);
                sum-=nums[l];
                l++;
            }
        }
        if(ans==INT_MAX){
            return 0;
        }
        return ans;

    }
};",False
House Robber II,"You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.
Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.
","Example 1:
Input: nums = [2,3,2]
Output: 3
Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.
Example 2:
Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
Example 3:
Input: nums = [1,2,3]
Output: 3
",,False
Kth Largest Element in an Array,"Given an integer array nums and an integer k, return the kth largest element in the array.
Note that it is the kth largest element in the sorted order, not the kth distinct element.
Can you solve it without sorting?
","Example 1:
Input: nums = [3,2,1,5,6,4], k = 2
Output: 5
Example 2:
Input: nums = [3,2,3,1,2,4,5,5,6], k = 4
Output: 4
","class Solution {
    public int findKthLargest(int[] nums, int k) {
    
        PriorityQueue<Integer> q = new PriorityQueue<>(k);
        for (int i:nums){
            q.offer(i);
            if (q.size()>k) q.poll();
            

        }return q.peek();
    }
    
}",False
Combination Sum III,"Find all valid combinations of k numbers that sum up to n such that the following conditions are true:
Only numbers 1 through 9 are used.
Each number is used at most once.
Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.
","Example 1:
Input: k = 3, n = 7
Output: [[1,2,4]]
Explanation:
1 + 2 + 4 = 7
There are no other valid combinations.
Example 2:
Input: k = 3, n = 9
Output: [[1,2,6],[1,3,5],[2,3,4]]
Explanation:
1 + 2 + 6 = 9
1 + 3 + 5 = 9
2 + 3 + 4 = 9
There are no other valid combinations.
Example 3:
Input: k = 4, n = 1
Output: []
Explanation: There are no valid combinations.
Using 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 > 1, there are no valid combination.
","class Solution {
    func combinationSum3(_ k: Int, _ n: Int) -> [[Int]] {
        var result = [[Int]]()
        var temp = [Int]()
        f(1, k, n, &temp, &result)
        return result
    }

    private func f(_ index: Int,
                    _ k: Int,
                    _ n: Int,
                    _ temp: inout [Int],
                    _ result: inout [[Int]]) {
        if n == 0 && k == 0 {
            result.append(temp)
            return
        }

        if k == 0 && n > 0 {
            return
        }

        for i in index..<10 {
            if n >= i {
                temp.append(i)
                f(i + 1, k - 1, n - i, &temp, &result)
                temp.removeLast()
            }
        }        
    }
}",False
Contains Duplicate,"Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.
","Example 1:
Input: nums = [1,2,3,1]
Output: true
Example 2:
Input: nums = [1,2,3,4]
Output: false
Example 3:
Input: nums = [1,1,1,3,3,4,3,2,4,2]
Output: true
",,False
Contains Duplicate II,"Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k.
","Example 1:
Input: nums = [1,2,3,1], k = 3
Output: true
Example 2:
Input: nums = [1,0,1,1], k = 1
Output: true
Example 3:
Input: nums = [1,2,3,1,2,3], k = 2
Output: false
","class Solution:
    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:
        # Create hset for storing previous of k elements...
        hset = {}
        # Traverse for all elements of the given array in a for loop...
        for idx in range(len(nums)):
            # If duplicate element is present at distance less than equal to k, return true...
            if nums[idx] in hset and abs(idx - hset[nums[idx]]) <= k:
                return True
            hset[nums[idx]] = idx
        # If no duplicate element is found then return false...
        return False",True
Maximal Square,"Given an m x n binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.
","Example 1:

Input: matrix = [[""1"",""0"",""1"",""0"",""0""],[""1"",""0"",""1"",""1"",""1""],[""1"",""1"",""1"",""1"",""1""],[""1"",""0"",""0"",""1"",""0""]]
Output: 4
Example 2:

Input: matrix = [[""0"",""1""],[""1"",""0""]]
Output: 1
Example 3:
Input: matrix = [[""0""]]
Output: 0
","class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        if (matrix.empty()) {
            return 0;
        }
        int m = matrix.size(), n = matrix[0].size(), sz = 0, pre;
        vector<int> cur(n, 0);
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int temp = cur[j];
                if (!i || !j || matrix[i][j] == '0') {
                    cur[j] = matrix[i][j] - '0';
                } else {
                    cur[j] = min(pre, min(cur[j], cur[j - 1])) + 1;
                }
                sz = max(cur[j], sz);
                pre = temp;
            }
        }
        return sz * sz;
    }
};",False
Summary Ranges,"You are given a sorted unique integer array nums.
A range [a,b] is the set of all integers from a to b (inclusive).
Return the smallest sorted list of ranges that cover all the numbers in the array exactly. That is, each element of nums is covered by exactly one of the ranges, and there is no integer x such that x is in one of the ranges but not in nums.
Each range [a,b] in the list should be output as:
""a->b"" if a != b
""a"" if a == b
","Example 1:
Input: nums = [0,1,2,4,5,7]
Output: [""0->2"",""4->5"",""7""]
Explanation: The ranges are:
[0,2] --> ""0->2""
[4,5] --> ""4->5""
[7,7] --> ""7""
Example 2:
Input: nums = [0,2,3,4,6,8,9]
Output: [""0"",""2->4"",""6"",""8->9""]
Explanation: The ranges are:
[0,0] --> ""0""
[2,4] --> ""2->4""
[6,6] --> ""6""
[8,9] --> ""8->9""
","class Solution {
public:
    vector<string> summaryRanges(vector<int>& nums) {
        vector<string> ans={};
        if(nums.size()==0) return ans;
        if(nums.size()==1){
            ans.push_back(to_string(nums[0]));
            return ans;
        }
        int i=0,j;
        string temp;
        while(i<nums.size()){
            j=i+1;
            while(j<nums.size() && nums[j - 1] + 1 == nums[j]) j++;
            temp=(j-i>1)?(to_string(nums[i])+""->""+to_string(nums[j-1])):(to_string(nums[i]));
            ans.push_back(temp);
            i=j;
        }
        return ans; 
    }
};",False
Majority Element II,"Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.
","Example 1:
Input: nums = [3,2,3]
Output: [3]
Example 2:
Input: nums = [1]
Output: [1]
Example 3:
Input: nums = [1,2]
Output: [1,2]
","class Solution:
    def majorityElement(self, nums: List[int]) -> List[int]:
        freq={}
        ans=[]
        for i in range(0,len(nums)):
            if(nums[i] in freq):
                freq[nums[i]]+=1
            else:
                freq[nums[i]]=0
        for i in freq:
            if freq[i]>=len(nums)//3:
                ans.append(i)
        return ans
",True
Product of Array Except Self,"Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].
The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.
You must write an algorithm that runs in O(n) time and without using the division operation.
","Example 1:
Input: nums = [1,2,3,4]
Output: [24,12,8,6]
Example 2:
Input: nums = [-1,1,0,-3,3]
Output: [0,0,9,0,0]
","class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        output = []
        prefix, suffix = list(accumulate(nums, operator.mul)), list(accumulate(reversed(nums), operator.mul))[::-1]
        for i in range(len(nums)): 
            if 0 < i < len(nums) - 1:
                output.append(prefix[i - 1] * suffix[i + 1])
            elif i == 0: 
                output.append(suffix[i + 1])
            else:
                output.append(prefix[i - 1])
        return output",True
Search a 2D Matrix II,"Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties:
Integers in each row are sorted in ascending from left to right.
Integers in each column are sorted in ascending from top to bottom.
","Example 1:

Input: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
Output: true
Example 2:

Input: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
Output: false
","class Solution {
public:
    bool searchMatrix(vector<vector<int>>& a, int t) {
        int m=a.size(),n=a[0].size();
        int i=0,j=n-1;

        while(i<m && j>=0)
        {
            if(a[i][j]==t)
            return 1;

            if(t>a[i][j])
                i++;
            else
                j--;
        }

        return 0;
    }
};",False
Single Number III,"Given an integer array nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in any order.
You must write an algorithm that runs in linear runtime complexity and uses only constant extra space.
","Example 1:
Input: nums = [1,2,1,3,2,5]
Output: [3,5]
Explanation:  [5, 3] is also a valid answer.
Example 2:
Input: nums = [-1,0]
Output: [-1,0]
Example 3:
Input: nums = [0,1]
Output: [1,0]
",,False
Missing Number,"Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.
","Example 1:
Input: nums = [3,0,1]
Output: 2
Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.
Example 2:
Input: nums = [0,1]
Output: 2
Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.
Example 3:
Input: nums = [9,6,4,2,3,5,7,0,1]
Output: 8
Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.
","class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        left,right=0,len(nums)
        nums.sort()
        while left<=right:
            mid=(left+right)//2
            if mid>len(nums)-1:
                return mid
            elif mid!=nums[mid] and mid<len(nums):
                right=mid-1
            elif mid==nums[mid]:
                left=mid+1
        return left                
        ",True
H-Index,"Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return the researcher's h-index.
According to the definition of h-index on Wikipedia: The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times.
","Example 1:
Input: citations = [3,0,6,1,5]
Output: 3
Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively.
Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.
Example 2:
Input: citations = [1,3,1]
Output: 1
","class Solution {
public:
    int hIndex(vector<int>& citations) {
        int n = citations.size();
        sort(citations.begin(), citations.end());
        for(int i=0; i<n; i++) {
            if(citations[i] >= n - i) return n - i;
        }
        return 0;
    }
};",False
H-Index II,"Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper and citations is sorted in ascending order, return the researcher's h-index.
According to the definition of h-index on Wikipedia: The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times.
You must write an algorithm that runs in logarithmic time.
","Example 1:
Input: citations = [0,1,3,5,6]
Output: 3
Explanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had received 0, 1, 3, 5, 6 citations respectively.
Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.
Example 2:
Input: citations = [1,2,100]
Output: 2
","class Solution:
    def hIndex(self, citations: List[int]) -> int:
        if not citations:
            return 0
        if len(citations) == 1:
            return 0 if citations[0] == 0 else 1
                
            
        i = 0
        j = i+1
        while j < len(citations) and i < len(citations):
            if (j-i+1) > citations[i]:
                i += 1
            else:
                j += 1

        return j-i if i < len(citations) else 0
        ",True
Move Zeroes,"Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.
Note that you must do this in-place without making a copy of the array.
","Example 1:
Input: nums = [0,1,0,3,12]
Output: [1,3,12,0,0]
Example 2:
Input: nums = [0]
Output: [0]
",,False
Peeking Iterator,"Design an iterator that supports the peek operation on an existing iterator in addition to the hasNext and the next operations.
Implement the PeekingIterator class:
PeekingIterator(Iterator<int> nums) Initializes the object with the given integer iterator iterator.
int next() Returns the next element in the array and moves the pointer to the next element.
boolean hasNext() Returns true if there are still elements in the array.
int peek() Returns the next element in the array without moving the pointer.
Note: Each language may have a different implementation of the constructor and Iterator, but they all support the int next() and boolean hasNext() functions.
","Example 1:
Input
[""PeekingIterator"", ""next"", ""peek"", ""next"", ""next"", ""hasNext""]
[[[1, 2, 3]], [], [], [], [], []]
Output
[null, 1, 2, 2, 3, false]

Explanation
PeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [1,2,3]
peekingIterator.next();    // return 1, the pointer moves to the next element [1,2,3].
peekingIterator.peek();    // return 2, the pointer does not move [1,2,3].
peekingIterator.next();    // return 2, the pointer moves to the next element [1,2,3]
peekingIterator.next();    // return 3, the pointer moves to the next element [1,2,3]
peekingIterator.hasNext(); // return False
",,False
Find the Duplicate Number,"Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.
There is only one repeated number in nums, return this repeated number.
You must solve the problem without modifying the array nums and uses only constant extra space.
","Example 1:
Input: nums = [1,3,4,2,2]
Output: 2
Example 2:
Input: nums = [3,1,3,4,2]
Output: 3
Example 3:
Input: nums = [3,3,3,3,3]
Output: 3
","class Solution(object):
    def findDuplicate(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        tortoise = nums[0]
        hare = nums[0]
        
        while True:
            tortoise = nums[tortoise]
            hare = nums[nums[hare]]
            if tortoise == hare:
                break
    
        tortoise = nums[0]
        while tortoise != hare:
            tortoise = nums[tortoise]
            hare = nums[hare]
        
        return tortoise",True
Game of Life,"According to Wikipedia's article: ""The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.""
The board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):
Any live cell with fewer than two live neighbors dies as if caused by under-population.
Any live cell with two or three live neighbors lives on to the next generation.
Any live cell with more than three live neighbors dies, as if by over-population.
Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.
The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the m x n grid board, return the next state.
","Example 1:

Input: board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]
Output: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]
Example 2:

Input: board = [[1,1],[1,0]]
Output: [[1,1],[1,1]]
",,False
Longest Increasing Subsequence,"Given an integer array nums, return the length of the longest strictly increasing
subsequence
.
","Example 1:
Input: nums = [10,9,2,5,3,7,101,18]
Output: 4
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.
Example 2:
Input: nums = [0,1,0,3,2,3]
Output: 4
Example 3:
Input: nums = [7,7,7,7,7,7,7]
Output: 1
","class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        from bisect import bisect_left
        n = len(nums)
        # Initialising the temporary list to store the start element and len of lis will equla 1
        temp = [nums[0]]
        length = 1
        # from 1 to n-1 as we have initialy added the starting element to the temp
        for i in range(1,n):
            # If the element in the nums is greater than the last element in the temp list add it to the temp
            if nums[i] > temp[-1]:
                temp.append(nums[i])
                length += 1
            else:
                # Use binary search to place the item in temp
                ind = bisect_left(temp,nums[i])
                temp[ind] = nums[i]
        return length
        ",True
Range Sum Query - Immutable,"Given an integer array nums, handle multiple queries of the following type:
Calculate the sum of the elements of nums between indices left and right inclusive where left <= right.
Implement the NumArray class:
NumArray(int[] nums) Initializes the object with the integer array nums.
int sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive (i.e. nums[left] + nums[left + 1] + ... + nums[right]).
","Example 1:
Input
[""NumArray"", ""sumRange"", ""sumRange"", ""sumRange""]
[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]
Output
[null, 1, -1, -3]

Explanation
NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);
numArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1
numArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1
numArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3
",,False
Range Sum Query 2D - Immutable,"Given a 2D matrix matrix, handle multiple queries of the following type:
Calculate the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).
Implement the NumMatrix class:
NumMatrix(int[][] matrix) Initializes the object with the integer matrix matrix.
int sumRegion(int row1, int col1, int row2, int col2) Returns the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).
You must design an algorithm where sumRegion works on O(1) time complexity.
","Example 1:

Input
[""NumMatrix"", ""sumRegion"", ""sumRegion"", ""sumRegion""]
[[[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]], [2, 1, 4, 3], [1, 1, 2, 2], [1, 2, 2, 4]]
Output
[null, 8, 11, 12]

Explanation
NumMatrix numMatrix = new NumMatrix([[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]);
numMatrix.sumRegion(2, 1, 4, 3); // return 8 (i.e sum of the red rectangle)
numMatrix.sumRegion(1, 1, 2, 2); // return 11 (i.e sum of the green rectangle)
numMatrix.sumRegion(1, 2, 2, 4); // return 12 (i.e sum of the blue rectangle)
",,False
Range Sum Query - Mutable,"Given an integer array nums, handle multiple queries of the following types:
Update the value of an element in nums.
Calculate the sum of the elements of nums between indices left and right inclusive where left <= right.
Implement the NumArray class:
NumArray(int[] nums) Initializes the object with the integer array nums.
void update(int index, int val) Updates the value of nums[index] to be val.
int sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive (i.e. nums[left] + nums[left + 1] + ... + nums[right]).
","Example 1:
Input
[""NumArray"", ""sumRange"", ""update"", ""sumRange""]
[[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]
Output
[null, 9, null, 8]

Explanation
NumArray numArray = new NumArray([1, 3, 5]);
numArray.sumRange(0, 2); // return 1 + 3 + 5 = 9
numArray.update(1, 2);   // nums = [1, 2, 5]
numArray.sumRange(0, 2); // return 1 + 2 + 5 = 8
",,False
Best Time to Buy and Sell Stock with Cooldown,"You are given an array prices where prices[i] is the price of a given stock on the ith day.
Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:
After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).
Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).
","Example 1:
Input: prices = [1,2,3,0,2]
Output: 3
Explanation: transactions = [buy, sell, cooldown, buy, sell]
Example 2:
Input: prices = [1]
Output: 0
",,False
Super Ugly Number,"A super ugly number is a positive integer whose prime factors are in the array primes.
Given an integer n and an array of integers primes, return the nth super ugly number.
The nth super ugly number is guaranteed to fit in a 32-bit signed integer.
","Example 1:
Input: n = 12, primes = [2,7,13,19]
Output: 32
Explanation: [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12 super ugly numbers given primes = [2,7,13,19].
Example 2:
Input: n = 1, primes = [2,3,5]
Output: 1
Explanation: 1 has no prime factors, therefore all of its prime factors are in the array primes = [2,3,5].
","class Solution {
public:
    int nthSuperUglyNumber(int n, vector<int>& arr) {
        unordered_map<int,int>mp;
        for(int i=0;i<arr.size();i++)
        {
            mp[arr[i]]=1;
        }
        vector<long long int>dp(n+1,0);
        dp[1]=1;
        long long int temp=0;
        int v;
        for(int i=2;i<=n;i++)
        {
            temp=INT_MAX;
            for(int j=0;j<arr.size();j++)
            {
                long long int count=mp[arr[j]];
                if(temp>(dp[count]*arr[j]))
                {
                    temp=dp[count]*arr[j];
                    v=arr[j];
                }
                else if(temp==(dp[count]*arr[j]))
                {
                    mp[arr[j]]++;
                }
            }
            mp[v]++;
            dp[i]=temp;
        }
        return dp[n];
    }
};",False
Maximum Product of Word Lengths,"Given a string array words, return the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. If no such two words exist, return 0.
","Example 1:
Input: words = [""abcw"",""baz"",""foo"",""bar"",""xtfn"",""abcdef""]
Output: 16
Explanation: The two words can be ""abcw"", ""xtfn"".
Example 2:
Input: words = [""a"",""ab"",""abc"",""d"",""cd"",""bcd"",""abcd""]
Output: 4
Explanation: The two words can be ""ab"", ""cd"".
Example 3:
Input: words = [""a"",""aa"",""aaa"",""aaaa""]
Output: 0
Explanation: No such pair of words.
",,False
Coin Change,"You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.
Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.
You may assume that you have an infinite number of each kind of coin.
","Example 1:
Input: coins = [1,2,5], amount = 11
Output: 3
Explanation: 11 = 5 + 5 + 1
Example 2:
Input: coins = [2], amount = 3
Output: -1
Example 3:
Input: coins = [1], amount = 0
Output: 0
","class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        dp = [0] + ([float('inf')] * amount)
        for i in range(1, amount + 1):
            for coin in coins:
                if coin <= i:
                    dp[i] = min(dp[i], dp[i - coin] + 1)

        if dp[-1] == float('inf'):
            return -1
        return dp[-1]

",True
Wiggle Sort II,"Given an integer array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3]....
You may assume the input array always has a valid answer.
","Example 1:
Input: nums = [1,5,1,1,6,4]
Output: [1,6,1,5,1,4]
Explanation: [1,4,1,5,1,6] is also accepted.
Example 2:
Input: nums = [1,3,2,2,3,1]
Output: [2,3,1,3,1,2]
","class Solution {
public:
    void wiggleSort(vector<int>& nums) {

               priority_queue<int> pq;
       for(int i =0;i<nums.size();i++){
           pq.push(nums[i]);
             
         }
        for(int i =1;i<nums.size();i+=2){
            nums[i]= pq.top();
            pq.pop();
        }
        for(int i =0;i<nums.size();i+=2){
            nums[i]= pq.top();
            pq.pop();
        }
    }
};",False
Increasing Triplet Subsequence,"Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. If no such indices exists, return false.
","Example 1:
Input: nums = [1,2,3,4,5]
Output: true
Explanation: Any triplet where i < j < k is valid.
Example 2:
Input: nums = [5,4,3,2,1]
Output: false
Explanation: No triplet exists.
Example 3:
Input: nums = [2,1,5,0,4,6]
Output: true
Explanation: The triplet (3, 4, 5) is valid because nums[3] == 0 < nums[4] == 4 < nums[5] == 6.
",,False
Top K Frequent Elements,"Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.
","Example 1:
Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]
Example 2:
Input: nums = [1], k = 1
Output: [1]
",,False
Intersection of Two Arrays,"Given two integer arrays nums1 and nums2, return an array of their
intersection
. Each element in the result must be unique and you may return the result in any order.
","Example 1:
Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2]
Example 2:
Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [9,4]
Explanation: [4,9] is also accepted.
","class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_map<int,int> mpp;
        for(auto i:nums1) {
            if(mpp[i]==0) {
                mpp[i]++;
            }
        }
        vector<int> result;
        for(auto i:nums2) {
            if(mpp[i]==1) {
                result.push_back(i);
                mpp[i]--;
            }
        } 
        return result; 
    }
};",False
Intersection of Two Arrays II,"Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.
","Example 1:
Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2,2]
Example 2:
Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [4,9]
Explanation: [9,4] is also accepted.
",,False
Largest Divisible Subset,"Given a set of distinct positive integers nums, return the largest subset answer such that every pair (answer[i], answer[j]) of elements in this subset satisfies:
answer[i] % answer[j] == 0, or
answer[j] % answer[i] == 0
If there are multiple solutions, return any of them.
","Example 1:
Input: nums = [1,2,3]
Output: [1,2]
Explanation: [1,3] is also accepted.
Example 2:
Input: nums = [1,2,4,8]
Output: [1,2,4,8]
","class Solution:
    def largestDivisibleSubset(self, nums: List[int]) -> List[int]:
        nums.sort()
        n=len(nums)
        if n<2:
            return nums
        ans=[ [num] for num in nums]   
        for i in range(n):
            for j in range(i):
                if nums[i]%nums[j]==0 and len(ans[i])<len(ans[j])+1:
                    ans[i]=ans[j]+[nums[i]]
        return max(ans,key=lambda x:len(x))             ",True
Find K Pairs with Smallest Sums,"You are given two integer arrays nums1 and nums2 sorted in non-decreasing order and an integer k.
Define a pair (u, v) which consists of one element from the first array and one element from the second array.
Return the k pairs (u1, v1), (u2, v2), ..., (uk, vk) with the smallest sums.
","Example 1:
Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3
Output: [[1,2],[1,4],[1,6]]
Explanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]
Example 2:
Input: nums1 = [1,1,2], nums2 = [1,2,3], k = 2
Output: [[1,1],[1,1]]
Explanation: The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]
","class Solution:
    def kSmallestPairs(self, nums1: list[int], nums2: list[int], k: int) -> list[list[int]]:
        n1, n2 = len(nums1), len(nums2)
        sumsq = [(nums1[i] + nums2[0], i, 0) for i in range(n1)]
        heapify(sumsq)
        
        smallest = []
        for _ in range(min(k, n1 * n2)):
            sum_, i, j = heappop(sumsq)
            smallest.append([nums1[i], nums2[j]])
            if j + 1 < n2: heappush(sumsq, (nums1[i] + nums2[j + 1], i, j + 1))
        
        return smallest

",True
Wiggle Subsequence,"A wiggle sequence is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences.
For example, [1, 7, 4, 9, 2, 5] is a wiggle sequence because the differences (6, -3, 5, -7, 3) alternate between positive and negative.
In contrast, [1, 4, 7, 2, 5] and [1, 7, 4, 5, 5] are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero.
A subsequence is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.
Given an integer array nums, return the length of the longest wiggle subsequence of nums.
","Example 1:
Input: nums = [1,7,4,9,2,5]
Output: 6
Explanation: The entire sequence is a wiggle sequence with differences (6, -3, 5, -7, 3).
Example 2:
Input: nums = [1,17,5,10,13,15,10,5,16,8]
Output: 7
Explanation: There are several subsequences that achieve this length.
One is [1, 17, 10, 13, 10, 16, 8] with differences (16, -7, 3, -3, 6, -8).
Example 3:
Input: nums = [1,2,3,4,5,6,7,8,9]
Output: 2
","class Solution {
public:
    int wiggleMaxLength(vector<int>& N) {
        int len = N.size(), i = 1, ans = 1;
        while (i < len && N[i] == N[i-1]) i++;
        if (i == len) return 1;
        bool up = N[i-1] > N[i];
        for (; i < len; i++)
            if ((up && N[i] < N[i-1]) || (!up && N[i] > N[i-1]))
                up = !up, ans++;
        return ans;
    }
};",False
Combination Sum IV,"Given an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to target.
The test cases are generated so that the answer can fit in a 32-bit integer.
","Example 1:
Input: nums = [1,2,3], target = 4
Output: 7
Explanation:
The possible combination ways are:
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
Note that different sequences are counted as different combinations.
Example 2:
Input: nums = [9], target = 3
Output: 0
","class Solution {
public:
    int combinationSum4(vector<int>& N, int T) {
        vector<unsigned int> dp(T+1, 0);
        dp[0] = 1;
        for (int i = 0; i < T; i++) {
            if (!dp[i]) continue;
            for (int num : N)
                if (num + i <= T) dp[i+num] += dp[i];
        }
        return dp[T];
    }
};",False
Kth Smallest Element in a Sorted Matrix,"Given an n x n matrix where each of the rows and columns is sorted in ascending order, return the kth smallest element in the matrix.
Note that it is the kth smallest element in the sorted order, not the kth distinct element.
You must find a solution with a memory complexity better than O(n2).
","Example 1:
Input: matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8
Output: 13
Explanation: The elements in the matrix are [1,5,9,10,11,12,13,13,15], and the 8th smallest number is 13
Example 2:
Input: matrix = [[-5]], k = 1
Output: -5
",,False
Insert Delete GetRandom O(1),"Implement the RandomizedSet class:
RandomizedSet() Initializes the RandomizedSet object.
bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise.
bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise.
int getRandom() Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned.
You must implement the functions of the class such that each function works in average O(1) time complexity.
","Example 1:
Input
[""RandomizedSet"", ""insert"", ""remove"", ""insert"", ""getRandom"", ""remove"", ""insert"", ""getRandom""]
[[], [1], [2], [2], [], [1], [2], []]
Output
[null, true, false, true, 2, true, false, 2]

Explanation
RandomizedSet randomizedSet = new RandomizedSet();
randomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.
randomizedSet.remove(2); // Returns false as 2 does not exist in the set.
randomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].
randomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.
randomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].
randomizedSet.insert(2); // 2 was already in the set, so return false.
randomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.
",,False
Shuffle an Array,"Given an integer array nums, design an algorithm to randomly shuffle the array. All permutations of the array should be equally likely as a result of the shuffling.
Implement the Solution class:
Solution(int[] nums) Initializes the object with the integer array nums.
int[] reset() Resets the array to its original configuration and returns it.
int[] shuffle() Returns a random shuffling of the array.
","Example 1:
Input
[""Solution"", ""shuffle"", ""reset"", ""shuffle""]
[[[1, 2, 3]], [], [], []]
Output
[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]

Explanation
Solution solution = new Solution([1, 2, 3]);
solution.shuffle();    // Shuffle the array [1,2,3] and return its result.
                       // Any permutation of [1,2,3] must be equally likely to be returned.
                       // Example: return [3, 1, 2]
solution.reset();      // Resets the array back to its original configuration [1,2,3]. Return [1, 2, 3]
solution.shuffle();    // Returns the random shuffling of array [1,2,3]. Example: return [1, 3, 2]
",,False
UTF-8 Validation,"Given an integer array data representing the data, return whether it is a valid UTF-8 encoding (i.e. it translates to a sequence of valid UTF-8 encoded characters).
A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:
For a 1-byte character, the first bit is a 0, followed by its Unicode code.
For an n-bytes character, the first n bits are all one's, the n + 1 bit is 0, followed by n - 1 bytes with the most significant 2 bits being 10.
This is how the UTF-8 encoding would work:
     Number of Bytes   |        UTF-8 Octet Sequence
                       |              (binary)
   --------------------+-----------------------------------------
            1          |   0xxxxxxx
            2          |   110xxxxx 10xxxxxx
            3          |   1110xxxx 10xxxxxx 10xxxxxx
            4          |   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
x denotes a bit in the binary form of a byte that may be either 0 or 1.
Note: The input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data.
","Example 1:
Input: data = [197,130,1]
Output: true
Explanation: data represents the octet sequence: 11000101 10000010 00000001.
It is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.
Example 2:
Input: data = [235,140,4]
Output: false
Explanation: data represented the octet sequence: 11101011 10001100 00000100.
The first 3 bits are all one's and the 4th bit is 0 means it is a 3-bytes character.
The next byte is a continuation byte which starts with 10 and that's correct.
But the second continuation byte does not start with 10, so it is invalid.
",,False
Rotate Function,"You are given an integer array nums of length n.
Assume arrk to be an array obtained by rotating nums by k positions clock-wise. We define the rotation function F on nums as follow:
F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1].
Return the maximum value of F(0), F(1), ..., F(n-1).
The test cases are generated so that the answer fits in a 32-bit integer.
","Example 1:
Input: nums = [4,3,2,6]
Output: 26
Explanation:
F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25
F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16
F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23
F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26
So the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26.
Example 2:
Input: nums = [100]
Output: 0
","class Solution {
public:
    int maxRotateFunction(vector<int>& nums) {
        int n=nums.size();
        int sum=0;
        int curr=0;
        for(int i=0;i<n;i++)
        {
            curr+=i*nums[i];
            sum+=nums[i];
        }
        int res=curr;
        for(int i=0;i<n;i++)
        {
            // remove the last item n times (as 1 times it is also added in sum && n-1 for index)
            curr-=n*nums[n-i-1];
            curr+=sum;
            res=max(res,curr);
        }
        return res;
    }
};",False
Evaluate Division,"You are given an array of variable pairs equations and an array of real numbers values, where equations[i] = [Ai, Bi] and values[i] represent the equation Ai / Bi = values[i]. Each Ai or Bi is a string that represents a single variable.
You are also given some queries, where queries[j] = [Cj, Dj] represents the jth query where you must find the answer for Cj / Dj = ?.
Return the answers to all queries. If a single answer cannot be determined, return -1.0.
Note: The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.
Note: The variables that do not occur in the list of equations are undefined, so the answer cannot be determined for them.
","Example 1:
Input: equations = [[""a"",""b""],[""b"",""c""]], values = [2.0,3.0], queries = [[""a"",""c""],[""b"",""a""],[""a"",""e""],[""a"",""a""],[""x"",""x""]]
Output: [6.00000,0.50000,-1.00000,1.00000,-1.00000]
Explanation: 
Given: a / b = 2.0, b / c = 3.0
queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? 
return: [6.0, 0.5, -1.0, 1.0, -1.0 ]
note: x is undefined => -1.0
Example 2:
Input: equations = [[""a"",""b""],[""b"",""c""],[""bc"",""cd""]], values = [1.5,2.5,5.0], queries = [[""a"",""c""],[""c"",""b""],[""bc"",""cd""],[""cd"",""bc""]]
Output: [3.75000,0.40000,5.00000,0.20000]
Example 3:
Input: equations = [[""a"",""b""]], values = [0.5], queries = [[""a"",""b""],[""b"",""a""],[""a"",""c""],[""x"",""y""]]
Output: [0.50000,2.00000,-1.00000,-1.00000]
","class Solution:
    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:
        denom_list = []
        value_list = []
        atoi_dict = dict()

        def atoi(c):
            if c not in atoi_dict:
                atoi_dict[c] = len(atoi_dict)
                value_list.append(1)
                denom_list.append(len(denom_list))
            return atoi_dict[c]

        def find(c): # return it's union head and c/head
            i = c
            if i == denom_list[i]:
                return (i, 1)
            else:
                head, c_d_head = find(denom_list[i])
                c_d_head *= value_list[i]
                denom_list[i] = head
                value_list[i] = c_d_head
                return (head, c_d_head)

        def union(a, b, a_d_b):
            ia_head, a_d_head = find(a)
            ib_head, b_d_head = find(b)
            if ia_head == ib_head:
                return
            else:
                denom_list[ia_head] = ib_head
                value_list[ia_head] = a_d_b / a_d_head * b_d_head
                return
        
        def query(a, b): # return a/b
            if value_list[a] == 0:
                return 0

            ia_head, a_d_head = find(a)
            ib_head, b_d_head = find(b)
            
            if ia_head == ib_head:
                return a_d_head/b_d_head
            else:
                return -1

        for i in range(len(equations)):
            a, b = equations[i]
            value = values[i]
            if value == 0:
                value_list[atoi(a)] = 0
                denom_list[atoi(a)] = atoi(a)
            else:
                union(atoi(a), atoi(b), value)

        ans = []
        for i in range(len(queries)):
            a, b = queries[i]
            if a not in atoi_dict or b not in atoi_dict:
                ans.append(-1)
            else:
                ans.append(query(atoi_dict[a], atoi_dict[b]))

        return ans
",True
Queue Reconstruction by Height,"You are given an array of people, people, which are the attributes of some people in a queue (not necessarily in order). Each people[i] = [hi, ki] represents the ith person of height hi with exactly ki other people in front who have a height greater than or equal to hi.
Reconstruct and return the queue that is represented by the input array people. The returned queue should be formatted as an array queue, where queue[j] = [hj, kj] is the attributes of the jth person in the queue (queue[0] is the person at the front of the queue).
","Example 1:
Input: people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
Output: [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
Explanation:
Person 0 has height 5 with no other people taller or the same height in front.
Person 1 has height 7 with no other people taller or the same height in front.
Person 2 has height 5 with two persons taller or the same height in front, which is person 0 and 1.
Person 3 has height 6 with one person taller or the same height in front, which is person 1.
Person 4 has height 4 with four people taller or the same height in front, which are people 0, 1, 2, and 3.
Person 5 has height 7 with one person taller or the same height in front, which is person 1.
Hence [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] is the reconstructed queue.
Example 2:
Input: people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]
Output: [[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]
",,False
Arithmetic Slices,"An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.
For example, [1,3,5,7,9], [7,7,7,7], and [3,-1,-5,-9] are arithmetic sequences.
Given an integer array nums, return the number of arithmetic subarrays of nums.
A subarray is a contiguous subsequence of the array.
","Example 1:
Input: nums = [1,2,3,4]
Output: 3
Explanation: We have 3 arithmetic slices in nums: [1, 2, 3], [2, 3, 4] and [1,2,3,4] itself.
Example 2:
Input: nums = [1]
Output: 0
",,False
Third Maximum Number,"Given an integer array nums, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number.
","Example 1:
Input: nums = [3,2,1]
Output: 1
Explanation:
The first distinct maximum is 3.
The second distinct maximum is 2.
The third distinct maximum is 1.
Example 2:
Input: nums = [1,2]
Output: 2
Explanation:
The first distinct maximum is 2.
The second distinct maximum is 1.
The third distinct maximum does not exist, so the maximum (2) is returned instead.
Example 3:
Input: nums = [2,2,3,1]
Output: 1
Explanation:
The first distinct maximum is 3.
The second distinct maximum is 2 (both 2's are counted together since they have the same value).
The third distinct maximum is 1.
","class Solution {
public:
    int thirdMax(vector<int>& nums) {
        long long mx1 = LLONG_MIN, mx2 = LLONG_MIN, mx3 = LLONG_MIN;
        for (int num : nums) {
            if (num > mx1) {
                mx3 = mx2;
                mx2 = mx1;
                mx1 = num;
            } else if (num < mx1 && num > mx2) {
                mx3 = mx2;
                mx2 = num;
            } else if (num < mx2 && num > mx3) {
                mx3 = num;
            }
        }
        return mx3 == LLONG_MIN ? mx1 : mx3;
    }
};
",False
Partition Equal Subset Sum,"Given an integer array nums, return true if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or false otherwise.
","Example 1:
Input: nums = [1,5,11,5]
Output: true
Explanation: The array can be partitioned as [1, 5, 5] and [11].
Example 2:
Input: nums = [1,2,3,5]
Output: false
Explanation: The array cannot be partitioned into equal sum subsets.
","class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        for (auto a : nums) // Sum up the array
            sum += a;
        
        if (sum % 2) // If the sum is odd - we can never find two equal partitions
            return false;
        
        sum /= 2;
        vector<bool> dp(sum+1, false); // dp keeps for each number if it has a subset or not
        dp[0] = true;
        
        for (auto a : nums) {
            for (int i = sum; i >= a; i--) {
                dp[i] = dp[i] || dp[i-a]; // for each number, either we use it or we don't
            } 
        }
        return dp[sum];
    }
};",False
Pacific Atlantic Water Flow,"There is an m x n rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.
The island is partitioned into a grid of square cells. You are given an m x n integer matrix heights where heights[r][c] represents the height above sea level of the cell at coordinate (r, c).
The island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is less than or equal to the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.
Return a 2D list of grid coordinates result where result[i] = [ri, ci] denotes that rain water can flow from cell (ri, ci) to both the Pacific and Atlantic oceans.
","Example 1:

Input: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]
Output: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]
Explanation: The following cells can flow to the Pacific and Atlantic oceans, as shown below:
[0,4]: [0,4] -> Pacific Ocean 
       [0,4] -> Atlantic Ocean
[1,3]: [1,3] -> [0,3] -> Pacific Ocean 
       [1,3] -> [1,4] -> Atlantic Ocean
[1,4]: [1,4] -> [1,3] -> [0,3] -> Pacific Ocean 
       [1,4] -> Atlantic Ocean
[2,2]: [2,2] -> [1,2] -> [0,2] -> Pacific Ocean 
       [2,2] -> [2,3] -> [2,4] -> Atlantic Ocean
[3,0]: [3,0] -> Pacific Ocean 
       [3,0] -> [4,0] -> Atlantic Ocean
[3,1]: [3,1] -> [3,0] -> Pacific Ocean 
       [3,1] -> [4,1] -> Atlantic Ocean
[4,0]: [4,0] -> Pacific Ocean 
       [4,0] -> Atlantic Ocean
Note that there are other possible paths for these cells to flow to the Pacific and Atlantic oceans.
Example 2:
Input: heights = [[1]]
Output: [[0,0]]
Explanation: The water can flow from the only cell to the Pacific and Atlantic oceans.
",,False
Battleships in a Board,"Given an m x n matrix board where each cell is a battleship 'X' or empty '.', return the number of the battleships on board.
Battleships can only be placed horizontally or vertically on board. In other words, they can only be made of the shape 1 x k (1 row, k columns) or k x 1 (k rows, 1 column), where k can be of any size. At least one horizontal or vertical cell separates between two battleships (i.e., there are no adjacent battleships).
","Example 1:

Input: board = [[""X"",""."",""."",""X""],[""."",""."",""."",""X""],[""."",""."",""."",""X""]]
Output: 2
Example 2:
Input: board = [["".""]]
Output: 0
","class Solution {
public:
    int countBattleships(vector<vector<char>>& grid) {
      int n=grid.size();
        int m=grid[0].size();
        int count=0;
        for(int i=0;i<n;i++)
        { for(int j=0;j<m;j++)
            {
                 if(grid[i][j]=='X')
            {  dfs(grid,i,j);
                count++;
            }
        }
            
        }
        return count;
    }
    
    void dfs(vector<vector<char>>& grid,int i,int j)
    {
        int n=grid.size();
        int m=grid[0].size();
        if(i<0 || j<0 || i>=n || j>=m || grid[i][j]!='X')
            return ;
        grid[i][j]='Y';
        dfs(grid,i+1,j);
        dfs(grid,i,j+1);
        
    }
};",False
Maximum XOR of Two Numbers in an Array,"Given an integer array nums, return the maximum result of nums[i] XOR nums[j], where 0 <= i <= j < n.
","Example 1:
Input: nums = [3,10,5,25,2,8]
Output: 28
Explanation: The maximum result is 5 XOR 25 = 28.
Example 2:
Input: nums = [14,70,53,83,49,91,36,80,92,51,66,70]
Output: 127
","class Solution {

	//this solution gets from discussion
	public int findMaximumXOR(int[] nums) {

		int result = 0;
		int mask = 0;

		//let's check every possible positive integer number
		for(int i=31;i>=0;i--){

			//mask start from most significant bit-1, 01000...00,->01100...00,->>>>>> 01111...11
			mask = mask | (1<<i);

			//we have already had a result,just make result's effective bit position extend to right one more
			//for example : 0110100..00 is result,let's check if 0110110..00 is the result
			//let's check is the candidateResult possible? 
			int candidateResult = result | (1<<i);  //(candidateResult as a result candidate)

			//record all prefixes(we only need to operate the specific bit positions)
			HashSet<Integer> set = new HashSet<>();
			for(int num : nums){
				set.add(num & mask);
			}

			//let's check evey prefix
			for(int prefix : set){

				//so..if candidateResult is the existed result, how could that happen?
				//the tricky viewpoint is:
				//A^B = candidateResult <=> B^candidateResult = A
				if(set.contains(candidateResult^prefix)){

					//it is possible, so store this result
					result = candidateResult;
					break;
				}
			}
		}
		return result;
	}
}",False
Non-overlapping Intervals,"Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.
","Example 1:
Input: intervals = [[1,2],[2,3],[3,4],[1,3]]
Output: 1
Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.
Example 2:
Input: intervals = [[1,2],[1,2],[1,2]]
Output: 2
Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.
Example 3:
Input: intervals = [[1,2],[2,3]]
Output: 0
Explanation: You don't need to remove any of the intervals since they're already non-overlapping.
","class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        intervals.sort(key = lambda x : x[1])
        ans = 0
        prev = intervals[0]
        for interval in intervals:
            if interval[0] < prev[1]:
                ans += 1
            else:
                prev = interval
        return ans - 1",True
Find Right Interval,"You are given an array of intervals, where intervals[i] = [starti, endi] and each starti is unique.
The right interval for an interval i is an interval j such that startj >= endi and startj is minimized. Note that i may equal j.
Return an array of right interval indices for each interval i. If no right interval exists for interval i, then put -1 at index i.
","Example 1:
Input: intervals = [[1,2]]
Output: [-1]
Explanation: There is only one interval in the collection, so it outputs -1.
Example 2:
Input: intervals = [[3,4],[2,3],[1,2]]
Output: [-1,0,1]
Explanation: There is no right interval for [3,4].
The right interval for [2,3] is [3,4] since start0 = 3 is the smallest start that is >= end1 = 3.
The right interval for [1,2] is [2,3] since start1 = 2 is the smallest start that is >= end2 = 2.
Example 3:
Input: intervals = [[1,4],[2,3],[3,4]]
Output: [-1,2,-1]
Explanation: There is no right interval for [1,4] and [3,4].
The right interval for [2,3] is [3,4] since start2 = 3 is the smallest start that is >= end1 = 3.
",,False
Find All Duplicates in an Array,"Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears once or twice, return an array of all the integers that appears twice.
You must write an algorithm that runs in O(n) time and uses only constant extra space.
","Example 1:
Input: nums = [4,3,2,7,8,2,3,1]
Output: [2,3]
Example 2:
Input: nums = [1,1,2]
Output: [1]
Example 3:
Input: nums = [1]
Output: []
","class Solution:
    def findDuplicates(self, nums: List[int]) -> List[int]:
        n = len(nums)
        count = 0
        for i in range(n):
            if nums[abs(nums[i]) - 1] > 0:
                nums[abs(nums[i]) - 1] = -nums[abs(nums[i]) - 1]
            else:
                nums.append(abs(nums[i]))
                count += 1
        for i in range(count):
            nums[i] = nums.pop()
        for i in range(n - count):
            nums.pop()
        return nums
",True
Number of Boomerangs,"You are given n points in the plane that are all distinct, where points[i] = [xi, yi]. A boomerang is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters).
Return the number of boomerangs.
","Example 1:
Input: points = [[0,0],[1,0],[2,0]]
Output: 2
Explanation: The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]].
Example 2:
Input: points = [[1,1],[2,2],[3,3]]
Output: 2
Example 3:
Input: points = [[1,1]]
Output: 0
","class Solution:
    def numberOfBoomerangs(self, points: List[List[int]]) -> int:
        def distance(p1, p2):
            return (p1[0]-p2[0])**2 + (p1[1]-p2[1])**2
        result = 0
        distanceMap = {}
        for A in points:
            for B in points:
                if A == B:
                    continue
                d = distance(A, B)
                key = (A[0], A[1], d)
                if distanceMap.get(key):
                    distanceMap[key] += 1
                else:
                    distanceMap[key] = 1
        for i, v in distanceMap.items():
            if v > 1:
                # order matters so formula will 
                # n * (n-1)
                # because we have one fix number that is i
                # so only have to arrange two numbers among v element
                # so it will be v! / (v-2) ! --> v*(v-1)
                result += v * (v-1)
            
                
            
        return result
                ",True
Find All Numbers Disappeared in an Array,"Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.
","Example 1:
Input: nums = [4,3,2,7,8,2,3,1]
Output: [5,6]
Example 2:
Input: nums = [1,1]
Output: [2]
",,False
Minimum Number of Arrows to Burst Balloons,"There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons.
Arrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart <= x <= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.
Given the array points, return the minimum number of arrows that must be shot to burst all balloons.
","Example 1:
Input: points = [[10,16],[2,8],[1,6],[7,12]]
Output: 2
Explanation: The balloons can be burst by 2 arrows:
- Shoot an arrow at x = 6, bursting the balloons [2,8] and [1,6].
- Shoot an arrow at x = 11, bursting the balloons [10,16] and [7,12].
Example 2:
Input: points = [[1,2],[3,4],[5,6],[7,8]]
Output: 4
Explanation: One arrow needs to be shot for each balloon for a total of 4 arrows.
Example 3:
Input: points = [[1,2],[2,3],[3,4],[4,5]]
Output: 2
Explanation: The balloons can be burst by 2 arrows:
- Shoot an arrow at x = 2, bursting the balloons [1,2] and [2,3].
- Shoot an arrow at x = 4, bursting the balloons [3,4] and [4,5].
","class Solution(object):
    def findMinArrowShots(self, points):
        points.sort(key=lambda x: x[0])
        arrows = 1
        end = points[0][1]
        
        for balloon in points[1:]:
            if balloon[0] > end: 
                arrows += 1  
                end = balloon[1] 
            else:
                end = min(end, balloon[1])
        
        return arrows",True
Minimum Moves to Equal Array Elements,"Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal.
In one move, you can increment n - 1 elements of the array by 1.
","Example 1:
Input: nums = [1,2,3]
Output: 3
Explanation: Only three moves are needed (remember each move increments two elements):
[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]
Example 2:
Input: nums = [1,1,1]
Output: 0
","class Solution {
public:
    int minMoves(vector<int>& nums) {
        
        int n = nums.size();
        sort(nums.begin(),nums.end()); // now the minimum element is at 0th index
        int minimum_element = nums[0];
        int answer = 0;
        
        for(int i=n-1; i>=0; i--)
        {
            answer += (nums[i] - minimum_element);
        }
        
        return answer;
    }
};",False
4Sum II,"Given four integer arrays nums1, nums2, nums3, and nums4 all of length n, return the number of tuples (i, j, k, l) such that:
0 <= i, j, k, l < n
nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0
","Example 1:
Input: nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
Output: 2
Explanation:
The two tuples are:
1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0
Example 2:
Input: nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]
Output: 1
","class Solution {
public:
    // This solution uses a hash map to store the sums of all possible pairs of elements from nums1 and nums2. Then, for each pair of elements from nums3 and nums4, it checks if the negative of the sum is present in the hash map, and if it is, it increments the count by the number of occurrences of that sum in the map.
    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
       int ans=0;
        unordered_map<int,int>mp;
        for(int i=0;i<nums1.size();i++){
            for(int j=0;j<nums1.size();j++){
               mp[nums1[i]+nums2[j]]++;
            }
        }
        for(int i=0;i<nums1.size();i++){
            for(int j=0;j<nums1.size();j++)
            {
                int sum=-(nums3[i]+nums4[j]);
                ans+=mp[sum];
            }
        }
        return ans;
    }
};",False
Assign Cookies,"Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.
Each child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] >= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.
","Example 1:
Input: g = [1,2,3], s = [1,1]
Output: 1
Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. 
And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.
You need to output 1.
Example 2:
Input: g = [1,2], s = [1,2,3]
Output: 2
Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. 
You have 3 cookies and their sizes are big enough to gratify all of the children, 
You need to output 2.
","class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        
        return g.sort() or reduce(lambda k, c: k + (k < len(g) and g[k] <= c), sorted(s), 0)",True
132 Pattern,"Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i < j < k and nums[i] < nums[k] < nums[j].
Return true if there is a 132 pattern in nums, otherwise, return false.
","Example 1:
Input: nums = [1,2,3,4]
Output: false
Explanation: There is no 132 pattern in the sequence.
Example 2:
Input: nums = [3,1,4,2]
Output: true
Explanation: There is a 132 pattern in the sequence: [1, 4, 2].
Example 3:
Input: nums = [-1,3,2,0]
Output: true
Explanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].
",,False
Circular Array Loop,"You are playing a game involving a circular array of non-zero integers nums. Each nums[i] denotes the number of indices forward/backward you must move if you are located at index i:
If nums[i] is positive, move nums[i] steps forward, and
If nums[i] is negative, move nums[i] steps backward.
Since the array is circular, you may assume that moving forward from the last element puts you on the first element, and moving backwards from the first element puts you on the last element.
A cycle in the array consists of a sequence of indices seq of length k where:
Following the movement rules above results in the repeating index sequence seq[0] -> seq[1] -> ... -> seq[k - 1] -> seq[0] -> ...
Every nums[seq[j]] is either all positive or all negative.
k > 1
Return true if there is a cycle in nums, or false otherwise.
","Example 1:

Input: nums = [2,-1,1,2,2]
Output: true
Explanation: The graph shows how the indices are connected. White nodes are jumping forward, while red is jumping backward.
We can see the cycle 0 --> 2 --> 3 --> 0 --> ..., and all of its nodes are white (jumping in the same direction).
Example 2:

Input: nums = [-1,-2,-3,-4,-5,6]
Output: false
Explanation: The graph shows how the indices are connected. White nodes are jumping forward, while red is jumping backward.
The only cycle is of size 1, so we return false.
Example 3:

Input: nums = [1,-1,5,1,4]
Output: true
Explanation: The graph shows how the indices are connected. White nodes are jumping forward, while red is jumping backward.
We can see the cycle 0 --> 1 --> 0 --> ..., and while it is of size > 1, it has a node jumping forward and a node jumping backward, so it is not a cycle.
We can see the cycle 3 --> 4 --> 3 --> ..., and all of its nodes are white (jumping in the same direction).
","class Solution {
    public boolean circularArrayLoop(int[] nums) {
        for(int i=0; i<nums.length; i++) {
            boolean frontDirection = nums[i]>=0;
            
            int currentPosition = i;
            int fastPosition = i;
            
            while(true) {
                currentPosition = getNextPosition(nums, currentPosition, frontDirection);
                
                if(currentPosition==-1) {
                    break;
                }
                
                fastPosition = getNextPosition(nums, fastPosition, frontDirection);
                
                if(fastPosition==-1) {
                    break;
                }
                
                fastPosition = getNextPosition(nums, fastPosition, frontDirection);
                
                if(fastPosition==-1) {
                    break;
                }
                
                if(currentPosition == fastPosition) {
                    return true;
                }
                
            }
            
        }
        return false;
    }

    public  int getNextPosition(int[] nums, int index, boolean frontDirection) {
        
        
        int nextIndex = (nums[index] + index)%nums.length;
        if(nextIndex<0) {
            nextIndex = nums.length + nextIndex;
        }
        
        if(index==nextIndex) {
            return -1;
        }
        
        boolean direction =  nums[nextIndex]>=0;
        
        if(direction!=frontDirection) {
            return -1;
        }
        
        return nextIndex;
    }
}",False
Minimum Moves to Equal Array Elements II,"Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal.
In one move, you can increment or decrement an element of the array by 1.
Test cases are designed so that the answer will fit in a 32-bit integer.
","Example 1:
Input: nums = [1,2,3]
Output: 2
Explanation:
Only two moves are needed (remember each move increments or decrements one element):
[1,2,3]  =>  [2,2,3]  =>  [2,2,2]
Example 2:
Input: nums = [1,10,2,9]
Output: 16
","class Solution {
    public int minMoves2(int[] nums) {
        Arrays.sort(nums);
        int ans = 0, median = nums[nums.length / 2];
        for (int num : nums) ans += Math.abs(median - num);
        return ans;
    }
}",False
Island Perimeter,"You are given row x col grid representing a map where grid[i][j] = 1 represents land and grid[i][j] = 0 represents water.
Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).
The island doesn't have ""lakes"", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.
","Example 1:

Input: grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]
Output: 16
Explanation: The perimeter is the 16 yellow stripes in the image above.
Example 2:
Input: grid = [[1]]
Output: 4
Example 3:
Input: grid = [[1,0]]
Output: 4
","class Solution:
    def islandPerimeter(self, grid: List[List[int]]) -> int:
        parimeter = 0

        rows , cols = len(grid)  , len(grid[0]) 

        for i in range(rows):
            for j in range(cols):
                # pre , nex , up , down = 0 , 0 , 0 , 0
                taken = 0
                if j > 0:
                    # pre = grid[i][j - 1]
                    taken += grid[i][j - 1]
                if j < cols - 1:
                    # nex = grid[i][j + 1]
                    taken += grid[i][j + 1]
                if i > 0:
                    # up = grid[i - 1][j]
                    taken += grid[i - 1][j]
                if i < rows - 1:
                    # down = grid[i + 1][j]
                    taken += grid[i + 1][j]
                if grid[i][j]:
                    # parimeter += 4 - pre - nex - up - down
                    parimeter += 4 - taken
        return parimeter ",True
Matchsticks to Square,"You are given an integer array matchsticks where matchsticks[i] is the length of the ith matchstick. You want to use all the matchsticks to make one square. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.
Return true if you can make this square and false otherwise.
","Example 1:

Input: matchsticks = [1,1,2,2,2]
Output: true
Explanation: You can form a square with length 2, one side of the square came two sticks with length 1.
Example 2:
Input: matchsticks = [3,3,3,3,4]
Output: false
Explanation: You cannot find a way to form a square with all the matchsticks.
",,False
Ones and Zeroes,"You are given an array of binary strings strs and two integers m and n.
Return the size of the largest subset of strs such that there are at most m 0's and n 1's in the subset.
A set x is a subset of a set y if all elements of x are also elements of y.
","Example 1:
Input: strs = [""10"",""0001"",""111001"",""1"",""0""], m = 5, n = 3
Output: 4
Explanation: The largest subset with at most 5 0's and 3 1's is {""10"", ""0001"", ""1"", ""0""}, so the answer is 4.
Other valid but smaller subsets include {""0001"", ""1""} and {""10"", ""1"", ""0""}.
{""111001""} is an invalid subset because it contains 4 1's, greater than the maximum of 3.
Example 2:
Input: strs = [""10"",""0"",""1""], m = 1, n = 1
Output: 2
Explanation: The largest subset is {""0"", ""1""}, so the answer is 2.
",,False
Heaters,"Winter is coming! During the contest, your first job is to design a standard heater with a fixed warm radius to warm all the houses.
Every house can be warmed, as long as the house is within the heater's warm radius range. 
Given the positions of houses and heaters on a horizontal line, return the minimum radius standard of heaters so that those heaters could cover all houses.
Notice that all the heaters follow your radius standard, and the warm radius will the same.
","Example 1:
Input: houses = [1,2,3], heaters = [2]
Output: 1
Explanation: The only heater was placed in the position 2, and if we use the radius 1 standard, then all the houses can be warmed.
Example 2:
Input: houses = [1,2,3,4], heaters = [1,4]
Output: 1
Explanation: The two heaters were placed at positions 1 and 4. We need to use a radius 1 standard, then all the houses can be warmed.
Example 3:
Input: houses = [1,5], heaters = [2]
Output: 3
","class Solution:
    def findRadius(self, houses: List[int], heaters: List[int]) -> int:
        c=0
        houses.sort()
        heaters.sort()
        dist=[]
        for i in houses:
            res=bisect_left(heaters,i)
            if(res==0):
                dist.append(abs(heaters[res]-i))
            elif (res>= len(heaters)):
                dist.append(abs(heaters[-1]-i))
            else:
                dist.append(min(abs(heaters[res]-i),abs(heaters[res-1]-i)))
            
        return max(dist)",True
Total Hamming Distance,"The Hamming distance between two integers is the number of positions at which the corresponding bits are different.
Given an integer array nums, return the sum of Hamming distances between all the pairs of the integers in nums.
","Example 1:
Input: nums = [4,14,2]
Output: 6
Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just
showing the four bits relevant in this case).
The answer will be:
HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.
Example 2:
Input: nums = [4,14,4]
Output: 4
",,False
Max Consecutive Ones,"Given a binary array nums, return the maximum number of consecutive 1's in the array.
","Example 1:
Input: nums = [1,1,0,1,1,1]
Output: 3
Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3.
Example 2:
Input: nums = [1,0,1,1,0,1]
Output: 2
","class Solution:
    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:
        res = []
        l = 0
        for i in nums:
            if i == 1:
                l += 1
            else:
                res.append(l)
                l = 0
        res.append(l)
        return max(res)",True
Predict the Winner,"You are given an integer array nums. Two players are playing a game with this array: player 1 and player 2.
Player 1 and player 2 take turns, with player 1 starting first. Both players start the game with a score of 0. At each turn, the player takes one of the numbers from either end of the array (i.e., nums[0] or nums[nums.length - 1]) which reduces the size of the array by 1. The player adds the chosen number to their score. The game ends when there are no more elements in the array.
Return true if Player 1 can win the game. If the scores of both players are equal, then player 1 is still the winner, and you should also return true. You may assume that both players are playing optimally.
","Example 1:
Input: nums = [1,5,2]
Output: false
Explanation: Initially, player 1 can choose between 1 and 2. 
If he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). 
So, final score of player 1 is 1 + 2 = 3, and player 2 is 5. 
Hence, player 1 will never be the winner and you need to return false.
Example 2:
Input: nums = [1,5,233,7]
Output: true
Explanation: Player 1 first chooses 1. Then player 2 has to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.
Finally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.
",,False
Non-decreasing Subsequences,"Given an integer array nums, return all the different possible non-decreasing subsequences of the given array with at least two elements. You may return the answer in any order.
","Example 1:
Input: nums = [4,6,7,7]
Output: [[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]
Example 2:
Input: nums = [4,4,3,2,1]
Output: [[4,4]]
","class Solution:
    def findSubsequences(self, nums: List[int]) -> List[List[int]]:
        res = []
        memo = defaultdict(int)
        n = len(nums)
        stack = [([nums[i]], i) for i in range(n - 1)]
        while stack:
            candidate, idx = stack.pop(0)
            if len(candidate) >= 2:
                res.append(candidate)
            for i in range(idx + 1, n):
                if nums[i] >= nums[idx]:
                    next_candidate = candidate + [nums[i]]
                    next_candidate_hashed = f'{next_candidate}'
                    if memo[next_candidate_hashed] == 0:
                        memo[next_candidate_hashed] = 1
                        stack.append((next_candidate, i))
        return res



            ",True
Target Sum,"You are given an integer array nums and an integer target.
You want to build an expression out of nums by adding one of the symbols '+' and '-' before each integer in nums and then concatenate all the integers.
For example, if nums = [2, 1], you can add a '+' before 2 and a '-' before 1 and concatenate them to build the expression ""+2-1"".
Return the number of different expressions that you can build, which evaluates to target.
","Example 1:
Input: nums = [1,1,1,1,1], target = 3
Output: 5
Explanation: There are 5 ways to assign symbols to make the sum of nums be target 3.
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
Example 2:
Input: nums = [1], target = 1
Output: 1
",,False
Teemo Attacking,"Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets poisoned for a exactly duration seconds. More formally, an attack at second t will mean Ashe is poisoned during the inclusive time interval [t, t + duration - 1]. If Teemo attacks again before the poison effect ends, the timer for it is reset, and the poison effect will end duration seconds after the new attack.
You are given a non-decreasing integer array timeSeries, where timeSeries[i] denotes that Teemo attacks Ashe at second timeSeries[i], and an integer duration.
Return the total number of seconds that Ashe is poisoned.
","Example 1:
Input: timeSeries = [1,4], duration = 2
Output: 4
Explanation: Teemo's attacks on Ashe go as follows:
- At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.
- At second 4, Teemo attacks, and Ashe is poisoned for seconds 4 and 5.
Ashe is poisoned for seconds 1, 2, 4, and 5, which is 4 seconds in total.
Example 2:
Input: timeSeries = [1,2], duration = 2
Output: 3
Explanation: Teemo's attacks on Ashe go as follows:
- At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.
- At second 2 however, Teemo attacks again and resets the poison timer. Ashe is poisoned for seconds 2 and 3.
Ashe is poisoned for seconds 1, 2, and 3, which is 3 seconds in total.
","class Solution:
    def findPoisonedDuration(self, t: List[int], d: int) -> int:
        return d+sum(min(t[i+1]-t[i], d) for i in range(len(t)-1))",True
Next Greater Element I,"The next greater element of some element x in an array is the first greater element that is to the right of x in the same array.
You are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2.
For each 0 <= i < nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2. If there is no next greater element, then the answer for this query is -1.
Return an array ans of length nums1.length such that ans[i] is the next greater element as described above.
","Example 1:
Input: nums1 = [4,1,2], nums2 = [1,3,4,2]
Output: [-1,3,-1]
Explanation: The next greater element for each value of nums1 is as follows:
- 4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.
- 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3.
- 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.
Example 2:
Input: nums1 = [2,4], nums2 = [1,2,3,4]
Output: [3,-1]
Explanation: The next greater element for each value of nums1 is as follows:
- 2 is underlined in nums2 = [1,2,3,4]. The next greater element is 3.
- 4 is underlined in nums2 = [1,2,3,4]. There is no next greater element, so the answer is -1.
","class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        # Create a dictionary to store the next greater element of each number in nums2
        next_greater = {}
        # Create a stack to keep track of the elements whose next greater element is not found yet
        stack = []
        
        # Loop through each element in nums2
        for num in nums2:
            # While the stack is not empty and the current number is greater than the top element in the stack
            while stack and num > stack[-1]:
                # Pop the top element from the stack and set its next greater element to the current number
                next_greater[stack.pop()] = num
            # Add the current number to the stack
            stack.append(num)
        
        # Create a list to store the next greater element of each number in nums1
        result = []
        # Loop through each element in nums1
        for num in nums1:
            # If the next greater element of the current number is found
            if num in next_greater:
                # Append it to the result list
                result.append(next_greater[num])
            else:
                # Otherwise, append -1 to the result list
                result.append(-1)
        
        return result
",True
Diagonal Traverse,"Given an m x n matrix mat, return an array of all the elements of the array in a diagonal order.
","Example 1:

Input: mat = [[1,2,3],[4,5,6],[7,8,9]]
Output: [1,2,4,7,5,3,6,8,9]
Example 2:
Input: mat = [[1,2],[3,4]]
Output: [1,2,3,4]
",,False
Keyboard Row,"Given an array of strings words, return the words that can be typed using letters of the alphabet on only one row of American keyboard like the image below.
In the American keyboard:
the first row consists of the characters ""qwertyuiop"",
the second row consists of the characters ""asdfghjkl"", and
the third row consists of the characters ""zxcvbnm"".

","Example 1:
Input: words = [""Hello"",""Alaska"",""Dad"",""Peace""]
Output: [""Alaska"",""Dad""]
Example 2:
Input: words = [""omk""]
Output: []
Example 3:
Input: words = [""adsdf"",""sfd""]
Output: [""adsdf"",""sfd""]
","class Solution {
    public String[] findWords(String[] words) {
        String[] n = new String[words.length];
        int k = 0;
        for(int i = 0; i < words.length; i++){
            int check = row(words[i].charAt(0));
            for(int j = 1; j < words[i].length(); j++){
                if(check != row(words[i].charAt(j))){
                    check = 0;
                    break;
                }
            }
            if(check!=0){
                n[k] = words[i];
                k++;
            }
        }
        String ans[] = new String[k];
        for(int i = 0; i < k; i ++){
            ans[i] = n[i]; 
        }
        return ans;
    }
    public int row(char c){
        c = Character.toLowerCase(c);
        String str1= ""qwertyuiop"";
        String str2= ""asdfghjkl"";
        String str3= ""zxcvbnm"";
        if (str1.contains(String.valueOf(c))){
            return 1;            
        }else if(str2.contains(String.valueOf(c))){
            return 2;
        }else if(str3.contains(String.valueOf(c))){
            return 3;
        }
        return 0;
    }
}",False
Next Greater Element II,"Given a circular integer array nums (i.e., the next element of nums[nums.length - 1] is nums[0]), return the next greater number for every element in nums.
The next greater number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, return -1 for this number.
","Example 1:
Input: nums = [1,2,1]
Output: [2,-1,2]
Explanation: The first 1's next greater number is 2; 
The number 2 can't find next greater number. 
The second 1's next greater number needs to search circularly, which is also 2.
Example 2:
Input: nums = [1,2,3,4,3]
Output: [2,3,4,-1,4]
","class Solution {
public:
    vector<int> nextGreaterElements(vector<int> &nums)
{
    int n = nums.size();
    vector<int> ans;
    stack<int> st;
    for (int i = 2 * n - 1; i >= 0; i--)
    {
        while (!st.empty() and st.top() <= nums[(i % n)])
        {
            st.pop();
        }

        if (i < n)
        {
            if (st.empty())
            {
                ans.push_back(-1);
            }
            else
            {
                ans.push_back(st.top());
            }
        }
        st.push(nums[i % n]);
    }
    reverse(ans.begin(), ans.end());
    return ans;
}
};",False
Relative Ranks,"You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.
The athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:
The 1st place athlete's rank is ""Gold Medal"".
The 2nd place athlete's rank is ""Silver Medal"".
The 3rd place athlete's rank is ""Bronze Medal"".
For the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is ""x"").
Return an array answer of size n where answer[i] is the rank of the ith athlete.
","Example 1:
Input: score = [5,4,3,2,1]
Output: [""Gold Medal"",""Silver Medal"",""Bronze Medal"",""4"",""5""]
Explanation: The placements are [1st, 2nd, 3rd, 4th, 5th].
Example 2:
Input: score = [10,3,8,9,4]
Output: [""Gold Medal"",""5"",""Bronze Medal"",""Silver Medal"",""4""]
Explanation: The placements are [1st, 5th, 3rd, 2nd, 4th].
","class Solution {
public:
    vector<string> findRelativeRanks(vector<int>& score) {
        int lenScore = score.size();
        vector<string> answer(lenScore);
        priority_queue<pair<int, int>>
            maxHeap; // max heap to store scores with indices

        // Fill the heap with scores and their corresponding indices
        for (int i = 0; i < lenScore; ++i) {
            maxHeap.push({score[i], i});
        }

        vector<string> rank = {""Gold Medal"", ""Silver Medal"", ""Bronze Medal""};

        // Assign ranks based on the max heap
        int number = 1;
        while (!maxHeap.empty()) {
            auto top = maxHeap.top();
            maxHeap.pop();
            int index = top.second;
            if (number < 4) {
                answer[index] = rank[number - 1];
            } else {
                answer[index] = to_string(number);
            }
            number++;
        }

        return answer;
    }
};",False
Coin Change II,"You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.
Return the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.
You may assume that you have an infinite number of each kind of coin.
The answer is guaranteed to fit into a signed 32-bit integer.
","Example 1:
Input: amount = 5, coins = [1,2,5]
Output: 4
Explanation: there are four ways to make up the amount:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
Example 2:
Input: amount = 3, coins = [2]
Output: 0
Explanation: the amount of 3 cannot be made up just with coins of 2.
Example 3:
Input: amount = 10, coins = [10]
Output: 1
","class Solution {
public:
  /*
    int  solveMemo( vector<int> & coins, int amount, int index , vector<vector<int>> &dp){

        if( amount == 0) {
            
            return 1;
        }
        if( amount < 0  || index >= coins.size() ) return 0;
       
        if( dp[index][amount]!= -1) return dp[index][amount];

        int take = solveMemo( coins, amount - coins[index], index, dp);
        int dontTake = solveMemo( coins, amount, index + 1, dp);

        dp[index][amount] = take + dontTake;

        return dp[index][amount];
        
    }

    */

    int change(int amount, vector<int>& coins) {
        vector<vector<int>> dp ( coins.size() + 1, vector<int>( amount+1));
        int n = coins.size() ;

        for( int i = 0; i <=n; i++) dp[i][0] = 1;

        for( int i = 1; i <= n; i++ ){

            for( int j = 1; j <= amount; j++ ){
               
                if( coins[i-1] <= j) 
                  dp[i][j] = dp[i][j - coins[i-1]] + dp[i-1][j];

                else {
                    dp[i][j] = dp[i-1][j];
                }
            }
        }
        
        return dp[n][amount];

       
    }
};",False
Longest Uncommon Subsequence II,"Given an array of strings strs, return the length of the longest uncommon subsequence between them. If the longest uncommon subsequence does not exist, return -1.
An uncommon subsequence between an array of strings is a string that is a subsequence of one string but not the others.
A subsequence of a string s is a string that can be obtained after deleting any number of characters from s.
For example, ""abc"" is a subsequence of ""aebdc"" because you can delete the underlined characters in ""aebdc"" to get ""abc"". Other subsequences of ""aebdc"" include ""aebdc"", ""aeb"", and """" (empty string).
","Example 1:
Input: strs = [""aba"",""cdc"",""eae""]
Output: 3
Example 2:
Input: strs = [""aaa"",""aaa"",""aa""]
Output: -1
",,False
Continuous Subarray Sum,"Given an integer array nums and an integer k, return true if nums has a good subarray or false otherwise.
A good subarray is a subarray where:
its length is at least two, and
the sum of the elements of the subarray is a multiple of k.
Note that:
A subarray is a contiguous part of the array.
An integer x is a multiple of k if there exists an integer n such that x = n * k. 0 is always a multiple of k.
","Example 1:
Input: nums = [23,2,4,6,7], k = 6
Output: true
Explanation: [2, 4] is a continuous subarray of size 2 whose elements sum up to 6.
Example 2:
Input: nums = [23,2,6,4,7], k = 6
Output: true
Explanation: [23, 2, 6, 4, 7] is an continuous subarray of size 5 whose elements sum up to 42.
42 is a multiple of 6 because 42 = 7 * 6 and 7 is an integer.
Example 3:
Input: nums = [23,2,6,4,7], k = 13
Output: false
","class Solution {
public:
    bool checkSubarraySum(vector<int>& nums, int k) {
        
  int prefSum = 0;
  
  unordered_map<int, int> mp;
  for(int i=0; i<nums.size(); i++)
  {
    prefSum += nums[i];
    prefSum %= k;

    if(prefSum == 0 && i) return true;

    if(mp.find(prefSum) != mp.end())  // Found the required prefix sum 
    {
      if(i - mp[prefSum] > 1) return true; // check if atleast 2 elements are there or not
    }
    else mp[prefSum] = i;
  }

  return false; 
        
    }
};",False
Longest Word in Dictionary through Deleting,"Given a string s and a string array dictionary, return the longest string in the dictionary that can be formed by deleting some of the given string characters. If there is more than one possible result, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.
","Example 1:
Input: s = ""abpcplea"", dictionary = [""ale"",""apple"",""monkey"",""plea""]
Output: ""apple""
Example 2:
Input: s = ""abpcplea"", dictionary = [""a"",""b"",""c""]
Output: ""a""
",,False
Contiguous Array,"Given a binary array nums, return the maximum length of a contiguous subarray with an equal number of 0 and 1.
","Example 1:
Input: nums = [0,1]
Output: 2
Explanation: [0, 1] is the longest contiguous subarray with an equal number of 0 and 1.
Example 2:
Input: nums = [0,1,0]
Output: 2
Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.
","class Solution:
    def findMaxLength(self, nums: List[int]) -> int:
        first = {0:0}
        curr = 0
        ans = 0
        for i in range(len(nums)):
            curr+=1 if nums[i]==1 else -1
            if curr in first:
                ans = max(ans, i+1-first[curr])
            else:
                first[curr] = i+1
        return ans",True
Beautiful Arrangement,"Suppose you have n integers labeled 1 through n. A permutation of those n integers perm (1-indexed) is considered a beautiful arrangement if for every i (1 <= i <= n), either of the following is true:
perm[i] is divisible by i.
i is divisible by perm[i].
Given an integer n, return the number of the beautiful arrangements that you can construct.
","Example 1:
Input: n = 2
Output: 2
Explanation: 
The first beautiful arrangement is [1,2]:
    - perm[1] = 1 is divisible by i = 1
    - perm[2] = 2 is divisible by i = 2
The second beautiful arrangement is [2,1]:
    - perm[1] = 2 is divisible by i = 1
    - i = 2 is divisible by perm[2] = 1
Example 2:
Input: n = 1
Output: 1
","class Solution {
    public int countArrangement(int n) {
        int[] arr = new int[n + 1];
        int ans = 0;
        ans = countArrangementHelper( n ,  arr ,  ans ,  1);
        return ans;
    }
    private int countArrangementHelper(int n , int[] arr , int ans , int currNum){
        if(currNum == n + 1){
            ++ans;
            return ans;
        }

        for(int i = 1; i <= n ; i++){
            if(arr[i] == 0 && (currNum % i == 0 || i % currNum == 0)){
                arr[i] = currNum;
                ans = countArrangementHelper( n ,  arr ,  ans ,  currNum  + 1);
                arr[i] = 0;
            }
        }
        return ans;
    }
}",False
Minesweeper,"Let's play the minesweeper game (Wikipedia, online game)!
You are given an m x n char matrix board representing the game board where:
'M' represents an unrevealed mine,
'E' represents an unrevealed empty square,
'B' represents a revealed blank square that has no adjacent mines (i.e., above, below, left, right, and all 4 diagonals),
digit ('1' to '8') represents how many mines are adjacent to this revealed square, and
'X' represents a revealed mine.
You are also given an integer array click where click = [clickr, clickc] represents the next click position among all the unrevealed squares ('M' or 'E').
Return the board after revealing this position according to the following rules:
If a mine 'M' is revealed, then the game is over. You should change it to 'X'.
If an empty square 'E' with no adjacent mines is revealed, then change it to a revealed blank 'B' and all of its adjacent unrevealed squares should be revealed recursively.
If an empty square 'E' with at least one adjacent mine is revealed, then change it to a digit ('1' to '8') representing the number of adjacent mines.
Return the board when no more squares will be revealed.
","Example 1:

Input: board = [[""E"",""E"",""E"",""E"",""E""],[""E"",""E"",""M"",""E"",""E""],[""E"",""E"",""E"",""E"",""E""],[""E"",""E"",""E"",""E"",""E""]], click = [3,0]
Output: [[""B"",""1"",""E"",""1"",""B""],[""B"",""1"",""M"",""1"",""B""],[""B"",""1"",""1"",""1"",""B""],[""B"",""B"",""B"",""B"",""B""]]
Example 2:

Input: board = [[""B"",""1"",""E"",""1"",""B""],[""B"",""1"",""M"",""1"",""B""],[""B"",""1"",""1"",""1"",""B""],[""B"",""B"",""B"",""B"",""B""]], click = [1,2]
Output: [[""B"",""1"",""E"",""1"",""B""],[""B"",""1"",""X"",""1"",""B""],[""B"",""1"",""1"",""1"",""B""],[""B"",""B"",""B"",""B"",""B""]]
",,False
K-diff Pairs in an Array,"Given an array of integers nums and an integer k, return the number of unique k-diff pairs in the array.
A k-diff pair is an integer pair (nums[i], nums[j]), where the following are true:
0 <= i, j < nums.length
i != j
|nums[i] - nums[j]| == k
Notice that |val| denotes the absolute value of val.
","Example 1:
Input: nums = [3,1,4,1,5], k = 2
Output: 2
Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).
Although we have two 1s in the input, we should only return the number of unique pairs.
Example 2:
Input: nums = [1,2,3,4,5], k = 1
Output: 4
Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).
Example 3:
Input: nums = [1,3,1,5,4], k = 0
Output: 1
Explanation: There is one 0-diff pair in the array, (1, 1).
","class Solution {
public:
    int findPairs(vector<int>& nums, int k) {
        map<pair<int, int>, int> m;
        for(int i=0;i<nums.size();i++){
            for(int j=i+1;j<nums.size();j++){
                if(abs(nums[i]-nums[j])==k and m.find({nums[j], nums[i]})==m.end())
                    m[{nums[i], nums[j]}]++;
            }
        }
        return m.size();
    }
};",False
Minimum Time Difference,"""HH:MM""
the minimum minutes difference between any two time-points in the list
","Example 1:
Input: timePoints = [""23:59"",""00:00""]
Output: 1
Example 2:
Input: timePoints = [""00:00"",""23:59"",""00:00""]
Output: 0
","class Solution:
    def findMinDifference(self, timePoints: List[str]) -> int:
        # Convert time points to minutes since midnight and sort the list
        minutes = sorted([int(time[:2]) * 60 + int(time[3:]) for time in timePoints])
        
        # Calculate the minimum difference between adjacent time points
        min_diff = float('inf')
        for i in range(len(minutes) - 1):
            diff = minutes[i+1] - minutes[i]
            if diff < min_diff:
                min_diff = diff
        
        # Calculate the difference between the first and last time points
        diff = (24*60 - minutes[-1] + minutes[0]) % (24*60)
        if diff < min_diff:
            min_diff = diff
        
        return min_diff
",True
Single Element in a Sorted Array,"You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.
Return the single element that appears only once.
Your solution must run in O(log n) time and O(1) space.
","Example 1:
Input: nums = [1,1,2,3,3,4,4,8,8]
Output: 2
Example 2:
Input: nums = [3,3,7,7,10,11,11]
Output: 10
","class Solution {
public:
    int singleNonDuplicate(vector<int>& nums) {
        int lo = 0;
        int hi = nums.size() - 1;
        while (hi >= lo) {
            int mid = lo + (hi - lo) / 2;
            if ((mid == 0 || nums[mid - 1] != nums[mid]) &&
                (mid == nums.size() - 1 || nums[mid + 1] != nums[mid])) {
                return nums[mid];
            } else if (mid == 0 || nums[mid - 1] == nums[mid]) {
                if (mid % 2 == 0) {
                    hi = mid - 1;
                } else {
                    lo = mid + 1;
                }

            } else if (mid == nums.size() - 1 || nums[mid + 1] == nums[mid]) {
                if (mid % 2 == 0) {
                    lo = mid + 1;
                } else {
                    hi = mid - 1;
                }
            }
        }
        return -1;
    }
};",False
01 Matrix,"Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell.
The distance between two adjacent cells is 1.
","Example 1:

Input: mat = [[0,0,0],[0,1,0],[0,0,0]]
Output: [[0,0,0],[0,1,0],[0,0,0]]
Example 2:

Input: mat = [[0,0,0],[0,1,0],[1,1,1]]
Output: [[0,0,0],[0,1,0],[1,2,1]]
","class Solution:
    def updateMatrix(self, matrix: List[List[int]]) -> List[List[int]]:
        row, col = len(matrix), len(matrix[0])
        q = collections.deque()
        for x in range(row):
            for y in range(col):
                if matrix[x][y] == 0:
                    q.append((x, y))
                else:
                    matrix[x][y] = float('inf')
        
        while q:
            x, y = q.popleft()
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                new_x, new_y = x + dx, y + dy
                if 0 <= new_x < row and 0 <= new_y < col and matrix[new_x][new_y] > matrix[x][y] + 1:
                    q.append((new_x, new_y))
                    matrix[new_x][new_y] = matrix[x][y] + 1
        
        return matrix
",True
Optimal Division,"You are given an integer array nums. The adjacent integers in nums will perform the float division.
For example, for nums = [2,3,4], we will evaluate the expression ""2/3/4"".
However, you can add any number of parenthesis at any position to change the priority of operations. You want to add these parentheses such the value of the expression after the evaluation is maximum.
Return the corresponding expression that has the maximum value in string format.
Note: your expression should not contain redundant parenthesis.
","Example 1:
Input: nums = [1000,100,10,2]
Output: ""1000/(100/10/2)""
Explanation: 1000/(100/10/2) = 1000/((100/10)/2) = 200
However, the bold parenthesis in ""1000/((100/10)/2)"" are redundant since they do not influence the operation priority.
So you should return ""1000/(100/10/2)"".
Other cases:
1000/(100/10)/2 = 50
1000/(100/(10/2)) = 50
1000/100/10/2 = 0.5
1000/100/(10/2) = 2
Example 2:
Input: nums = [2,3,4]
Output: ""2/(3/4)""
Explanation: (2/(3/4)) = 8/3 = 2.667
It can be shown that after trying all possibilities, we cannot get an expression with evaluation greater than 2.667
",,False
Brick Wall,"There is a rectangular brick wall in front of you with n rows of bricks. The ith row has some number of bricks each of the same height (i.e., one unit) but they can be of different widths. The total width of each row is the same.
Draw a vertical line from the top to the bottom and cross the least bricks. If your line goes through the edge of a brick, then the brick is not considered as crossed. You cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks.
Given the 2D array wall that contains the information about the wall, return the minimum number of crossed bricks after drawing such a vertical line.
","Example 1:

Input: wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]
Output: 2
Example 2:
Input: wall = [[1],[1],[1]]
Output: 3
","class Solution:
    def leastBricks(self, wall: List[List[int]]) -> int:
        dic={}
        highest=0
        for i in range(len(wall)):
            total=0
            for j in range(len(wall[i])-1):
                total+=wall[i][j]
                if total in dic:
                    dic[total]+=1
                else:
                    dic[total]=1
                highest=max(dic[total],highest)
        
        return len(wall)-highest if len(wall)-highest>=0 else len(wall)",True
Subarray Sum Equals K,"Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.
A subarray is a contiguous non-empty sequence of elements within an array.
","Example 1:
Input: nums = [1,1,1], k = 2
Output: 2
Example 2:
Input: nums = [1,2,3], k = 3
Output: 2
",,False
Array Partition,"Given an integer array nums of 2n integers, group these integers into n pairs (a1, b1), (a2, b2), ..., (an, bn) such that the sum of min(ai, bi) for all i is maximized. Return the maximized sum.
","Example 1:
Input: nums = [1,4,3,2]
Output: 4
Explanation: All possible pairings (ignoring the ordering of elements) are:
1. (1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3
2. (1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3
3. (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4
So the maximum possible sum is 4.
Example 2:
Input: nums = [6,2,6,5,1,2]
Output: 9
Explanation: The optimal pairing is (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9.
","class Solution:
    def arrayPairSum(self, nums: List[int]) -> int:
        # nums.sort()
        # s=0
        # for i in range(0,len(nums),2):
        #     s+=min(nums[i],nums[i+1])
        # return s
        return sum(sorted(nums)[::2])",True
Array Nesting,"You are given an integer array nums of length n where nums is a permutation of the numbers in the range [0, n - 1].
You should build a set s[k] = {nums[k], nums[nums[k]], nums[nums[nums[k]]], ... } subjected to the following rule:
The first element in s[k] starts with the selection of the element nums[k] of index = k.
The next element in s[k] should be nums[nums[k]], and then nums[nums[nums[k]]], and so on.
We stop adding right before a duplicate element occurs in s[k].
Return the longest length of a set s[k].
","Example 1:
Input: nums = [5,4,0,3,1,6,2]
Output: 4
Explanation: 
nums[0] = 5, nums[1] = 4, nums[2] = 0, nums[3] = 3, nums[4] = 1, nums[5] = 6, nums[6] = 2.
One of the longest sets s[k]:
s[0] = {nums[0], nums[5], nums[6], nums[2]} = {5, 6, 2, 0}
Example 2:
Input: nums = [0,1,2]
Output: 1
","class Solution {
public:
    int arrayNesting(vector<int>& nums) {  
        vector<int> vis(nums.size(),0);
        int ans=0;
        for(int i=0;i<nums.size();i++){
            int k=i,count=0;
            while(!vis[k]){
                vis[k]=1;
                count++;
                k=nums[k];
            }
            ans=max(ans,count);
        }
        return ans;
    }
};",False
Reshape the Matrix,"In MATLAB, there is a handy function called reshape which can reshape an m x n matrix into a new one with a different size r x c keeping its original data.
You are given an m x n matrix mat and two integers r and c representing the number of rows and the number of columns of the wanted reshaped matrix.
The reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were.
If the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.
","Example 1:

Input: mat = [[1,2],[3,4]], r = 1, c = 4
Output: [[1,2,3,4]]
Example 2:

Input: mat = [[1,2],[3,4]], r = 2, c = 4
Output: [[1,2],[3,4]]
","class Solution {
public:
    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {
        int m = size(mat), n = size(mat[0]), total = m * n;
        if(r * c != total) return mat;   
        vector<vector<int>> ans(r, vector<int>(c));
        for(int i = 0; i < total; i++) 
            ans[(i%m * n + i/m) / c][(i%m * n + i/m) % c] = mat[i % m][i / m];
        return ans;
    }
};",False
Distribute Candies,"Alice has n candies, where the ith candy is of type candyType[i]. Alice noticed that she started to gain weight, so she visited a doctor.
The doctor advised Alice to only eat n / 2 of the candies she has (n is always even). Alice likes her candies very much, and she wants to eat the maximum number of different types of candies while still following the doctor's advice.
Given the integer array candyType of length n, return the maximum number of different types of candies she can eat if she only eats n / 2 of them.
","Example 1:
Input: candyType = [1,1,2,2,3,3]
Output: 3
Explanation: Alice can only eat 6 / 2 = 3 candies. Since there are only 3 types, she can eat one of each type.
Example 2:
Input: candyType = [1,1,2,3]
Output: 2
Explanation: Alice can only eat 4 / 2 = 2 candies. Whether she eats types [1,2], [1,3], or [2,3], she still can only eat 2 different types.
Example 3:
Input: candyType = [6,6,6,6]
Output: 1
Explanation: Alice can only eat 4 / 2 = 2 candies. Even though she can eat 2 candies, she only has 1 type.
",,False
Shortest Unsorted Continuous Subarray,"Given an integer array nums, you need to find one continuous subarray such that if you only sort this subarray in non-decreasing order, then the whole array will be sorted in non-decreasing order.
Return the shortest such subarray and output its length.
","Example 1:
Input: nums = [2,6,4,8,10,9,15]
Output: 5
Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.
Example 2:
Input: nums = [1,2,3,4]
Output: 0
Example 3:
Input: nums = [1]
Output: 0
","class Solution {
    public int findUnsortedSubarray(int[] arr) {
        int max = Integer.MIN_VALUE;
        int min = Integer.MAX_VALUE;
        int n = arr.length;
        int right = n;
        int left = -1;
// pass 1 to get the rightmost index      
        for(int i=0;i<n;i++)
        {
            if(arr[i]>max)
                max = arr[i];
            if(arr[i]<max)    right = i;
        }

// pass 2 to get the leftmost index
        for(int i=n-1;i>=0;i--)
        {
            if(arr[i]<min)
                min = arr[i];
            if(arr[i]>min)    left = i;
        }

        return right-left+1>n?0: right-left+1;
    }
}",False
Longest Harmonious Subsequence,"We define a harmonious array as an array where the difference between its maximum value and its minimum value is exactly 1.
Given an integer array nums, return the length of its longest harmonious subsequence among all its possible subsequences.
A subsequence of array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements.
","Example 1:
Input: nums = [1,3,2,2,5,2,3,7]
Output: 5
Explanation: The longest harmonious subsequence is [3,2,2,2,3].
Example 2:
Input: nums = [1,2,3,4]
Output: 2
Example 3:
Input: nums = [1,1,1,1]
Output: 0
","class Solution {
public:
    int findLHS(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int i = 0;
        int left = 0;
        int right = 0;
        int ans = 0;
        int maxAns = 0;

        while(right < nums.size()){
            if(nums[right]-nums[left] == 1){
                ans = right-left+1;
                maxAns = max(maxAns, ans);
            }else if(nums[right]-nums[left] > 1){
                while(nums[right]-nums[left] > 1){
                    left++;
                }
            }
            right++;
        }

        return maxAns;
    }
};",False
Range Addition II,"You are given an m x n matrix M initialized with all 0's and an array of operations ops, where ops[i] = [ai, bi] means M[x][y] should be incremented by one for all 0 <= x < ai and 0 <= y < bi.
Count and return the number of maximum integers in the matrix after performing all the operations.
","Example 1:

Input: m = 3, n = 3, ops = [[2,2],[3,3]]
Output: 4
Explanation: The maximum integer in M is 2, and there are four of it in M. So return 4.
Example 2:
Input: m = 3, n = 3, ops = [[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3]]
Output: 4
Example 3:
Input: m = 3, n = 3, ops = []
Output: 9
","class Solution:
    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:
        return min([x for x,y in ops])*min([y for x,y in ops]) if ops else m*n",True
Minimum Index Sum of Two Lists,"Given two arrays of strings list1 and list2, find the common strings with the least index sum.
A common string is a string that appeared in both list1 and list2.
A common string with the least index sum is a common string such that if it appeared at list1[i] and list2[j] then i + j should be the minimum value among all the other common strings.
Return all the common strings with the least index sum. Return the answer in any order.
","Example 1:
Input: list1 = [""Shogun"",""Tapioca Express"",""Burger King"",""KFC""], list2 = [""Piatti"",""The Grill at Torrey Pines"",""Hungry Hunter Steakhouse"",""Shogun""]
Output: [""Shogun""]
Explanation: The only common string is ""Shogun"".
Example 2:
Input: list1 = [""Shogun"",""Tapioca Express"",""Burger King"",""KFC""], list2 = [""KFC"",""Shogun"",""Burger King""]
Output: [""Shogun""]
Explanation: The common string with the least index sum is ""Shogun"" with index sum = (0 + 1) = 1.
Example 3:
Input: list1 = [""happy"",""sad"",""good""], list2 = [""sad"",""happy"",""good""]
Output: [""sad"",""happy""]
Explanation: There are three common strings:
""happy"" with index sum = (0 + 1) = 1.
""sad"" with index sum = (1 + 0) = 1.
""good"" with index sum = (2 + 2) = 4.
The strings with the least index sum are ""sad"" and ""happy"".
","class Solution {
public:
    vector<string> findRestaurant(vector<string>& list1, vector<string>& list2) {
        unordered_map<string,int> mp,m;
        vector<string> v;
        int mini =INT_MAX;
        int mi;
        int sum;
        for(int i=0;i<list1.size();i++)
            m[list1[i]] = i;
        for(int j=0;j<list2.size();j++)
        {
            if(m.find(list2[j]) != m.end())
            {
                sum = j + m[list2[j]];
                if(sum<mini)
                {
                    v.clear();
                    mini = sum;
                    v.push_back(list2[j]);
                }
                else if( sum == mini)
                    v.push_back(list2[j]);
            }
        }
        return v;
    }
};",False
Can Place Flowers,"You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.
Given an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.
","Example 1:
Input: flowerbed = [1,0,0,0,1], n = 1
Output: true
Example 2:
Input: flowerbed = [1,0,0,0,1], n = 2
Output: false
","class Solution {
public:
    bool canPlaceFlowers(vector<int>& flowerbed, int add) {
        int eligible = 0, n = flowerbed.size();

        for(int i=0;i<n;i++){
            if(flowerbed[i]==0){
                if((i+1<n && flowerbed[i+1]==0) && (i>0 && flowerbed[i-1]==0)){
                    flowerbed[i] = 1;
                    eligible++;
                }
                if(i==0 && flowerbed[i]==0){
                    flowerbed[i] = 1;
                    eligible += i+1<n ? !flowerbed[i+1] : 1;
                }else if(i==n-1 && flowerbed[i]==0 && flowerbed[i-1]==0){
                    flowerbed[i] = 1;
                    eligible ++;
                }
            }
        }

        if(eligible>=add){
            return true;
        }else{
            return false;
        }

    }
};",False
Find Duplicate File in System,"Given a list paths of directory info, including the directory path, and all the files with contents in this directory, return all the duplicate files in the file system in terms of their paths. You may return the answer in any order.
A group of duplicate files consists of at least two files that have the same content.
A single directory info string in the input list has the following format:
""root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)""
It means there are n files (f1.txt, f2.txt ... fn.txt) with content (f1_content, f2_content ... fn_content) respectively in the directory ""root/d1/d2/.../dm"". Note that n >= 1 and m >= 0. If m = 0, it means the directory is just the root directory.
The output is a list of groups of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format:
""directory_path/file_name.txt""
","Example 1:
Input: paths = [""root/a 1.txt(abcd) 2.txt(efgh)"",""root/c 3.txt(abcd)"",""root/c/d 4.txt(efgh)"",""root 4.txt(efgh)""]
Output: [[""root/a/2.txt"",""root/c/d/4.txt"",""root/4.txt""],[""root/a/1.txt"",""root/c/3.txt""]]
Example 2:
Input: paths = [""root/a 1.txt(abcd) 2.txt(efgh)"",""root/c 3.txt(abcd)"",""root/c/d 4.txt(efgh)""]
Output: [[""root/a/2.txt"",""root/c/d/4.txt""],[""root/a/1.txt"",""root/c/3.txt""]]
",,False
Valid Triangle Number,"Given an integer array nums, return the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.
","Example 1:
Input: nums = [2,2,3,4]
Output: 3
Explanation: Valid combinations are: 
2,3,4 (using the first 2)
2,3,4 (using the second 2)
2,2,3
Example 2:
Input: nums = [4,2,3,4]
Output: 4
","class Solution {
public:
    int triangleNumber(vector<int>& nums) {
         int n=nums.size();
        if(n<3) return 0;
        sort(nums.begin(),nums.end());
       
        int count=0;
        for(int i=2;i<n;i++){
            int s=0;
            int e=i-1;
            while(s<e){
                if(nums[s]+nums[e]>nums[i]){
                    count+=e-s;
                    e--;
                    }
                else
                    s++;
            }
        }
        return count;
    }
};",False
Task Scheduler,"You are given an array of CPU tasks, each represented by letters A to Z, and a cooling time, n. Each cycle or interval allows the completion of one task. Tasks can be completed in any order, but there's a constraint: identical tasks must be separated by at least n intervals due to cooling time.
Return the minimum number of intervals required to complete all tasks.
","Example 1:
Input: tasks = [""A"",""A"",""A"",""B"",""B"",""B""], n = 2
Output: 8
Explanation: A possible sequence is: A -> B -> idle -> A -> B -> idle -> A -> B.
After completing task A, you must wait two cycles before doing A again. The same applies to task B. In the 3rd interval, neither A nor B can be done, so you idle. By the 4th cycle, you can do A again as 2 intervals have passed.
Example 2:
Input: tasks = [""A"",""C"",""A"",""B"",""D"",""B""], n = 1
Output: 6
Explanation: A possible sequence is: A -> B -> C -> D -> A -> B.
With a cooling interval of 1, you can repeat a task after just one other task.
Example 3:
Input: tasks = [""A"",""A"",""A"", ""B"",""B"",""B""], n = 3
Output: 10
Explanation: A possible sequence is: A -> B -> idle -> idle -> A -> B -> idle -> idle -> A -> B.
There are only two types of tasks, A and B, which need to be separated by 3 intervals. This leads to idling twice between repetitions of these tasks.
",,False
Maximum Product of Three Numbers,"Given an integer array nums, find three numbers whose product is maximum and return the maximum product.
","Example 1:
Input: nums = [1,2,3]
Output: 6
Example 2:
Input: nums = [1,2,3,4]
Output: 24
Example 3:
Input: nums = [-1,-2,-3]
Output: -6
","class Solution:
    def maximumProduct(self, nums: List[int]) -> int:
      nums.sort()
      pos=heapq.nlargest(3,nums)
      neg=heapq.nsmallest(2,nums)
      return max(neg[0]*neg[1]*pos[0],pos[-1]*pos[-2]*pos[-3])",True
Exclusive Time of Functions,"On a single-threaded CPU, we execute a program containing n functions. Each function has a unique ID between 0 and n-1.
Function calls are stored in a call stack: when a function call starts, its ID is pushed onto the stack, and when a function call ends, its ID is popped off the stack. The function whose ID is at the top of the stack is the current function being executed. Each time a function starts or ends, we write a log with the ID, whether it started or ended, and the timestamp.
You are given a list logs, where logs[i] represents the ith log message formatted as a string ""{function_id}:{""start"" | ""end""}:{timestamp}"". For example, ""0:start:3"" means a function call with function ID 0 started at the beginning of timestamp 3, and ""1:end:2"" means a function call with function ID 1 ended at the end of timestamp 2. Note that a function can be called multiple times, possibly recursively.
A function's exclusive time is the sum of execution times for all function calls in the program. For example, if a function is called twice, one call executing for 2 time units and another call executing for 1 time unit, the exclusive time is 2 + 1 = 3.
Return the exclusive time of each function in an array, where the value at the ith index represents the exclusive time for the function with ID i.
","Example 1:

Input: n = 2, logs = [""0:start:0"",""1:start:2"",""1:end:5"",""0:end:6""]
Output: [3,4]
Explanation:
Function 0 starts at the beginning of time 0, then it executes 2 for units of time and reaches the end of time 1.
Function 1 starts at the beginning of time 2, executes for 4 units of time, and ends at the end of time 5.
Function 0 resumes execution at the beginning of time 6 and executes for 1 unit of time.
So function 0 spends 2 + 1 = 3 units of total time executing, and function 1 spends 4 units of total time executing.
Example 2:
Input: n = 1, logs = [""0:start:0"",""0:start:2"",""0:end:5"",""0:start:6"",""0:end:6"",""0:end:7""]
Output: [8]
Explanation:
Function 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself.
Function 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time.
Function 0 (initial call) resumes execution then immediately calls itself again.
Function 0 (2nd recursive call) starts at the beginning of time 6 and executes for 1 unit of time.
Function 0 (initial call) resumes execution at the beginning of time 7 and executes for 1 unit of time.
So function 0 spends 2 + 4 + 1 + 1 = 8 units of total time executing.
Example 3:
Input: n = 2, logs = [""0:start:0"",""0:start:2"",""0:end:5"",""1:start:6"",""1:end:6"",""0:end:7""]
Output: [7,1]
Explanation:
Function 0 starts at the beginning of time 0, executes for 2 units of time, and recursively calls itself.
Function 0 (recursive call) starts at the beginning of time 2 and executes for 4 units of time.
Function 0 (initial call) resumes execution then immediately calls function 1.
Function 1 starts at the beginning of time 6, executes 1 unit of time, and ends at the end of time 6.
Function 0 resumes execution at the beginning of time 6 and executes for 2 units of time.
So function 0 spends 2 + 4 + 1 = 7 units of total time executing, and function 1 spends 1 unit of total time executing.
","class Solution:
    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:
        ## RC ##
		## APPROACH : STACK ##
        stack, res = [], [0] * n
        for log in logs:
            id, func, curr_time = log.split("":"")
            id, curr_time = int(id), int(curr_time)
            if func == ""start"":
                stack.append((id, curr_time))
            elif func == ""end"" and id == stack[-1][0]:
                pop_id, insert_time = stack.pop()
                time_taken = curr_time - insert_time + 1
                res[pop_id] += time_taken
                
                # gist, we have remove overlap time, if a process is in the stack indicates there is overlap with the last process
                if stack:
                    res[stack[-1][0]] -= time_taken # time taken by this process is the overlap time for prev process in stack
        return res
        ",True
Shopping Offers,"In LeetCode Store, there are n items to sell. Each item has a price. However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price.
You are given an integer array price where price[i] is the price of the ith item, and an integer array needs where needs[i] is the number of pieces of the ith item you want to buy.
You are also given an array special where special[i] is of size n + 1 where special[i][j] is the number of pieces of the jth item in the ith offer and special[i][n] (i.e., the last integer in the array) is the price of the ith offer.
Return the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers. You are not allowed to buy more items than you want, even if that would lower the overall price. You could use any of the special offers as many times as you want.
","Example 1:
Input: price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]
Output: 14
Explanation: There are two kinds of items, A and B. Their prices are $2 and $5 respectively. 
In special offer 1, you can pay $5 for 3A and 0B
In special offer 2, you can pay $10 for 1A and 2B. 
You need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A.
Example 2:
Input: price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]
Output: 11
Explanation: The price of A is $2, and $3 for B, $4 for C. 
You may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C. 
You need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C. 
You cannot add more items, though only $9 for 2A ,2B and 1C.
","class Solution {
public:
    bool check(vector<int> need){
        for(int i = 0; i < need.size(); i++){
            if(need[i] < 0){
                return false;
            }
        }
        return true;
    }
    map<vector<int>, int> umap;
    
    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {
        if(umap[needs] > 0){
            return umap[needs];
        }
        int minimum = 0;
        for(int i = 0; i < needs.size(); i++){
            minimum += needs[i] * price[i];
        }        
        for(auto spec : special){
            vector<int> need = needs;
            for(int i = 0; i < need.size(); i++){
                need[i] -= spec[i];
            }
            if(check(need)){
                minimum = min(minimum, spec[spec.size() - 1] + shoppingOffers(price, special, need));    
            }            
        }
        return umap[needs] = minimum;
    }
};",False
Maximum Average Subarray I,"You are given an integer array nums consisting of n elements, and an integer k.
Find a contiguous subarray whose length is equal to k that has the maximum average value and return this value. Any answer with a calculation error less than 10-5 will be accepted.
","Example 1:
Input: nums = [1,12,-5,-6,50,3], k = 4
Output: 12.75000
Explanation: Maximum average is (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75
Example 2:
Input: nums = [5], k = 1
Output: 5.00000
","class Solution:
    def findMaxAverage(self, nums: List[int], k: int) -> float:
        ans = sum(nums[:k])
        window = ans
        for i in range(1,len(nums)-k+1):            
            window = window - nums[i-1] + nums[i+k-1]
            ans = max(window, ans)
        return ans/k
",True
Set Mismatch,"You have a set of integers s, which originally contains all the numbers from 1 to n. Unfortunately, due to some error, one of the numbers in s got duplicated to another number in the set, which results in repetition of one number and loss of another number.
You are given an integer array nums representing the data status of this set after the error.
Find the number that occurs twice and the number that is missing and return them in the form of an array.
","Example 1:
Input: nums = [1,2,2,4]
Output: [2,3]
Example 2:
Input: nums = [1,1]
Output: [1,2]
","class Solution:
    def findErrorNums(self, nums: List[int]) -> List[int]:
        n = len(nums)
        sumtoN = n*(n+1)//2
        missingNum = sumtoN - sum(set(nums))
        duplicateNum = sum(nums) - (sumtoN - missingNum)
        return [duplicateNum,missingNum]",True
Maximum Length of Pair Chain,"You are given an array of n pairs pairs where pairs[i] = [lefti, righti] and lefti < righti.
A pair p2 = [c, d] follows a pair p1 = [a, b] if b < c. A chain of pairs can be formed in this fashion.
Return the length longest chain which can be formed.
You do not need to use up all the given intervals. You can select pairs in any order.
","Example 1:
Input: pairs = [[1,2],[2,3],[3,4]]
Output: 2
Explanation: The longest chain is [1,2] -> [3,4].
Example 2:
Input: pairs = [[1,2],[7,8],[4,5]]
Output: 3
Explanation: The longest chain is [1,2] -> [4,5] -> [7,8].
","class Solution {
public:
static bool compare(vector<int>&a,vector<int>&b){
             if(a[1]==b[1])
             return a[0]<b[0];

             return a[1]<b[1];

}
    int findLongestChain(vector<vector<int>>& pairs) {
        sort(pairs.begin(),pairs.end(),compare);
        int c=0;
     //   vector<vector<int>>ans;
          int temp=-1e9;
        for(int i=0;i<pairs.size();i++){
        //    vector<int>temp;
          //  cout<<pairs[i][0]<<"" ""<<pairs[i][1]<<endl;
          //  temp.push_back(pairs[i][0]);
             //  temp.push_back(pairs[i][1]);
           
            if(temp==-1e9 ||temp<pairs[i][0]){
                temp=pairs[i][1];
                c++;
            }
           // ans.push_back(temp);
           
        }

return c;
    }
};",False
Replace Words,"In English, we have a concept called root, which can be followed by some other word to form another longer word - let's call this word successor. For example, when the root ""help"" is followed by the successor word ""ful"", we can form a new word ""helpful"".
Given a dictionary consisting of many roots and a sentence consisting of words separated by spaces, replace all the successors in the sentence with the root forming it. If a successor can be replaced by more than one root, replace it with the root that has the shortest length.
Return the sentence after the replacement.
","Example 1:
Input: dictionary = [""cat"",""bat"",""rat""], sentence = ""the cattle was rattled by the battery""
Output: ""the cat was rat by the bat""
Example 2:
Input: dictionary = [""a"",""b"",""c""], sentence = ""aadsfasf absbs bbab cadsfafs""
Output: ""a a b c""
","class Solution:
    def replaceWords(self, dictionary: List[str], sentence: str) -> str:
        d = {w:len(w) for w in dictionary}
        mini, maxi = min(d.values()), max(d.values())
        wd = sentence.split()
        rt = []
        for s in wd:
            c = s 
            for k in range(mini,min(maxi,len(s))+1):
                ss = s[:k]
                if ss in d:
                    c = ss 
                    break 
            rt.append(c)
        return "" "".join(rt)",True
Maximum Binary Tree,"You are given an integer array nums with no duplicates. A maximum binary tree can be built recursively from nums using the following algorithm:
Create a root node whose value is the maximum value in nums.
Recursively build the left subtree on the subarray prefix to the left of the maximum value.
Recursively build the right subtree on the subarray suffix to the right of the maximum value.
Return the maximum binary tree built from nums.
","Example 1:

Input: nums = [3,2,1,6,0,5]
Output: [6,3,5,null,2,0,null,null,1]
Explanation: The recursive calls are as follow:
- The largest value in [3,2,1,6,0,5] is 6. Left prefix is [3,2,1] and right suffix is [0,5].
    - The largest value in [3,2,1] is 3. Left prefix is [] and right suffix is [2,1].
        - Empty array, so no child.
        - The largest value in [2,1] is 2. Left prefix is [] and right suffix is [1].
            - Empty array, so no child.
            - Only one element, so child is a node with value 1.
    - The largest value in [0,5] is 5. Left prefix is [0] and right suffix is [].
        - Only one element, so child is a node with value 0.
        - Empty array, so no child.
Example 2:

Input: nums = [3,2,1]
Output: [3,null,2,null,1]
",,False
Find K Closest Elements,"Given a sorted integer array arr, two integers k and x, return the k closest integers to x in the array. The result should also be sorted in ascending order.
An integer a is closer to x than an integer b if:
|a - x| < |b - x|, or
|a - x| == |b - x| and a < b
","Example 1:
Input: arr = [1,2,3,4,5], k = 4, x = 3
Output: [1,2,3,4]
Example 2:
Input: arr = [1,2,3,4,5], k = 4, x = -1
Output: [1,2,3,4]
","class Solution {
    public List<Integer> findClosestElements(int[] arr, int k, int x) {
        List<Integer> ans = new ArrayList<Integer>();
        int t=0;
        int tt=arr[arr.length-1]+1;
        for(int i=0; i<arr.length; i++){
            if(Math.abs(arr[i]-x)<tt){
                t=i;
                tt=Math.abs(arr[i]-x);
            }
        }
        int p1=t, p2=t;
        
        for(int i=0; i<k; i++){
            if(p1==p2){
                ans.add(arr[p1]);
                p2++;
                p1--;
                continue;
            }
            if(p1>=0 && p2<arr.length && Math.abs(x-arr[p1]) <= Math.abs(x-arr[p2])){
                ans.add(arr[p1]);
                p1--;
            }
            else if(p1>=0 && p2<arr.length && Math.abs(arr[p1]-x) > Math.abs(arr[p2]-x)){
                ans.add(arr[p2]);
                p2++;
            }
            else if(p1<0){
                ans.add(arr[p2]);
                p2++;
            }
            else if(p2>=arr.length){
                ans.add(arr[p1]);
                p1--;
            }
        }
        Collections.sort(ans);
        return ans;
    }
}",False
Split Array into Consecutive Subsequences,"You are given an integer array nums that is sorted in non-decreasing order.
Determine if it is possible to split nums into one or more subsequences such that both of the following conditions are true:
Each subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer).
All subsequences have a length of 3 or more.
Return true if you can split nums according to the above conditions, or false otherwise.
A subsequence of an array is a new array that is formed from the original array by deleting some (can be none) of the elements without disturbing the relative positions of the remaining elements. (i.e., [1,3,5] is a subsequence of [1,2,3,4,5] while [1,3,2] is not).
","Example 1:
Input: nums = [1,2,3,3,4,5]
Output: true
Explanation: nums can be split into the following subsequences:
[1,2,3,3,4,5] --> 1, 2, 3
[1,2,3,3,4,5] --> 3, 4, 5
Example 2:
Input: nums = [1,2,3,3,4,4,5,5]
Output: true
Explanation: nums can be split into the following subsequences:
[1,2,3,3,4,4,5,5] --> 1, 2, 3, 4, 5
[1,2,3,3,4,4,5,5] --> 3, 4, 5
Example 3:
Input: nums = [1,2,3,4,4,5]
Output: false
Explanation: It is impossible to split nums into consecutive increasing subsequences of length 3 or more.
","class Solution {
    public boolean isPossible(int[] nums) {
        
        HashMap<Integer, Integer> frequencyMap = new HashMap<>();
        HashMap<Integer, Integer> hypotheticalMap = new HashMap<>();
        
        for(int i : nums){
            frequencyMap.put(i, frequencyMap.getOrDefault(i, 0) + 1);
        }
        
        for(int i : nums){
            
            int fromFm = frequencyMap.getOrDefault(i, 0);
            int fromHm = hypotheticalMap.getOrDefault(i, 0);
            
            if(fromFm == 0) continue;
            
            if(fromHm > 0) {
                hypotheticalMap.put(i, fromHm - 1);
                hypotheticalMap.put(i+1, hypotheticalMap.getOrDefault(i + 1, 0) + 1);
                frequencyMap.put(i, fromFm - 1);
            }
            else if(frequencyMap.getOrDefault(i, 0) > 0 && frequencyMap.getOrDefault(i + 1, 0) > 0 && frequencyMap.getOrDefault(i + 2, 0) > 0) {
                frequencyMap.put(i, frequencyMap.get(i) - 1);
                frequencyMap.put(i + 1, frequencyMap.get(i + 1) - 1);
                frequencyMap.put(i + 2, frequencyMap.get(i + 2) - 1);
                hypotheticalMap.put(i+3, hypotheticalMap.getOrDefault(i + 3, 0) + 1);
                
            }
            else {
                return false;
            }
        }
        return true;
    }
}",False
Image Smoother,"An image smoother is a filter of the size 3 x 3 that can be applied to each cell of an image by rounding down the average of the cell and the eight surrounding cells (i.e., the average of the nine cells in the blue smoother). If one or more of the surrounding cells of a cell is not present, we do not consider it in the average (i.e., the average of the four cells in the red smoother).

Given an m x n integer matrix img representing the grayscale of an image, return the image after applying the smoother on each cell of it.
","Example 1:

Input: img = [[1,1,1],[1,0,1],[1,1,1]]
Output: [[0,0,0],[0,0,0],[0,0,0]]
Explanation:
For the points (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0
For the points (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0
For the point (1,1): floor(8/9) = floor(0.88888889) = 0
Example 2:

Input: img = [[100,200,100],[200,50,200],[100,200,100]]
Output: [[137,141,137],[141,138,141],[137,141,137]]
Explanation:
For the points (0,0), (0,2), (2,0), (2,2): floor((100+200+200+50)/4) = floor(137.5) = 137
For the points (0,1), (1,0), (1,2), (2,1): floor((200+200+50+200+100+100)/6) = floor(141.666667) = 141
For the point (1,1): floor((50+200+200+200+200+100+100+100+100)/9) = floor(138.888889) = 138
","class Solution:
    def imageSmoother(self, img: List[List[int]]) -> List[List[int]]:
        # nasty one liner
        return [[(sum([img[r+y][c+x] for y, x in [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (1, 1), (-1, 1), (1, -1), (0, 0)] if 0 <= r+y < len(img) and 0 <= c + x < len(img[0])]) 
               // len([img[r+y][c+x] for y, x in [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (1, 1), (-1, 1), (1, -1), (0, 0)] if 0 <= r+y < len(img) and 0 <= c + x < len(img[0])])) 
            for c in range(len(img[0]))] 
            for r in range(len(img))]

        # Actual Solution in O(m*n) time, O(m*n) space
        #  call dfs on each of the cells to get the average 
        rows = len(img)
        cols = len(img[0])
        # initialize smoothed image
        smoothedImg = [[0 for y in range(cols)] for x in range(rows)]
        # 8 directions 
        dirs = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (1, 1), (-1, 1), (1, -1), (0, 0)]

        # iterate through the whole img calling dfs and adding the average to a new matrix
        for r in range(rows): 
            for c in range(cols): 
                avg = []
                for y, x in dirs: 
                    # append dirs
                    ry = r + y
                    cx = c + x
                    if 0 <= ry < len(img) and 0 <= cx < len(img[0]): 
                        avg.append(img[ry][cx])
                smoothedImg[r][c] = sum(avg)//len(avg)  
        
        return smoothedImg",True
Non-decreasing Array,"Given an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most one element.
We define an array is non-decreasing if nums[i] <= nums[i + 1] holds for every i (0-based) such that (0 <= i <= n - 2).
","Example 1:
Input: nums = [4,2,3]
Output: true
Explanation: You could modify the first 4 to 1 to get a non-decreasing array.
Example 2:
Input: nums = [4,2,1]
Output: false
Explanation: You cannot get a non-decreasing array by modifying at most one element.
","class Solution {
    public boolean checkPossibility(int[] nums) {
        int n = nums.length;
        int count=0;
        for(int i=0;i<n-1;i++){
            if(nums[i]>nums[i+1]){
                count++;
                if(count>1){
                    return false;
                }
                if(i>0 && nums[i-1]>nums[i+1]){
                    nums[i+1]=nums[i];
                }
            }
            
        }

        return true;
    }
}",False
Beautiful Arrangement II,"Given two integers n and k, construct a list answer that contains n different positive integers ranging from 1 to n and obeys the following requirement:
Suppose this list is answer = [a1, a2, a3, ... , an], then the list [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] has exactly k distinct integers.
Return the list answer. If there multiple valid answers, return any of them.
","Example 1:
Input: n = 3, k = 1
Output: [1,2,3]
Explanation: The [1,2,3] has three different positive integers ranging from 1 to 3, and the [1,1] has exactly 1 distinct integer: 1
Example 2:
Input: n = 3, k = 2
Output: [1,3,2]
Explanation: The [1,3,2] has three different positive integers ranging from 1 to 3, and the [2,1] has exactly 2 distinct integers: 1 and 2.
","class Solution {
    public int[] constructArray(int n, int k) {
        int [] result = new int[n];
        result[0] = 1;
        int sign = 1;
        for(int i = 1 ; i < n; i++, k--){
            if(k > 0){
                result[i] = result[i-1] + k * sign;
                sign *= -1;
            }
            else{
                result[i] = i+1;
            }
        }
        return result;
    }
}",False
Number of Longest Increasing Subsequence,"Given an integer array nums, return the number of longest increasing subsequences.
Notice that the sequence has to be strictly increasing.
","Example 1:
Input: nums = [1,3,5,4,7]
Output: 2
Explanation: The two longest increasing subsequences are [1, 3, 4, 7] and [1, 3, 5, 7].
Example 2:
Input: nums = [2,2,2,2,2]
Output: 5
Explanation: The length of the longest increasing subsequence is 1, and there are 5 increasing subsequences of length 1, so output 5.
","class Solution:
    def findNumberOfLIS(self, nums: List[int]) -> int:
        ct = defaultdict(list)
        ct[0] = [1,1]
        length,longest,ans = len(nums),1,1

        for right in range(1,length):
            map,cur_longest = defaultdict(lambda:1),1
            for left in range(right-1,-1,-1):
                if nums[right] > nums[left] and ct[left][0]+1>=cur_longest:
                    temp_long,temp_ct = ct[left]
                    cur_longest = temp_long+1
                    map[cur_longest] += temp_ct
            if map:
                map[cur_longest]-=1
                ct[right] = [cur_longest,map[cur_longest]]
            else:
                ct[right] = ct[0]
            if cur_longest > longest:
                longest,ans = cur_longest,map[cur_longest]
            elif cur_longest == longest:
                ans += map[cur_longest]
        return ans",True
Longest Continuous Increasing Subsequence,"Given an unsorted array of integers nums, return the length of the longest continuous increasing subsequence (i.e. subarray). The subsequence must be strictly increasing.
A continuous increasing subsequence is defined by two indices l and r (l < r) such that it is [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] and for each l <= i < r, nums[i] < nums[i + 1].
","Example 1:
Input: nums = [1,3,5,4,7]
Output: 3
Explanation: The longest continuous increasing subsequence is [1,3,5] with length 3.
Even though [1,3,5,7] is an increasing subsequence, it is not continuous as elements 5 and 7 are separated by element
4.
Example 2:
Input: nums = [2,2,2,2,2]
Output: 1
Explanation: The longest continuous increasing subsequence is [2] with length 1. Note that it must be strictly
increasing.
","class Solution:
    def findLengthOfLCIS(self, nums: List[int]) -> int:
        if not nums:
            return 0
        
        cur_len = 1
        max_len = 1
        
        for i in range(1,len(nums)):
            if nums[i] > nums[i-1]:
                cur_len += 1
            else:
                max_len = max(max_len,cur_len)
                cur_len = 1
        
        return max(max_len,cur_len)",True
Baseball Game,"You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you start with an empty record.
You are given a list of strings operations, where operations[i] is the ith operation you must apply to the record and is one of the following:
An integer x.
Record a new score of x.
'+'.
Record a new score that is the sum of the previous two scores.
'D'.
Record a new score that is the double of the previous score.
'C'.
Invalidate the previous score, removing it from the record.
Return the sum of all the scores on the record after applying all the operations.
The test cases are generated such that the answer and all intermediate calculations fit in a 32-bit integer and that all operations are valid.
","Example 1:
Input: ops = [""5"",""2"",""C"",""D"",""+""]
Output: 30
Explanation:
""5"" - Add 5 to the record, record is now [5].
""2"" - Add 2 to the record, record is now [5, 2].
""C"" - Invalidate and remove the previous score, record is now [5].
""D"" - Add 2 * 5 = 10 to the record, record is now [5, 10].
""+"" - Add 5 + 10 = 15 to the record, record is now [5, 10, 15].
The total sum is 5 + 10 + 15 = 30.
Example 2:
Input: ops = [""5"",""-2"",""4"",""C"",""D"",""9"",""+"",""+""]
Output: 27
Explanation:
""5"" - Add 5 to the record, record is now [5].
""-2"" - Add -2 to the record, record is now [5, -2].
""4"" - Add 4 to the record, record is now [5, -2, 4].
""C"" - Invalidate and remove the previous score, record is now [5, -2].
""D"" - Add 2 * -2 = -4 to the record, record is now [5, -2, -4].
""9"" - Add 9 to the record, record is now [5, -2, -4, 9].
""+"" - Add -4 + 9 = 5 to the record, record is now [5, -2, -4, 9, 5].
""+"" - Add 9 + 5 = 14 to the record, record is now [5, -2, -4, 9, 5, 14].
The total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27.
Example 3:
Input: ops = [""1"",""C""]
Output: 0
Explanation:
""1"" - Add 1 to the record, record is now [1].
""C"" - Invalidate and remove the previous score, record is now [].
Since the record is empty, the total sum is 0.
","class Solution {
public:
    int calPoints(vector<string>&o)
    {
        stack<int>s;
        for(int i=0;i<o.size();i++)
        {
            if(o[i]==""C"")
            s.pop();
            else if(o[i]==""D"")
            s.push(s.top()*2);
            else if(o[i]==""+"")
            {
                int e1=s.top();
                s.pop();
                int e2=s.top();
                s.push(e1);
                s.push(e1+e2);
            }
            else
            s.push(stoi(o[i]));
        }
        int sum=0;
        while(!s.empty())
        {
        sum+=s.top();
        s.pop();
        }
        return sum;
    }
};",False
Employee Importance,"You have a data structure of employee information, including the employee's unique ID, importance value, and direct subordinates' IDs.
You are given an array of employees employees where:
employees[i].id is the ID of the ith employee.
employees[i].importance is the importance value of the ith employee.
employees[i].subordinates is a list of the IDs of the direct subordinates of the ith employee.
Given an integer id that represents an employee's ID, return the total importance value of this employee and all their direct and indirect subordinates.
","Example 1:

Input: employees = [[1,5,[2,3]],[2,3,[]],[3,3,[]]], id = 1
Output: 11
Explanation: Employee 1 has an importance value of 5 and has two direct subordinates: employee 2 and employee 3.
They both have an importance value of 3.
Thus, the total importance value of employee 1 is 5 + 3 + 3 = 11.
Example 2:

Input: employees = [[1,2,[5]],[5,-3,[]]], id = 5
Output: -3
Explanation: Employee 5 has an importance value of -3 and has no direct subordinates.
Thus, the total importance value of employee 5 is -3.
","class Solution {
public:
    int getImportance(vector<Employee*> employees, int id) {
        int result = 0;
        unordered_map<int, Employee*> emap;
        for(auto& employee : employees){
            emap[employee->id] = employee;
        }
        queue<Employee*> q;
        q.push(emap[id]);
        while (!q.empty()) {
            Employee* emp = q.front();  q.pop();
            result += emp->importance;
            for (int s : emp->subordinates) {
                q.push(emap[s]);
            }
        }
        return result;
    }
};",False
Max Area of Island,"You are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.
The area of an island is the number of cells with a value 1 in the island.
Return the maximum area of an island in grid. If there is no island, return 0.
","Example 1:

Input: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]
Output: 6
Explanation: The answer is not 11, because the island must be connected 4-directionally.
Example 2:
Input: grid = [[0,0,0,0,0,0,0,0]]
Output: 0
",,False
Degree of an Array,"Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements.
Your task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums.
","Example 1:
Input: nums = [1,2,2,3,1]
Output: 2
Explanation: 
The input array has a degree of 2 because both elements 1 and 2 appear twice.
Of the subarrays that have the same degree:
[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]
The shortest length is 2. So return 2.
Example 2:
Input: nums = [1,2,2,3,1,4,2]
Output: 6
Explanation: 
The degree is 3 because the element 2 is repeated 3 times.
So [2,2,3,1,4,2] is the shortest subarray, therefore returning 6.
","class Solution:
    def findShortestSubArray(self, nums: List[int]) -> int:
        '''
        step 1: find the degree
            - create a hashmap of a number and value as list of occurance indices
            - the largest indices array in the hashmap gives us the degree
        step 2: find the minimum length subarray with same degree
            - initialize result as length of array
            - for each indices array, if it's length equals degree, means it's most frequent element
                - this length will be equal to the difference of first occurance and last occurance of most frequent element
                - compare this length with current result and keep the smallest length as result
            - return result + 1 because difference of indices will give us length - 1
                
            
        '''
        c = defaultdict(list)
        for i, n in enumerate(nums):
            c[n].append(i)        
        degree = max([len(x) for x in c.values()])
        
        result = len(nums)
        for indices in c.values():
            if len(indices) == degree:
                result = min(result, indices[-1] - indices[0])
        return result + 1            
        
        ",True
Partition to K Equal Sum Subsets,"Given an integer array nums and an integer k, return true if it is possible to divide this array into k non-empty subsets whose sums are all equal.
","Example 1:
Input: nums = [4,3,2,3,5,2,1], k = 4
Output: true
Explanation: It is possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums.
Example 2:
Input: nums = [1,2,3,4], k = 3
Output: false
","class Solution {
public:
    bool canPartitionKSubsets(vector<int>& nums, int k) {
        int sum = 0;
        for(auto num: nums) sum += num;
        
        //Sum must be divisible by k
        if(sum % k)return false;
        
        sum/= k;
        sort(nums.begin(), nums.end(), greater<int>());
        
        //Largest element must not be greater than sum(nums)/k
        if(nums[0] > sum)return false;
        vector<int> used(nums.size(), 0);
        
        return help(nums, 0, used, 0, sum, k);
    }
    
    bool help(vector<int> &nums, int idx, vector<int> &used, int currSum, int reqSum, int k){
        //Base case
        if(k == 0)return true;
        
        //Called after previous currSum was equal to reqSum
        if(used[idx]){
            if(idx == nums.size() - 1)return false;
            else return help(nums, idx + 1, used, currSum, reqSum, k);
        }
        used[idx] = 1;
        currSum += nums[idx];
        
        //Not possible
        if(currSum > reqSum)return false;
        
        //Check for k - 1
        if(currSum == reqSum)return help(nums, 0, used, 0, reqSum, k - 1);
		
        //Check for all valid index
        //Elements with index < idx have already been used
        for(int i = idx + 1; i < nums.size(); i++){
            if(used[i])continue;
            if(help(nums, i, used, currSum, reqSum, k)){
                return true;
            }
            //We can't use the ith index to achieve requiredSum
            used[i] = 0;
        }
        //Backtrack
        used[idx] = 0;
        currSum -= nums[idx];
        return false;
    }
    
    
};",False
Subarray Product Less Than K,"Given an array of integers nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k.
","Example 1:
Input: nums = [10,5,2,6], k = 100
Output: 8
Explanation: The 8 subarrays that have product less than 100 are:
[10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]
Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.
Example 2:
Input: nums = [1,2,3], k = 0
Output: 0
","class Solution {
public:
    int numSubarrayProductLessThanK(vector<int>& nums, int k) {
        if (k == 0) return 0;
        
        int ans = 0;
        int l = 0;
        int psum = 1;
        for (int r = 0; r < nums.size(); ++r) {
            psum *= nums[r];
            while (l <= r && psum >= k) {
                psum /= nums[l++];
            }
            ans += (r - l + 1);
        }
        
        return ans;
    }
};",False
Best Time to Buy and Sell Stock with Transaction Fee,"You are given an array prices where prices[i] is the price of a given stock on the ith day, and an integer fee representing a transaction fee.
Find the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.
Note:
You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).
The transaction fee is only charged once for each stock purchase and sale.
","Example 1:
Input: prices = [1,3,2,8,4,9], fee = 2
Output: 8
Explanation: The maximum profit can be achieved by:
- Buying at prices[0] = 1
- Selling at prices[3] = 8
- Buying at prices[4] = 4
- Selling at prices[5] = 9
The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
Example 2:
Input: prices = [1,3,7,5,10,3], fee = 3
Output: 6
","class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int res {0};
        auto it = prices.cbegin() + 1;
        while (true) {
            //Find local minimum of the prices:
            while (it != prices.cend() && *it <= *(it - 1)) ++it;
            if (it == prices.cend()) break;
           
            int min = *(it - 1);
            int max = *it;
            //Find gap down bigger than fee:
            while (++it != prices.cend() && max - *it < fee) {
                if (*it < min) min = *it;
                if (*it > max) max = *it;
            }
            
            //Add the transaction iff it's profitable:
            int diff = max - min - fee;
            if (diff > 0) res += diff;
        }
        return res;
    }
};",False
1-bit and 2-bit Characters,"We have two special characters:
The first character can be represented by one bit 0.
The second character can be represented by two bits (10 or 11).
Given a binary array bits that ends with 0, return true if the last character must be a one-bit character.
","Example 1:
Input: bits = [1,0,0]
Output: true
Explanation: The only way to decode it is two-bit character and one-bit character.
So the last character is one-bit character.
Example 2:
Input: bits = [1,1,1,0]
Output: false
Explanation: The only way to decode it is two-bit character and two-bit character.
So the last character is not one-bit character.
","class Solution{
public:
    bool isOneBitCharacter(vector<int> &bits){
        int len = bits.size();
        bool ans = false;
        for (int i = 0; i < len; i++){
            if (i == len - 1)
                ans = true;
            if (bits[i] == 1)
                i += 1;
        }
        return ans;
    }
};",False
Maximum Length of Repeated Subarray,"Given two integer arrays nums1 and nums2, return the maximum length of a subarray that appears in both arrays.
","Example 1:
Input: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
Output: 3
Explanation: The repeated subarray with maximum length is [3,2,1].
Example 2:
Input: nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]
Output: 5
Explanation: The repeated subarray with maximum length is [0,0,0,0,0].
","class Solution {
    public int findLength(int[] nums1, int[] nums2) {
        int n = nums1.length, m = nums2.length;

        int max = 0;
        int dp[][] = new int[n + 1][m + 1];

        for (int i = dp.length - 2; i >= 0; i--) {
            for (int j = dp[0].length - 2; j >= 0; j--) {
                if (nums1[i] == nums2[j]) {
                    dp[i][j] = dp[i + 1][j + 1] + 1;
                }
                max = Math.max(max, dp[i][j]);
            }
        }

        return max;
    }
}",False
Longest Word in Dictionary,"Given an array of strings words representing an English Dictionary, return the longest word in words that can be built one character at a time by other words in words.
If there is more than one possible answer, return the longest word with the smallest lexicographical order. If there is no answer, return the empty string.
Note that the word should be built from left to right with each additional character being added to the end of a previous word. 
","Example 1:
Input: words = [""w"",""wo"",""wor"",""worl"",""world""]
Output: ""world""
Explanation: The word ""world"" can be built one character at a time by ""w"", ""wo"", ""wor"", and ""worl"".
Example 2:
Input: words = [""a"",""banana"",""app"",""appl"",""ap"",""apply"",""apple""]
Output: ""apple""
Explanation: Both ""apply"" and ""apple"" can be built from other words in the dictionary. However, ""apple"" is lexicographically smaller than ""apply"".
",,False
Accounts Merge,"Given a list of accounts where each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account.
Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.
After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any order.
","Example 1:
Input: accounts = [[""John"",""johnsmith@mail.com"",""john_newyork@mail.com""],[""John"",""johnsmith@mail.com"",""john00@mail.com""],[""Mary"",""mary@mail.com""],[""John"",""johnnybravo@mail.com""]]
Output: [[""John"",""john00@mail.com"",""john_newyork@mail.com"",""johnsmith@mail.com""],[""Mary"",""mary@mail.com""],[""John"",""johnnybravo@mail.com""]]
Explanation:
The first and second John's are the same person as they have the common email ""johnsmith@mail.com"".
The third John and Mary are different people as none of their email addresses are used by other accounts.
We could return these lists in any order, for example the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'], 
['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted.
Example 2:
Input: accounts = [[""Gabe"",""Gabe0@m.co"",""Gabe3@m.co"",""Gabe1@m.co""],[""Kevin"",""Kevin3@m.co"",""Kevin5@m.co"",""Kevin0@m.co""],[""Ethan"",""Ethan5@m.co"",""Ethan4@m.co"",""Ethan0@m.co""],[""Hanzo"",""Hanzo3@m.co"",""Hanzo1@m.co"",""Hanzo0@m.co""],[""Fern"",""Fern5@m.co"",""Fern1@m.co"",""Fern0@m.co""]]
Output: [[""Ethan"",""Ethan0@m.co"",""Ethan4@m.co"",""Ethan5@m.co""],[""Gabe"",""Gabe0@m.co"",""Gabe1@m.co"",""Gabe3@m.co""],[""Hanzo"",""Hanzo0@m.co"",""Hanzo1@m.co"",""Hanzo3@m.co""],[""Kevin"",""Kevin0@m.co"",""Kevin3@m.co"",""Kevin5@m.co""],[""Fern"",""Fern0@m.co"",""Fern1@m.co"",""Fern5@m.co""]]
","class Solution {

    // Let N be the # of accounts and K is the max length of an account.
    //
    // Time: Θ(N K log N K)
    //
    // While merging we consider the size of each connected component 
    // and we always choose the representative of the larger component 
    // to be the new representative of the smaller component, also we have 
    // included the path compression so the time complexity 
    // for find/union operation is α(N)) 
    // Here, α(N) is the inverse Ackermann function that grows so slowly, 
    // that it doesn't exceed 4 for all reasonable N (approximately N < 10⁶⁰⁰).
    //
    // We find the representative of all the emails, 
    // hence it will take O(N K α(N)) time. 
    // We are also sorting the components and the worst case will be when 
    // all emails end up belonging to the same component 
    // this will cost O(N K (log ⁡N K)).
    //
    // Total is Θ(N K * log N K + N L * α(N))
    //
    // Space: O(N K)
    func accountsMerge(_ accounts: [[String]]) -> [[String]] {

        var adjList = [String : [String]]()
        var visited = Set<String>()

        func dfs(_ bucket: inout [String], _ key: String) { // Returns mergedAccount.
            visited.insert(key)
            // Add the email vector that contains the current component's emails.
            bucket.append(key)

            guard adjList[key] != nil else {
                return
            }
            for email in adjList[key]! {
                if visited.contains(email) { continue }
                dfs(&bucket, email)
            }
        }

        // 1. Create an adjacency list: For each account 
        // add an edge between the first email (accountFirstEmail) 
        // and each of the other emails in the account.
        for account in accounts {
            let firstEmail = account[1]
            for email in account.dropFirst() {
                adjList[firstEmail, default: []].append(email)
                adjList[email, default: []].append(firstEmail)
            }
        }

        // 2. Traverse over the accounts; for each account, check if the first email in the account
        // accountFirstEmail was already visited. If so, then don't start a new DFS.
        // Othetwise, perform DFS with this email as the source node.
        var mergedAccounts = [[String]]() // Answer.

        for account in accounts {
            let accountName = account[0]
            let accountFirstEmail = account[1]

            // If email is visited, then it's a part of different component
            // Hence perform DFS only if email is not visited yet.
            if visited.contains(accountFirstEmail) {
                continue
            }

            // Adding account name at the 0th index.
            var mergedAccount = [String]()
            dfs(&mergedAccount, accountFirstEmail)
            let accountNameAndSortedEmails: [String] = [accountName] + mergedAccount.sorted()
            mergedAccounts.append(accountNameAndSortedEmails)
        }

        return mergedAccounts
    }
}",True
Remove Comments,"Given a C++ program, remove comments from it. The program source is an array of strings source where source[i] is the ith line of the source code. This represents the result of splitting the original source code string by the newline character '\n'.
In C++, there are two types of comments, line comments, and block comments.
The string ""//"" denotes a line comment, which represents that it and the rest of the characters to the right of it in the same line should be ignored.
The string ""/*"" denotes a block comment, which represents that all characters until the next (non-overlapping) occurrence of ""*/"" should be ignored. (Here, occurrences happen in reading order: line by line from left to right.) To be clear, the string ""/*/"" does not yet end the block comment, as the ending would be overlapping the beginning.
The first effective comment takes precedence over others.
For example, if the string ""//"" occurs in a block comment, it is ignored.
Similarly, if the string ""/*"" occurs in a line or block comment, it is also ignored.
If a certain line of code is empty after removing comments, you must not output that line: each string in the answer list will be non-empty.
There will be no control characters, single quote, or double quote characters.
For example, source = ""string s = ""/* Not a comment. */"";"" will not be a test case.
Also, nothing else such as defines or macros will interfere with the comments.
It is guaranteed that every open block comment will eventually be closed, so ""/*"" outside of a line or block comment always starts a new comment.
Finally, implicit newline characters can be deleted by block comments. Please see the examples below for details.
After removing the comments from the source code, return the source code in the same format.
","Example 1:
Input: source = [""/*Test program */"", ""int main()"", ""{ "", ""  // variable declaration "", ""int a, b, c;"", ""/* This is a test"", ""   multiline  "", ""   comment for "", ""   testing */"", ""a = b + c;"", ""}""]
Output: [""int main()"",""{ "",""  "",""int a, b, c;"",""a = b + c;"",""}""]
Explanation: The line by line code is visualized as below:
/*Test program */
int main()
{ 
  // variable declaration 
int a, b, c;
/* This is a test
   multiline  
   comment for 
   testing */
a = b + c;
}
The string /* denotes a block comment, including line 1 and lines 6-9. The string // denotes line 4 as comments.
The line by line output code is visualized as below:
int main()
{ 
  
int a, b, c;
a = b + c;
}
Example 2:
Input: source = [""a/*comment"", ""line"", ""more_comment*/b""]
Output: [""ab""]
Explanation: The original source string is ""a/*comment\nline\nmore_comment*/b"", where we have bolded the newline characters.  After deletion, the implicit newline characters are deleted, leaving the string ""ab"", which when delimited by newline characters becomes [""ab""].
",,False
Find Pivot Index,"Given an array of integers nums, calculate the pivot index of this array.
The pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index's right.
If the index is on the left edge of the array, then the left sum is 0 because there are no elements to the left. This also applies to the right edge of the array.
Return the leftmost pivot index. If no such index exists, return -1.
","Example 1:
Input: nums = [1,7,3,6,5,6]
Output: 3
Explanation:
The pivot index is 3.
Left sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11
Right sum = nums[4] + nums[5] = 5 + 6 = 11
Example 2:
Input: nums = [1,2,3]
Output: -1
Explanation:
There is no index that satisfies the conditions in the problem statement.
Example 3:
Input: nums = [2,1,-1]
Output: 0
Explanation:
The pivot index is 0.
Left sum = 0 (no elements to the left of index 0)
Right sum = nums[1] + nums[2] = 1 + -1 = 0
","class Solution {
    public int pivotIndex(int[] nums) {

        int preSum = 0;
        int suffSum = 0;

        int len = nums.length;

        int i = 0;
        
        for(int j  = 1; j < len; j++) {
            suffSum += nums[j];
        }
        
        if(preSum == suffSum) return 0;

        while(i < len-1) {
            preSum += nums[i];
            i++;
            suffSum -= nums[i];
            if(preSum == suffSum) return i;
        }

        return -1;
    }
}",False
My Calendar I,"You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a double booking.
A double booking happens when two events have some non-empty intersection (i.e., some moment is common to both events.).
The event can be represented as a pair of integers start and end that represents a booking on the half-open interval [start, end), the range of real numbers x such that start <= x < end.
Implement the MyCalendar class:
MyCalendar() Initializes the calendar object.
boolean book(int start, int end) Returns true if the event can be added to the calendar successfully without causing a double booking. Otherwise, return false and do not add the event to the calendar.
","Example 1:
Input
[""MyCalendar"", ""book"", ""book"", ""book""]
[[], [10, 20], [15, 25], [20, 30]]
Output
[null, true, false, true]

Explanation
MyCalendar myCalendar = new MyCalendar();
myCalendar.book(10, 20); // return True
myCalendar.book(15, 25); // return False, It can not be booked because time 15 is already booked by another event.
myCalendar.book(20, 30); // return True, The event can be booked, as the first event takes every time less than 20, but not including 20.
",,False
My Calendar II,"You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a triple booking.
A triple booking happens when three events have some non-empty intersection (i.e., some moment is common to all the three events.).
The event can be represented as a pair of integers start and end that represents a booking on the half-open interval [start, end), the range of real numbers x such that start <= x < end.
Implement the MyCalendarTwo class:
MyCalendarTwo() Initializes the calendar object.
boolean book(int start, int end) Returns true if the event can be added to the calendar successfully without causing a triple booking. Otherwise, return false and do not add the event to the calendar.
","Example 1:
Input
[""MyCalendarTwo"", ""book"", ""book"", ""book"", ""book"", ""book"", ""book""]
[[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]
Output
[null, true, true, true, false, true, true]

Explanation
MyCalendarTwo myCalendarTwo = new MyCalendarTwo();
myCalendarTwo.book(10, 20); // return True, The event can be booked. 
myCalendarTwo.book(50, 60); // return True, The event can be booked. 
myCalendarTwo.book(10, 40); // return True, The event can be double booked. 
myCalendarTwo.book(5, 15);  // return False, The event cannot be booked, because it would result in a triple booking.
myCalendarTwo.book(5, 10); // return True, The event can be booked, as it does not use time 10 which is already double booked.
myCalendarTwo.book(25, 55); // return True, The event can be booked, as the time in [25, 40) will be double booked with the third event, the time [40, 50) will be single booked, and the time [50, 55) will be double booked with the second event.
",,False
Flood Fill,"An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image.
You are also given three integers sr, sc, and color. You should perform a flood fill on the image starting from the pixel image[sr][sc].
To perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with color.
Return the modified image after performing the flood fill.
","Example 1:

Input: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, color = 2
Output: [[2,2,2],[2,2,0],[2,0,1]]
Explanation: From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.
Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.
Example 2:
Input: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, color = 0
Output: [[0,0,0],[0,0,0]]
Explanation: The starting pixel is already colored 0, so no changes are made to the image.
","class Solution {
public:
    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {
        
        int inicolor = image[sr][sc];
        vector<vector<int>> ans = image;
        int delrow[] = {-1,0,1,0};
        int delcol[] = {0,1,0,-1};
        dfs(sr,sc,ans,image,color,delrow,delcol,inicolor);
        return ans;

    }

    void dfs(int row, int col, vector<vector<int>> &ans, vector<vector<int>> &image, int color, int delrow[], int delcol[], int inicolor){

        ans[row][col] = color;
        int n = image.size();
        int m = image[0].size();

        for(int i=0;i<4;i++)
        {
            int nrow = row + delrow[i];
            int ncol = col + delcol[i];

            if(nrow >= 0 && nrow < n && ncol>=0 && ncol<m &&  image[nrow][ncol] == inicolor && ans[nrow][ncol] != color){
                dfs(nrow,ncol,ans,image,color,delrow,delcol,inicolor);
            }
        }
        

    }
};",False
Asteroid Collision,"We are given an array asteroids of integers representing asteroids in a row.
For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.
Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.
","Example 1:
Input: asteroids = [5,10,-5]
Output: [5,10]
Explanation: The 10 and -5 collide resulting in 10. The 5 and 10 never collide.
Example 2:
Input: asteroids = [8,-8]
Output: []
Explanation: The 8 and -8 collide exploding each other.
Example 3:
Input: asteroids = [10,2,-5]
Output: [10]
Explanation: The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10.
","class Solution {
public:
    vector<int> asteroidCollision(vector<int>& asteroids) {
        stack<int> s;
        s.push(asteroids[asteroids.size()-1]);
        int i = asteroids.size()-2;
        while(i>=0){
            if(s.empty())s.push(asteroids[i]);
            else if(s.top()<0 && asteroids[i]>0){
                if(abs(s.top())<abs(asteroids[i])){
                    s.pop();
                    i++;
                }
                else if(abs(s.top())==abs(asteroids[i]))s.pop();
            }
            else{
                s.push(asteroids[i]);
            }
            i--;
        }
        vector<int>ans;
        while(!s.empty()){
            ans.push_back(s.top());
            s.pop();
        }
        return ans;
    }
};",False
Daily Temperatures,"Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.
","Example 1:
Input: temperatures = [73,74,75,71,69,72,76,73]
Output: [1,1,4,2,1,1,0,0]
Example 2:
Input: temperatures = [30,40,50,60]
Output: [1,1,1,0]
Example 3:
Input: temperatures = [30,60,90]
Output: [1,1,0]
","class Solution:
    def dailyTemperatures(self, temp: List[int]) -> List[int]:
        # Stack to store indices of temperatures
        s = []
        # Initialize result list with zeros for each day
        res = [0] * len(temp)
        
        # Iterate temperatures in reverse order
        for i in range(len(temp)-1, -1, -1):
            # Pop elements while current temperature is greater or equal
            while s and temp[s[-1]] <= temp[i]:
                s.pop()
            
            # Calculate days until a warmer temperature, or 0 if none
            res[i] = 0 if len(s) == 0 else s[-1] - i
            
            # Push current index onto the stack
            s.append(i)
        
        return res",True
Delete and Earn,"You are given an integer array nums. You want to maximize the number of points you get by performing the following operation any number of times:
Pick any nums[i] and delete it to earn nums[i] points. Afterwards, you must delete every element equal to nums[i] - 1 and every element equal to nums[i] + 1.
Return the maximum number of points you can earn by applying the above operation some number of times.
","Example 1:
Input: nums = [3,4,2]
Output: 6
Explanation: You can perform the following operations:
- Delete 4 to earn 4 points. Consequently, 3 is also deleted. nums = [2].
- Delete 2 to earn 2 points. nums = [].
You earn a total of 6 points.
Example 2:
Input: nums = [2,2,3,3,3,4]
Output: 9
Explanation: You can perform the following operations:
- Delete a 3 to earn 3 points. All 2's and 4's are also deleted. nums = [3,3].
- Delete a 3 again to earn 3 points. nums = [3].
- Delete a 3 once more to earn 3 points. nums = [].
You earn a total of 9 points.
","class Solution {
public:
    
   int deleteAndEarn(vector<int>& nums) {
	   
        vector<int> arr(10001, 0);
        vector<int> dp(10001, 0);
        for(int i = 0; i < nums.size(); i++)
        {
			// arr stores the maximum sum we could generate if we select all the elements equal to nums[i]
			// if nums is [2, 2, 3, 3, 3, 4] then arr would be [0, 0, 4, 9, 4]
            arr[nums[i]] += nums[i];
        }
        
        dp[0] = arr[0];
        dp[1] = max(arr[0], arr[1]);
        
        for(int i = 2; i < 10001; i++)
        {
            dp[i] = max(dp[i - 1], arr[i] + dp[i - 2]);
        }    
        return dp[10000];
    }
};",False
Find Smallest Letter Greater Than Target,"You are given an array of characters letters that is sorted in non-decreasing order, and a character target. There are at least two different characters in letters.
Return the smallest character in letters that is lexicographically greater than target. If such a character does not exist, return the first character in letters.
","Example 1:
Input: letters = [""c"",""f"",""j""], target = ""a""
Output: ""c""
Explanation: The smallest character that is lexicographically greater than 'a' in letters is 'c'.
Example 2:
Input: letters = [""c"",""f"",""j""], target = ""c""
Output: ""f""
Explanation: The smallest character that is lexicographically greater than 'c' in letters is 'f'.
Example 3:
Input: letters = [""x"",""x"",""y"",""y""], target = ""z""
Output: ""x""
Explanation: There are no characters in letters that is lexicographically greater than 'z' so we return letters[0].
","class Solution {
public:
    char nextGreatestLetter(vector<char>& letters, char target) {
        int low=0, high=letters.size()-1;
        if(letters[0] > target || target >= letters[letters.size()-1])
            return letters[0];  
        char ans;  
        while(low <= high)
        {
            int mid=(low+high)/2;
            if(letters[mid] > target){
                ans = letters[mid];
                high = mid-1;
            }
            else
                low = mid+1;
        }
        return ans;
    }
};",False
Valid Boomerang,"Given an array points where points[i] = [xi, yi] represents a point on the X-Y plane, return true if these points are a boomerang.
A boomerang is a set of three points that are all distinct and not in a straight line.
","Example 1:
Input: points = [[1,1],[2,3],[3,2]]
Output: true
Example 2:
Input: points = [[1,1],[2,2],[3,3]]
Output: false
","class Solution:
    def isBoomerang(self, points: List[List[int]]) -> bool:
        # Check if points are collinear.
        collinearVal = points[0][0]*(points[1][1] - points[2][1]) + points[1][0]*(points[2][1] - points[0][1]) + points[2][0]*(points[0][1] - points[1][1]) 
        
        if collinearVal == 0:
            return False
            
        for i in range(len(points)):
            for j in range(i+1, len(points)):
                #  If any two points are equal, return false.
                if points[i][0] == points[j][0] and points[i][1] == points[j][1]:
                    return False
                    
        return True
        ",True
Partition Array for Maximum Sum,"Given an integer array arr, partition the array into (contiguous) subarrays of length at most k. After partitioning, each subarray has their values changed to become the maximum value of that subarray.
Return the largest sum of the given array after partitioning. Test cases are generated so that the answer fits in a 32-bit integer.
","Example 1:
Input: arr = [1,15,7,9,2,5,10], k = 3
Output: 84
Explanation: arr becomes [15,15,15,9,10,10,10]
Example 2:
Input: arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4
Output: 83
Example 3:
Input: arr = [1], k = 1
Output: 1
","class Solution:
    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:
        # Length of the input array
        n = len(arr)
        
        # Dynamic programming table to store maximum sum at each position
        dp = [0]*(n+1)
        
        # Iterate through the array elements
        for i in range(n):
            curMax = curSum = 0
            
            # Iterate over the last k elements or until the beginning of the array
            for j in range(i, max(-1, i-k), -1):
                # Update the maximum value in the current partition
                if curMax < arr[j]:
                    curMax = arr[j]
                
                # Calculate the current sum considering the maximum value in the partition
                cur = curMax * (i - j + 1) + dp[j]
                
                # Update the current sum if the new one is greater
                if curSum < cur:
                    curSum = cur
            
            # Update the dynamic programming table with the maximum sum at the current position
            dp[i+1] = curSum
        
        return dp[-1]",True
Height Checker,"A school is trying to take an annual photo of all the students. The students are asked to stand in a single file line in non-decreasing order by height. Let this ordering be represented by the integer array expected where expected[i] is the expected height of the ith student in line.
You are given an integer array heights representing the current order that the students are standing in. Each heights[i] is the height of the ith student in line (0-indexed).
Return the number of indices where heights[i] != expected[i].
","Example 1:
Input: heights = [1,1,4,2,1,3]
Output: 3
Explanation: 
heights:  [1,1,4,2,1,3]
expected: [1,1,1,2,3,4]
Indices 2, 4, and 5 do not match.
Example 2:
Input: heights = [5,1,2,3,4]
Output: 5
Explanation:
heights:  [5,1,2,3,4]
expected: [1,2,3,4,5]
All indices do not match.
Example 3:
Input: heights = [1,2,3,4,5]
Output: 0
Explanation:
heights:  [1,2,3,4,5]
expected: [1,2,3,4,5]
All indices match.
","class Solution:
    def heightChecker(self, heights: List[int]) -> int:
        sort_heights = sorted(heights)
        return sum([0 if heights[i] == sort_heights[i] else 1 for i in range(len(heights))])",True
Duplicate Zeros,"Given a fixed-length integer array arr, duplicate each occurrence of zero, shifting the remaining elements to the right.
Note that elements beyond the length of the original array are not written. Do the above modifications to the input array in place and do not return anything.
","Example 1:
Input: arr = [1,0,2,3,0,4,5,0]
Output: [1,0,0,2,3,0,0,4]
Explanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4]
Example 2:
Input: arr = [1,2,3]
Output: [1,2,3]
Explanation: After calling your function, the input array is modified to: [1,2,3]
","class Solution:
    def duplicateZeros(self, arr: List[int]) -> None:
        """"""
        Do not return anything, modify arr in-place instead.
        """"""
        
            <!-- use while loop to contorl ""i"" -->
        i=0
        while(i<len(arr)):
            if(arr[i]==0):
                arr.insert(i,0)

            <!-- i+2 for skip the insert index -->
                i=i+2
                arr.pop()
            else:
                i=i+1
 ",True
Corporate Flight Bookings,"There are n flights that are labeled from 1 to n.
You are given an array of flight bookings bookings, where bookings[i] = [firsti, lasti, seatsi] represents a booking for flights firsti through lasti (inclusive) with seatsi seats reserved for each flight in the range.
Return an array answer of length n, where answer[i] is the total number of seats reserved for flight i.
","Example 1:
Input: bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5
Output: [10,55,45,25,25]
Explanation:
Flight labels:        1   2   3   4   5
Booking 1 reserved:  10  10
Booking 2 reserved:      20  20
Booking 3 reserved:      25  25  25  25
Total seats:         10  55  45  25  25
Hence, answer = [10,55,45,25,25]
Example 2:
Input: bookings = [[1,2,10],[2,2,15]], n = 2
Output: [10,25]
Explanation:
Flight labels:        1   2
Booking 1 reserved:  10  10
Booking 2 reserved:      15
Total seats:         10  25
Hence, answer = [10,25]
","class Solution:
    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:
        ans = [0]*n
        m = len(bookings)
        for start,end,seats in bookings:
            ans[start-1]+=seats
            if end < n : ans[end] -= seats
        for i in range(1,n):
            ans[i] += ans[i-1]
        return ans",True
Delete Nodes And Return Forest,"Given the root of a binary tree, each node in the tree has a distinct value.
After deleting all nodes with a value in to_delete, we are left with a forest (a disjoint union of trees).
Return the roots of the trees in the remaining forest. You may return the result in any order.
","Example 1:

Input: root = [1,2,3,4,5,6,7], to_delete = [3,5]
Output: [[1,2,null,4],[6],[7]]
Example 2:
Input: root = [1,2,4,null,3], to_delete = [3]
Output: [[1,2,4]]
",,False
Mean of Array After Removing Some Elements,"Given an integer array arr, return the mean of the remaining integers after removing the smallest 5% and the largest 5% of the elements.
Answers within 10-5 of the actual answer will be considered accepted.
","Example 1:
Input: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]
Output: 2.00000
Explanation: After erasing the minimum and the maximum values of this array, all elements are equal to 2, so the mean is 2.
Example 2:
Input: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]
Output: 4.00000
Example 3:
Input: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]
Output: 4.77778
","class Solution:
    def trimMean(self, arr: List[int]) -> float:
        x=arr.sort()
        len1=len(arr)
        y=len1//20
        sum1=sum(arr[y:len1-y])
        return sum1/(len1-2*y)
        #please do upvote it will encourage me alot",True
Relative Sort Array,"Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all elements in arr2 are also in arr1.
Sort the elements of arr1 such that the relative ordering of items in arr1 are the same as in arr2. Elements that do not appear in arr2 should be placed at the end of arr1 in ascending order.
","Example 1:
Input: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]
Output: [2,2,2,1,4,3,3,9,6,7,19]
Example 2:
Input: arr1 = [28,6,22,8,44,17], arr2 = [22,28,8,6]
Output: [22,28,8,6,17,44]
","class Solution:
    def relativeSortArray(self, arr1, arr2):
        dict={}
        nums,ans = [], []
        
        for val in arr2:
            dict[val] = 0
        
        for val in arr1:
            if val not in dict:
                nums.append(val)
            else: 
                dict[val] += 1
                
        for key, val in dict.items():
            ans.extend([key for _ in range(val)])
        
        ans.extend(sorted(nums))
        return ans",True
Element Appearing More Than 25% In Sorted Array,"Given an integer array sorted in non-decreasing order, there is exactly one integer in the array that occurs more than 25% of the time, return that integer.
","Example 1:
Input: arr = [1,2,2,6,6,6,6,7,10]
Output: 6
Example 2:
Input: arr = [1,1]
Output: 1
","class Solution:
    def findSpecialInteger(self, arr: List[int]) -> int:
        n= len(arr)
        threshold= n//4

        candidate=arr[0]
        count = 1
        for i in range(1,n):
            if arr[i] == candidate:
                count+=1
            else:
                count = 1
                candidate = arr[i]
            if count > threshold:
                return candidate
        return arr[0]

        ",True
Replace Elements with Greatest Element on Right Side,"Given an array arr, replace every element in that array with the greatest element among the elements to its right, and replace the last element with -1.
After doing so, return the array.
","Example 1:
Input: arr = [17,18,5,4,6,1]
Output: [18,6,6,6,1,-1]
Explanation: 
- index 0 --> the greatest element to the right of index 0 is index 1 (18).
- index 1 --> the greatest element to the right of index 1 is index 4 (6).
- index 2 --> the greatest element to the right of index 2 is index 4 (6).
- index 3 --> the greatest element to the right of index 3 is index 4 (6).
- index 4 --> the greatest element to the right of index 4 is index 5 (1).
- index 5 --> there are no elements to the right of index 5, so we put -1.
Example 2:
Input: arr = [400]
Output: [-1]
Explanation: There are no elements to the right of index 0.
","class Solution {
public:
    vector<int> replaceElements(vector<int>& arr) {
        int n = arr.size();
        for(int i=0; i<n-1; i++){
            arr[i] = *max_element(arr.begin()+i+1, arr.end());
        }
        arr[n-1] = -1;
        return arr;
    }
};",False
Largest 1-Bordered Square,"Given a 2D grid of 0s and 1s, return the number of elements in the largest square subgrid that has all 1s on its border, or 0 if such a subgrid doesn't exist in the grid.
","Example 1:
Input: grid = [[1,1,1],[1,0,1],[1,1,1]]
Output: 9
Example 2:
Input: grid = [[1,1,0,0]]
Output: 1
","class Solution:
    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:
        N,M = len(grid), len(grid[0])
        largest_square = 0
        for start_r in range(N):
            for start_c in range(M):
                for i in range(0, min(M-start_c, N-start_r)):
                    valid_square = True
                    if not (grid[start_r][start_c+i] and grid[start_r+i][start_c]):
                        valid_square = False
                        break
                    for j in range(0, i+1):
                        if not (grid[start_r+i][start_c+i-j] and grid[start_r+i-j][start_c+i]):
                            valid_square = False
                            break
                    if valid_square:
                        largest_square = max(largest_square, (i+1)*(i+1))
        return largest_square


",True
Stone Game II,"Alice and Bob continue their games with piles of stones.  There are a number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].  The objective of the game is to end with the most stones. 
Alice and Bob take turns, with Alice starting first.  Initially, M = 1.
On each player's turn, that player can take all the stones in the first X remaining piles, where 1 <= X <= 2M.  Then, we set M = max(M, X).
The game continues until all the stones have been taken.
Assuming Alice and Bob play optimally, return the maximum number of stones Alice can get.
","Example 1:
Input: piles = [2,7,9,4,4]
Output: 10
Explanation:  If Alice takes one pile at the beginning, Bob takes two piles, then Alice takes 2 piles again. Alice can get 2 + 4 + 4 = 10 piles in total. If Alice takes two piles at the beginning, then Bob can take all three piles left. In this case, Alice get 2 + 7 = 9 piles in total. So we return 10 since it's larger. 
Example 2:
Input: piles = [1,2,3,4,5,100]
Output: 104
",,False
Decompress Run-Length Encoded List,"We are given a list nums of integers representing a list compressed with run-length encoding.
Consider each adjacent pair of elements [freq, val] = [nums[2*i], nums[2*i+1]] (with i >= 0).  For each such pair, there are freq elements with value val concatenated in a sublist. Concatenate all the sublists from left to right to generate the decompressed list.
Return the decompressed list.
","Example 1:
Input: nums = [1,2,3,4]
Output: [2,4,4,4]
Explanation: The first pair [1,2] means we have freq = 1 and val = 2 so we generate the array [2].
The second pair [3,4] means we have freq = 3 and val = 4 so we generate [4,4,4].
At the end the concatenation [2] + [4,4,4] is [2,4,4,4].
Example 2:
Input: nums = [1,1,2,3]
Output: [1,3,3]
","class Solution:
    def decompressRLElist(self, nums: List[int]) -> List[int]:
        answer = []
        for i in range(len(nums)//2):
            answer += nums[2*i]*[nums[2*i+1]]
        return answer",True
Snapshot Array,"Implement a SnapshotArray that supports the following interface:
SnapshotArray(int length) initializes an array-like data structure with the given length. Initially, each element equals 0.
void set(index, val) sets the element at the given index to be equal to val.
int snap() takes a snapshot of the array and returns the snap_id: the total number of times we called snap() minus 1.
int get(index, snap_id) returns the value at the given index, at the time we took the snapshot with the given snap_id
","Example 1:
Input: [""SnapshotArray"",""set"",""snap"",""set"",""get""]
[[3],[0,5],[],[0,6],[0,0]]
Output: [null,null,0,null,5]
Explanation: 
SnapshotArray snapshotArr = new SnapshotArray(3); // set the length to be 3
snapshotArr.set(0,5);  // Set array[0] = 5
snapshotArr.snap();  // Take a snapshot, return snap_id = 0
snapshotArr.set(0,6);
snapshotArr.get(0,0);  // Get the value of array[0] with snap_id = 0, return 5
",,False
Rank Transform of an Array,"Given an array of integers arr, replace each element with its rank.
The rank represents how large the element is. The rank has the following rules:
Rank is an integer starting from 1.
The larger the element, the larger the rank. If two elements are equal, their rank must be the same.
Rank should be as small as possible.
","Example 1:
Input: arr = [40,10,20,30]
Output: [4,1,2,3]
Explanation: 40 is the largest element. 10 is the smallest. 20 is the second smallest. 30 is the third smallest.
Example 2:
Input: arr = [100,100,100]
Output: [1,1,1]
Explanation: Same elements share the same rank.
Example 3:
Input: arr = [37,12,28,9,100,56,80,5,12]
Output: [5,3,4,2,8,6,7,1,3]
","class Solution:
    def arrayRankTransform(self, arr: List[int]) -> List[int]:
        rank = {ele: i + 1 for i, ele in enumerate(sorted(set(arr)))}
        return list(map(rank.get, arr))",True
Compare Strings by Frequency of the Smallest Character,"Let the function f(s) be the frequency of the lexicographically smallest character in a non-empty string s. For example, if s = ""dcce"" then f(s) = 2 because the lexicographically smallest character is 'c', which has a frequency of 2.
You are given an array of strings words and another array of query strings queries. For each query queries[i], count the number of words in words such that f(queries[i]) < f(W) for each W in words.
Return an integer array answer, where each answer[i] is the answer to the ith query.
","Example 1:
Input: queries = [""cbd""], words = [""zaaaz""]
Output: [1]
Explanation: On the first query we have f(""cbd"") = 1, f(""zaaaz"") = 3 so f(""cbd"") < f(""zaaaz"").
Example 2:
Input: queries = [""bbb"",""cc""], words = [""a"",""aa"",""aaa"",""aaaa""]
Output: [1,2]
Explanation: On the first query only f(""bbb"") < f(""aaaa""). On the second query both f(""aaa"") and f(""aaaa"") are both > f(""cc"").
","class Solution:
    def numSmallerByFrequency(self, queries: List[str], words: List[str]) -> List[int]:
        answer = []
        for word_id, word in enumerate(words):
            word               = sorted(word)
            freq               = word.count(word[0])
            words[word_id]     = freq
        for query_id, query in enumerate(queries):
            query              = sorted(query)
            freq               = query.count(query[0])
            queries[query_id]  = freq
        words   = sorted(words)
        for query_freq in queries:
            left, right = 0, len(words) - 1
            count       = 0
            while left <= right:
                mid = (left + right) // 2
                if(words[mid] > query_freq):
                    count += (right + 1) - mid 
                    right  = mid - 1
                else:
                    left   = mid + 1
            answer.append(count)
        return answer





",True
Can Make Palindrome from Substring,"You are given a string s and array queries where queries[i] = [lefti, righti, ki]. We may rearrange the substring s[lefti...righti] for each query and then choose up to ki of them to replace with any lowercase English letter.
If the substring is possible to be a palindrome string after the operations above, the result of the query is true. Otherwise, the result is false.
Return a boolean array answer where answer[i] is the result of the ith query queries[i].
Note that each letter is counted individually for replacement, so if, for example s[lefti...righti] = ""aaa"", and ki = 2, we can only replace two of the letters. Also, note that no query modifies the initial string s.
","Example :
Input: s = ""abcda"", queries = [[3,3,0],[1,2,0],[0,3,1],[0,3,2],[0,4,1]]
Output: [true,false,false,true,true]
Explanation:
queries[0]: substring = ""d"", is palidrome.
queries[1]: substring = ""bc"", is not palidrome.
queries[2]: substring = ""abcd"", is not palidrome after replacing only 1 character.
queries[3]: substring = ""abcd"", could be changed to ""abba"" which is palidrome. Also this can be changed to ""baab"" first rearrange it ""bacd"" then replace ""cd"" with ""ab"".
queries[4]: substring = ""abcda"", could be changed to ""abcba"" which is palidrome.
Example 2:
Input: s = ""lyb"", queries = [[0,1,0],[2,2,1]]
Output: [false,true]
","class Solution:
    def canMakePaliQueries(self, s, queries):
        def bg(d):
            return sum([1 for key,val in d.items() if val%2 == 1])//2
        
        n, dict1, dict2, res = len(s), Counter(), defaultdict(int), []

        for i in range(n):
            dict1[s[i]] += 1
            dict2[i] = dict1.copy()

        for i,j,k in queries:
            if i:
                res.append(bg(dict2[j]-dict2[i-1]) <= k)
            else:
                res.append(bg(dict2[j]) <= k)

        return res ",True
Distance Between Bus Stops,"A bus has n stops numbered from 0 to n - 1 that form a circle. We know the distance between all pairs of neighboring stops where distance[i] is the distance between the stops number i and (i + 1) % n.
The bus goes along both directions i.e. clockwise and counterclockwise.
Return the shortest distance between the given start and destination stops.
","Example 1:

Input: distance = [1,2,3,4], start = 0, destination = 1
Output: 1
Explanation: Distance between 0 and 1 is 1 or 9, minimum is 1.
","class Solution:
    def distanceBetweenBusStops(self, distance: List[int], start: int, destination: int) -> int:
        total = sum(distance)
        route = sum(distance[min(start,destination):max(start,destination)])
        return  min(total - route, route)
        ",True
Maximum Subarray Sum with One Deletion,"Given an array of integers, return the maximum sum for a non-empty subarray (contiguous elements) with at most one element deletion. In other words, you want to choose a subarray and optionally delete one element from it so that there is still at least one element left and the sum of the remaining elements is maximum possible.
Note that the subarray needs to be non-empty after deleting one element.
","Example 1:
Input: arr = [1,-2,0,3]
Output: 4
Explanation: Because we can choose [1, -2, 0, 3] and drop -2, thus the subarray [1, 0, 3] becomes the maximum value.
Example 2:
Input: arr = [1,-2,-2,3]
Output: 3
Explanation: We just choose [3] and it's the maximum sum.
Example 3:
Input: arr = [-1,-1,-1,-1]
Output: -1
Explanation: The final subarray needs to be non-empty. You can't choose [-1] and delete -1 from it, then get an empty subarray to make the sum equals to 0.
","class Solution:
    def maximumSum(self, arr):
        n = len(arr)

        @lru_cache(None)
        def dfs(i,delete):
            if i == n-1: return arr[i]
            if delete == 0: return max(dfs(i+1,delete)+arr[i],arr[i])
            return max(dfs(i+1,delete)+arr[i],dfs(i+1,delete-1),arr[i])

        return max([dfs(i,1) for i in range(n)])",True
Three Consecutive Odds,"arr
true
false
","Example 1:
Input: arr = [2,6,4,1]
Output: false
Explanation: There are no three consecutive odds.
Example 2:
Input: arr = [1,2,34,3,4,5,7,23,12]
Output: true
Explanation: [5,7,23] are three consecutive odds.
","class Solution:
    def threeConsecutiveOdds(self, arr: List[int]) -> bool:
        c=0
        for i in arr:
            if i%2==0:
                c=0
            else:
                c+=1
                if c==3:
                    return True
        return False",True
K-Concatenation Maximum Sum,"Given an integer array arr and an integer k, modify the array by repeating it k times.
For example, if arr = [1, 2] and k = 3 then the modified array will be [1, 2, 1, 2, 1, 2].
Return the maximum sub-array sum in the modified array. Note that the length of the sub-array can be 0 and its sum in that case is 0.
As the answer can be very large, return the answer modulo 109 + 7.
","Example 1:
Input: arr = [1,2], k = 3
Output: 9
Example 2:
Input: arr = [1,-2,1], k = 5
Output: 2
Example 3:
Input: arr = [-1,-2], k = 7
Output: 0
","class Solution {
public:
    int kConcatenationMaxSum(vector<int>& arr, int k) {
        long long m = 0, c = 0, MOD = 1e9+7;
        for(int i = 0; i < arr.size(); i++) {
            c += arr[i];
            m = max(m, c);
            if(c < 0) {
                c = 0;
            }
        }
        if(k == 1) {
            return m % MOD;
        } else {
            vector<int> p = arr;
            p.insert(p.end(), arr.begin(), arr.end());
            m = 0, c = 0;
            for(int i = 0; i < p.size(); i++) {
                c += p[i];
                m = max(m, c);
                if(c < 0) {
                    c = 0;
                }
            }
           long long sum = 0;
        for (auto& num : arr) {
            sum += num;
        }
        long long o = m + ((k - 2) * sum);
        return (sum < 0) ? m % MOD : o % MOD;

        }
    }
};",False
Minimum Absolute Difference,"Given an array of distinct integers arr, find all pairs of elements with the minimum absolute difference of any two elements.
Return a list of pairs in ascending order(with respect to pairs), each pair [a, b] follows
a, b are from arr
a < b
b - a equals to the minimum absolute difference of any two elements in arr
","Example 1:
Input: arr = [4,2,1,3]
Output: [[1,2],[2,3],[3,4]]
Explanation: The minimum absolute difference is 1. List all pairs with difference equal to 1 in ascending order.
Example 2:
Input: arr = [1,3,6,10,15]
Output: [[1,3]]
Example 3:
Input: arr = [3,8,-10,23,19,-4,-14,27]
Output: [[-14,-10],[19,23],[23,27]]
",,False
Unique Number of Occurrences,"Given an array of integers arr, return true if the number of occurrences of each value in the array is unique or false otherwise.
","Example 1:
Input: arr = [1,2,2,1,1,3]
Output: true
Explanation: The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences.
Example 2:
Input: arr = [1,2]
Output: false
Example 3:
Input: arr = [-3,0,1,-3,1,1,1,-3,10,0]
Output: true
","class Solution:
    def uniqueOccurrences(self, arr: List[int]) -> bool:
        d = {}
        for num in arr:
            d[num] = d.get(num, 0) + 1
        return len(set(d.values())) == len(d)",True
Path with Maximum Probability,"You are given an undirected weighted graph of n nodes (0-indexed), represented by an edge list where edges[i] = [a, b] is an undirected edge connecting the nodes a and b with a probability of success of traversing that edge succProb[i].
Given two nodes start and end, find the path with the maximum probability of success to go from start to end and return its success probability.
If there is no path from start to end, return 0. Your answer will be accepted if it differs from the correct answer by at most 1e-5.
","Example 1:

Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2
Output: 0.25000
Explanation: There are two paths from start to end, one having a probability of success = 0.2 and the other has 0.5 * 0.5 = 0.25.
Example 2:

Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2
Output: 0.30000
Example 3:

Input: n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2
Output: 0.00000
Explanation: There is no path between 0 and 2.
","class Solution(object):
    def maxProbability(self, n, edges, succProb, start, end):
        """"""
        :type n: int
        :type edges: List[List[int]]
        :type succProb: List[float]
        :type start: int
        :type end: int
        :rtype: float
        """"""
        graph = collections.defaultdict(list)
        for i in range(len(edges)):
            s, e = edges[i]
            graph[s].append((-succProb[i], e))
            graph[e].append((-succProb[i], s))
        max_heap = [(-1, start)]
        visited = set()
        while max_heap:
            p, node = heapq.heappop(max_heap)
            if node == end:
                return -p
            visited.add(node)
            for q, adj in graph[node]:
                if adj not in visited:
                    heapq.heappush(max_heap, (-(p*q), adj))
        return 0",True
Longest Arithmetic Subsequence of Given Difference,"Given an integer array arr and an integer difference, return the length of the longest subsequence in arr which is an arithmetic sequence such that the difference between adjacent elements in the subsequence equals difference.
A subsequence is a sequence that can be derived from arr by deleting some or no elements without changing the order of the remaining elements.
","Example 1:
Input: arr = [1,2,3,4], difference = 1
Output: 4
Explanation: The longest arithmetic subsequence is [1,2,3,4].
Example 2:
Input: arr = [1,3,5,7], difference = 1
Output: 1
Explanation: The longest arithmetic subsequence is any single element.
Example 3:
Input: arr = [1,5,7,8,5,3,4,2,1], difference = -2
Output: 4
Explanation: The longest arithmetic subsequence is [7,5,3,1].
","class Solution:
    def longestSubsequence(self, arr: List[int], difference: int) -> int:
        count = {}
        for num in arr:
            next_ = num + difference
            if next_ not in count:
                count[next_] = count.get(num, 0) + 1
            else:
                count[next_] = max(count[next_], count.get(num, 0) + 1)
        return max(count.values())",True
Path with Maximum Gold,"In a gold mine grid of size m x n, each cell in this mine has an integer representing the amount of gold in that cell, 0 if it is empty.
Return the maximum amount of gold you can collect under the conditions:
Every time you are located in a cell you will collect all the gold in that cell.
From your position, you can walk one step to the left, right, up, or down.
You can't visit the same cell more than once.
Never visit a cell with 0 gold.
You can start and stop collecting gold from any position in the grid that has some gold.
","Example 1:
Input: grid = [[0,6,0],[5,8,7],[0,9,0]]
Output: 24
Explanation:
[[0,6,0],
 [5,8,7],
 [0,9,0]]
Path to get the maximum gold, 9 -> 8 -> 7.
Example 2:
Input: grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]
Output: 28
Explanation:
[[1,0,7],
 [2,0,6],
 [3,4,5],
 [0,3,0],
 [9,0,20]]
Path to get the maximum gold, 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7.
","class Solution {
    private int maxGold;

    public int getMaximumGold(int[][] grid) {
        maxGold = 0;
        int rows = grid.length;
        int cols = grid[0].length;

        // Iterate over each cell in the grid
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                // If the cell contains gold, start DFS from this cell
                if (grid[i][j] > 0) {
                    dfs(grid, i, j, 0);
                }
            }
        }
        return maxGold;
    }

    private void dfs(int[][] grid, int row, int col, int currentGold) {
        // Check for out-of-bounds or empty cell
        if (row < 0 || row >= grid.length || col < 0 || col >= grid[0].length || grid[row][col] == 0) {
            return;
        }

        // Add the gold in the current cell to the current total
        currentGold += grid[row][col];
        // Update the maximum gold collected
        maxGold = Math.max(maxGold, currentGold);

        // Save the gold amount in the current cell and mark it as visited by setting it to 0
        int temp = grid[row][col];
        grid[row][col] = 0;

        // Explore all 4 possible directions (up, down, left, right)
        dfs(grid, row - 1, col, currentGold);
        dfs(grid, row + 1, col, currentGold);
        dfs(grid, row, col - 1, currentGold);
        dfs(grid, row, col + 1, currentGold);

        // Restore the gold amount in the current cell
        grid[row][col] = temp;
    }
}",False
Check If It Is a Straight Line,"You are given an array coordinates, coordinates[i] = [x, y], where [x, y] represents the coordinate of a point. Check if these points make a straight line in the XY plane.
",,,False
Find Resultant Array After Removing Anagrams,"You are given a 0-indexed string array words, where words[i] consists of lowercase English letters.
In one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words. Keep performing this operation as long as you can select an index that satisfies the conditions.
Return words after performing all operations. It can be shown that selecting the indices for each operation in any arbitrary order will lead to the same result.
An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase using all the original letters exactly once. For example, ""dacb"" is an anagram of ""abdc"".
","Example 1:
Input: words = [""abba"",""baba"",""bbaa"",""cd"",""cd""]
Output: [""abba"",""cd""]
Explanation:
One of the ways we can obtain the resultant array is by using the following operations:
- Since words[2] = ""bbaa"" and words[1] = ""baba"" are anagrams, we choose index 2 and delete words[2].
  Now words = [""abba"",""baba"",""cd"",""cd""].
- Since words[1] = ""baba"" and words[0] = ""abba"" are anagrams, we choose index 1 and delete words[1].
  Now words = [""abba"",""cd"",""cd""].
- Since words[2] = ""cd"" and words[1] = ""cd"" are anagrams, we choose index 2 and delete words[2].
  Now words = [""abba"",""cd""].
We can no longer perform any operations, so [""abba"",""cd""] is the final answer.
Example 2:
Input: words = [""a"",""b"",""c"",""d"",""e""]
Output: [""a"",""b"",""c"",""d"",""e""]
Explanation:
No two adjacent strings in words are anagrams of each other, so no operations are performed.
","class Solution:
  def removeAnagrams(self, words: List[str]) -> List[str]:
    res = []
    prev = []

    for i in range(len(words)):
      word = words[i]
      counter = [0]*26
      for c in word:
        counter[ord(c)-ord('a')] += 1

      if counter != prev:
        res.append(word)
        prev = counter
    return res",True
Find Players With Zero or One Losses,"You are given an integer array matches where matches[i] = [winneri, loseri] indicates that the player winneri defeated player loseri in a match.
Return a list answer of size 2 where:
answer[0] is a list of all players that have not lost any matches.
answer[1] is a list of all players that have lost exactly one match.
The values in the two lists should be returned in increasing order.
Note:
You should only consider the players that have played at least one match.
The testcases will be generated such that no two matches will have the same outcome.
","Example 1:
Input: matches = [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]
Output: [[1,2,10],[4,5,7,8]]
Explanation:
Players 1, 2, and 10 have not lost any matches.
Players 4, 5, 7, and 8 each have lost one match.
Players 3, 6, and 9 each have lost two matches.
Thus, answer[0] = [1,2,10] and answer[1] = [4,5,7,8].
Example 2:
Input: matches = [[2,3],[1,3],[5,4],[6,4]]
Output: [[1,2,5,6],[]]
Explanation:
Players 1, 2, 5, and 6 have not lost any matches.
Players 3 and 4 each have lost two matches.
Thus, answer[0] = [1,2,5,6] and answer[1] = [].
","class Solution:
    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:
        winner1={}
        winner2={}

        num2={}
        for ma in matches:
            num2[ma[1]]=num2.get(ma[1],0)+1
        for ma in matches:
            if ma[0] not in num2 and ma[0] not in winner1 :
                winner1[ma[0]]=1
            if ma[0] in num2 and num2[ma[0]]==1  and ma[0] not in winner2 :
                winner2[ma[0]]=1
            if ma[1] in num2 and num2[ma[1]]==1 and ma[1] not in winner2:
                winner2[ma[1]]=1
            
            
        return [sorted(winner1.keys()),sorted(winner2.keys())]





",True
Maximum Length of a Concatenated String with Unique Characters,"You are given an array of strings arr. A string s is formed by the concatenation of a subsequence of arr that has unique characters.
Return the maximum possible length of s.
A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.
","Example 1:
Input: arr = [""un"",""iq"",""ue""]
Output: 4
Explanation: All the valid concatenations are:
- """"
- ""un""
- ""iq""
- ""ue""
- ""uniq"" (""un"" + ""iq"")
- ""ique"" (""iq"" + ""ue"")
Maximum length is 4.
Example 2:
Input: arr = [""cha"",""r"",""act"",""ers""]
Output: 6
Explanation: Possible longest valid concatenations are ""chaers"" (""cha"" + ""ers"") and ""acters"" (""act"" + ""ers"").
Example 3:
Input: arr = [""abcdefghijklmnopqrstuvwxyz""]
Output: 26
Explanation: The only string in arr has all 26 characters.
","class Solution:
    def maxLength(self, arr: List[str]) -> int:
        n = len(arr)
        def backtrack(currStrSet, index):
            if len(set(arr[index])) != len(arr[index]) or len(currStrSet.intersection(set(arr[index]))) > 0:
                return len(currStrSet)
            updatedSet = currStrSet.union(set(arr[index]))
            maxLen = len(updatedSet)
            for i in range(index + 1, n):
                updatedSetLen = backtrack(updatedSet, i)
                maxLen = max(maxLen, updatedSetLen)
            return maxLen
        maxRes = 0
        for i in range(n):
            maxRes = max(maxRes, backtrack(set(), i))
        return maxRes",True
Count Number of Nice Subarrays,"Given an array of integers nums and an integer k. A continuous subarray is called nice if there are k odd numbers on it.
Return the number of nice sub-arrays.
","Example 1:
Input: nums = [1,1,2,1,1], k = 3
Output: 2
Explanation: The only sub-arrays with 3 odd numbers are [1,1,2,1] and [1,2,1,1].
Example 2:
Input: nums = [2,4,6], k = 1
Output: 0
Explanation: There is no odd numbers in the array.
Example 3:
Input: nums = [2,2,2,1,2,2,1,2,2,2], k = 2
Output: 16
","class Solution:
    def numberOfSubarrays(self, nums: List[int], k: int) -> int:
        q = deque()
        n = len(nums)
        for i in range(len(nums)):
            if nums[i] % 2 != 0:
                q.append(i)
        q.append(n) # for the subarray can be formed by odd ele at last index
        i = 0
        subarrays = 0
        while len(q) > k:
            minWindowLen = q[k-1]
            nextWindow = q[k]
            subarrays += nextWindow - minWindowLen
            if i == q[0]:
                q.popleft()
            i += 1
        return subarrays
        

",True
Number of Closed Islands,"Given a 2D grid consists of 0s (land) and 1s (water).  An island is a maximal 4-directionally connected group of 0s and a closed island is an island totally (all left, top, right, bottom) surrounded by 1s.
Return the number of closed islands.
","Example 1:

Input: grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]
Output: 2
Explanation: 
Islands in gray are closed because they are completely surrounded by water (group of 1s).
Example 2:

Input: grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]]
Output: 1
Example 3:
Input: grid = [[1,1,1,1,1,1,1],
               [1,0,0,0,0,0,1],
               [1,0,1,1,1,0,1],
               [1,0,1,0,1,0,1],
               [1,0,1,1,1,0,1],
               [1,0,0,0,0,0,1],
               [1,1,1,1,1,1,1]]
Output: 2
","class Solution:
    def closedIsland(self, grid: List[List[int]]) -> int:
        def is_closed(pos):
            if grid[pos[0]][pos[1]]:
                return 0
            stack = [pos]
            is_closed_state = 1
            while stack:
                i, j = stack.pop()
                grid[i][j] = 1
                for x, y in dirs:
                    nx, ny = i + x, j + y
                    if not (-1 < nx < m and -1 < ny < n):
                        is_closed_state = 0
                        continue
                    if grid[nx][ny]:
                        continue
                    stack.append((nx, ny))
            return is_closed_state
        
        count = 0
        m, n = len(grid), len(grid[0])
        dirs = ((1, 0), (0, 1), (-1, 0), (0, -1))
        return sum(map(is_closed, product(range(m), range(n))))


                        
                    ",True
Find the Difference of Two Arrays,"Given two 0-indexed integer arrays nums1 and nums2, return a list answer of size 2 where:
answer[0] is a list of all distinct integers in nums1 which are not present in nums2.
answer[1] is a list of all distinct integers in nums2 which are not present in nums1.
Note that the integers in the lists may be returned in any order.
","Example 1:
Input: nums1 = [1,2,3], nums2 = [2,4,6]
Output: [[1,3],[4,6]]
Explanation:
For nums1, nums1[1] = 2 is present at index 0 of nums2, whereas nums1[0] = 1 and nums1[2] = 3 are not present in nums2. Therefore, answer[0] = [1,3].
For nums2, nums2[0] = 2 is present at index 1 of nums1, whereas nums2[1] = 4 and nums2[2] = 6 are not present in nums2. Therefore, answer[1] = [4,6].
Example 2:
Input: nums1 = [1,2,3,3], nums2 = [1,1,2,2]
Output: [[3],[]]
Explanation:
For nums1, nums1[2] and nums1[3] are not present in nums2. Since nums1[2] == nums1[3], their value is only included once and answer[0] = [3].
Every integer in nums2 is present in nums1. Therefore, answer[1] = [].
","class Solution:
    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:
        nums1 = set(nums1)
        nums2 = set(nums2)
        return [list(nums1-nums2), list((nums2-nums1))]",True
Minimum Time Visiting All Points,"On a 2D plane, there are n points with integer coordinates points[i] = [xi, yi]. Return the minimum time in seconds to visit all the points in the order given by points.
You can move according to these rules:
In 1 second, you can either:
move vertically by one unit,
move horizontally by one unit, or
move diagonally sqrt(2) units (in other words, move one unit vertically then one unit horizontally in 1 second).
You have to visit the points in the same order as they appear in the array.
You are allowed to pass through points that appear later in the order, but these do not count as visits.
","Example 1:

Input: points = [[1,1],[3,4],[-1,0]]
Output: 7
Explanation: One optimal path is [1,1] -> [2,2] -> [3,3] -> [3,4] -> [2,3] -> [1,2] -> [0,1] -> [-1,0]   
Time from [1,1] to [3,4] = 3 seconds 
Time from [3,4] to [-1,0] = 4 seconds
Total time = 7 seconds
Example 2:
Input: points = [[3,2],[-2,2]]
Output: 5
","class Solution:
    def minTimeToVisitAllPoints(self, points: List[List[int]]) ->int:
        s=0
        for i in range(len(points)-1):
            a=points[i]
            b=points[i+1]
            max1=max(a[0],b[0])
            min1=min(a[0],b[0])
            max2=max(a[1],b[1])
            min2=min(a[1],b[1])
            c=max((max1-min1),(max2-min2))  
            s+=c 
        return (s)

        ",True
Find Winner on a Tic Tac Toe Game,"Tic-tac-toe is played by two players A and B on a 3 x 3 grid. The rules of Tic-Tac-Toe are:
Players take turns placing characters into empty squares ' '.
The first player A always places 'X' characters, while the second player B always places 'O' characters.
'X' and 'O' characters are always placed into empty squares, never on filled ones.
The game ends when there are three of the same (non-empty) character filling any row, column, or diagonal.
The game also ends if all squares are non-empty.
No more moves can be played if the game is over.
Given a 2D integer array moves where moves[i] = [rowi, coli] indicates that the ith move will be played on grid[rowi][coli]. return the winner of the game if it exists (A or B). In case the game ends in a draw return ""Draw"". If there are still movements to play return ""Pending"".
You can assume that moves is valid (i.e., it follows the rules of Tic-Tac-Toe), the grid is initially empty, and A will play first.
","Example 1:

Input: moves = [[0,0],[2,0],[1,1],[2,1],[2,2]]
Output: ""A""
Explanation: A wins, they always play first.
Example 2:

Input: moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]]
Output: ""B""
Explanation: B wins.
Example 3:

Input: moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]]
Output: ""Draw""
Explanation: The game ends in a draw since there are no moves to make.
","class Solution:
    def tictactoe(self, moves: List[List[int]]) -> str:
        winner = None
        matrix = [[0 for _ in range(3)] for _ in range(3)]

        # use 1 for the first player move, 5 — the second player
        # winner sum on row/col/diagonal == 3(1+1+1) or 15(5+5+5)
        for i, (x, y) in enumerate(moves):
            matrix[x][y] = 5 if i & 1 else 1
        
        def checkWin(s):
            nonlocal winner
            if winner: return
            if s == 3: winner = 'A'
            if s == 15: winner = 'B'

        def checkRows():
            for row in matrix: checkWin(sum(row))

        def checkCols():
            for col in zip(*matrix): checkWin(sum(col))

        def checkDiagonal1():
            checkWin(matrix[0][0] + matrix[1][1] + matrix[2][2])       

        def checkDiagonal2():
            checkWin(matrix[0][2] + matrix[1][1] + matrix[2][0])

        checkRows()
        checkCols()
        checkDiagonal1()
        checkDiagonal2()

        return winner or ('Draw' if len(moves) == 9 else 'Pending')",True
Group the People Given the Group Size They Belong To,"There are n people that are split into some unknown number of groups. Each person is labeled with a unique ID from 0 to n - 1.
You are given an integer array groupSizes, where groupSizes[i] is the size of the group that person i is in. For example, if groupSizes[1] = 3, then person 1 must be in a group of size 3.
Return a list of groups such that each person i is in a group of size groupSizes[i].
Each person should appear in exactly one group, and every person must be in a group. If there are multiple answers, return any of them. It is guaranteed that there will be at least one valid solution for the given input.
","Example 1:
Input: groupSizes = [3,3,3,3,3,1,3]
Output: [[5],[0,1,2],[3,4,6]]
Explanation: 
The first group is [5]. The size is 1, and groupSizes[5] = 1.
The second group is [0,1,2]. The size is 3, and groupSizes[0] = groupSizes[1] = groupSizes[2] = 3.
The third group is [3,4,6]. The size is 3, and groupSizes[3] = groupSizes[4] = groupSizes[6] = 3.
Other possible solutions are [[2,1,6],[5],[0,4,3]] and [[5],[0,6,2],[4,3,1]].
Example 2:
Input: groupSizes = [2,1,3,3,3,2]
Output: [[1],[0,5],[2,3,4]]
","class Solution:
    def groupThePeople(self, gs: List[int]) -> List[List[int]]:
        d={}
        for i,v in enumerate(gs):
            if v in d:
                d[v].append(i)
            else:
                d|={v:[i]}
        x=sorted(d.items(),key=lambda d:d[0])
        ans=[]
        for i in x:
            for k in range(len(i[1])//i[0]):
                b=i[1][k*i[0]:(k+1)*i[0]]
                ans.append(b)
        return ans",True
Fair Distribution of Cookies,"You are given an integer array cookies, where cookies[i] denotes the number of cookies in the ith bag. You are also given an integer k that denotes the number of children to distribute all the bags of cookies to. All the cookies in the same bag must go to the same child and cannot be split up.
The unfairness of a distribution is defined as the maximum total cookies obtained by a single child in the distribution.
Return the minimum unfairness of all distributions.
","Example 1:
Input: cookies = [8,15,10,20,8], k = 2
Output: 31
Explanation: One optimal distribution is [8,15,8] and [10,20]
- The 1st child receives [8,15,8] which has a total of 8 + 15 + 8 = 31 cookies.
- The 2nd child receives [10,20] which has a total of 10 + 20 = 30 cookies.
The unfairness of the distribution is max(31,30) = 31.
It can be shown that there is no distribution with an unfairness less than 31.
Example 2:
Input: cookies = [6,1,3,2,2,4,1,2], k = 3
Output: 7
Explanation: One optimal distribution is [6,1], [3,2,2], and [4,1,2]
- The 1st child receives [6,1] which has a total of 6 + 1 = 7 cookies.
- The 2nd child receives [3,2,2] which has a total of 3 + 2 + 2 = 7 cookies.
- The 3rd child receives [4,1,2] which has a total of 4 + 1 + 2 = 7 cookies.
The unfairness of the distribution is max(7,7,7) = 7.
It can be shown that there is no distribution with an unfairness less than 7.
","class Solution {
    private int dfs(int idx, int[] distribute, int[] cookies, int k, int zeroCount) {
        if (cookies.length - idx < zeroCount) {
            return Integer.MAX_VALUE;   
        }

        if (idx == cookies.length) {
            int unfairness = Integer.MIN_VALUE;
            for (int value : distribute) {
                unfairness = Math.max(unfairness, value);
            }
            return unfairness;
        }
        
        int minUnfairness = Integer.MAX_VALUE;
        for (int j = 0; j < k; ++j) {
            zeroCount -= distribute[j] == 0 ? 1 : 0;
            distribute[j] += cookies[idx];
            
            minUnfairness = Math.min(minUnfairness, dfs(idx + 1, distribute, cookies, k, zeroCount));
            
            distribute[j] -= cookies[idx];
            zeroCount += distribute[j] == 0 ? 1 : 0;
        }
        
        return minUnfairness;
    }
    
    public int distributeCookies(int[] cookies, int k) {
        int[] distribute = new int[k];
        
        return dfs(0, distribute, cookies, k, k);
    }
}",False
Find Numbers with Even Number of Digits,"Given an array nums of integers, return how many of them contain an even number of digits.
","Example 1:
Input: nums = [12,345,2,6,7896]
Output: 2
Explanation: 
12 contains 2 digits (even number of digits). 
345 contains 3 digits (odd number of digits). 
2 contains 1 digit (odd number of digits). 
6 contains 1 digit (odd number of digits). 
7896 contains 4 digits (even number of digits). 
Therefore only 12 and 7896 contain an even number of digits.
Example 2:
Input: nums = [555,901,482,1771]
Output: 1 
Explanation: 
Only 1771 contains an even number of digits.
","class Solution:
    def findNumbers(self, nums: List[int]) -> int:
	    # We are going to take advantage of the fact that the array only contains positive integers.
		# A common formula for finding the number of digits in a positive number is digits = floor(log10(num)) + 1
		# Even if the array contained negatives, you could just do the same with the absolute value of num.
		# This turns the runtime into O(N) and there is no additional space needed so O(1) space.
		# You also don't need to convert this into a string which a lot of other solutions do and has other implications in terms of space complexity.
		# https://brilliant.org/wiki/finding-digits-of-a-number/
        result = 0
        
        for num in nums:
            num_digits = floor(log10(num)) + 1
            if num_digits % 2 == 0:
                result += 1
                
        return result",True
Get Watched Videos by Your Friends,"There are n people, each person has a unique id between 0 and n-1. Given the arrays watchedVideos and friends, where watchedVideos[i] and friends[i] contain the list of watched videos and the list of friends respectively for the person with id = i.
Level 1 of videos are all watched videos by your friends, level 2 of videos are all watched videos by the friends of your friends and so on. In general, the level k of videos are all watched videos by people with the shortest path exactly equal to k with you. Given your id and the level of videos, return the list of videos ordered by their frequencies (increasing). For videos with the same frequency order them alphabetically from least to greatest. 
","Example 1:

Input: watchedVideos = [[""A"",""B""],[""C""],[""B"",""C""],[""D""]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 1
Output: [""B"",""C""] 
Explanation: 
You have id = 0 (green color in the figure) and your friends are (yellow color in the figure):
Person with id = 1 -> watchedVideos = [""C""] 
Person with id = 2 -> watchedVideos = [""B"",""C""] 
The frequencies of watchedVideos by your friends are: 
B -> 1 
C -> 2
Example 2:

Input: watchedVideos = [[""A"",""B""],[""C""],[""B"",""C""],[""D""]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 2
Output: [""D""]
Explanation: 
You have id = 0 (green color in the figure) and the only friend of your friends is the person with id = 3 (yellow color in the figure).
","class Solution:
    def watchedVideosByFriends(self, watchedVideos: List[List[str]], friends: List[List[int]], id: int, level: int) -> List[str]:
        n = len(friends)
        adj_list = [set() for _ in range(n)]
        for src in range(n):
            for dst in friends[src]:
                adj_list[src].add(dst)
                adj_list[dst].add(src)
        visited = [False]*n
        q = deque([id]) # level = 0
        visited[id] = True
        for _ in range(level):
            l = len(q)
            for _ in range(l):
                vertex = q.popleft()
                for neighbour in adj_list[vertex]:
                    if not visited[neighbour]:
                        visited[neighbour] = True
                        q.append(neighbour)
        # q contains all numbers at level k
        # print(q)
        freq = {}
        for friend in q: 
            for videos in watchedVideos[friend]: freq[videos] = freq.get(videos,0)+1
        return [val[0] for val in sorted(freq.items(), key=lambda item: (item[1],item[0]))]",True
Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold,"Given an array of integers arr and two integers k and threshold, return the number of sub-arrays of size k and average greater than or equal to threshold.
","Example 1:
Input: arr = [2,2,2,2,5,5,5,8], k = 3, threshold = 4
Output: 3
Explanation: Sub-arrays [2,5,5],[5,5,5] and [5,5,8] have averages 4, 5 and 6 respectively. All other sub-arrays of size 3 have averages less than 4 (the threshold).
Example 2:
Input: arr = [11,13,17,23,29,31,7,5,2,3], k = 3, threshold = 5
Output: 6
Explanation: The first 6 sub-arrays of size 3 have averages greater than 5. Note that averages are not integers.
","class Solution:
    def numOfSubarrays(self, arr: List[int], k: int, threshold: int) -> int:
        count = 0
        # avg >= threshold , avg = sum(subarray) / k >= threshold
        # thus, sum(subarray) >= k * threshold
        target = k * threshold 

        curr = 0
        for i in range(k - 1):
            curr += arr[i]

        for i in range(k - 1, len(arr)):
            curr += arr[i]
            if curr >= target:
                count += 1
            curr -= arr[i - k + 1]
        
        return count",True
Print Words Vertically,"Given a string s. Return all the words vertically in the same order in which they appear in s.
Words are returned as a list of strings, complete with spaces when is necessary. (Trailing spaces are not allowed).
Each word would be put on only one column and that in one column there will be only one word.
","Example 1:
Input: s = ""HOW ARE YOU""
Output: [""HAY"",""ORO"",""WEU""]
Explanation: Each word is printed vertically. 
 ""HAY""
 ""ORO""
 ""WEU""
Example 2:
Input: s = ""TO BE OR NOT TO BE""
Output: [""TBONTB"",""OEROOE"",""   T""]
Explanation: Trailing spaces is not allowed. 
""TBONTB""
""OEROOE""
""   T""
Example 3:
Input: s = ""CONTEST IS COMING""
Output: [""CIC"",""OSO"",""N M"",""T I"",""E N"",""S G"",""T""]
","class Solution:
    def printVertically(self, s: str) -> List[str]:
        a, b, words = [], [], s.split()
        max_length = len(max(words, key=len))
        for i in words:
            if len(i) < max_length:
                i =  i + "" "" * (max_length - len(i)) 
            a.append(i)
        for i in zip(*a):
            b.append(''.join(i).rstrip())
        return b


        
",True
"Filter Restaurants by Vegan-Friendly, Price and Distance","Given the array restaurants where  restaurants[i] = [idi, ratingi, veganFriendlyi, pricei, distancei]. You have to filter the restaurants using three filters.
The veganFriendly filter will be either true (meaning you should only include restaurants with veganFriendlyi set to true) or false (meaning you can include any restaurant). In addition, you have the filters maxPrice and maxDistance which are the maximum value for price and distance of restaurants you should consider respectively.
Return the array of restaurant IDs after filtering, ordered by rating from highest to lowest. For restaurants with the same rating, order them by id from highest to lowest. For simplicity veganFriendlyi and veganFriendly take value 1 when it is true, and 0 when it is false.
","Example 1:
Input: restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 1, maxPrice = 50, maxDistance = 10
Output: [3,1,5] 
Explanation: 
The restaurants are:
Restaurant 1 [id=1, rating=4, veganFriendly=1, price=40, distance=10]
Restaurant 2 [id=2, rating=8, veganFriendly=0, price=50, distance=5]
Restaurant 3 [id=3, rating=8, veganFriendly=1, price=30, distance=4]
Restaurant 4 [id=4, rating=10, veganFriendly=0, price=10, distance=3]
Restaurant 5 [id=5, rating=1, veganFriendly=1, price=15, distance=1] 
After filter restaurants with veganFriendly = 1, maxPrice = 50 and maxDistance = 10 we have restaurant 3, restaurant 1 and restaurant 5 (ordered by rating from highest to lowest). 
Example 2:
Input: restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 50, maxDistance = 10
Output: [4,3,2,1,5]
Explanation: The restaurants are the same as in example 1, but in this case the filter veganFriendly = 0, therefore all restaurants are considered.
Example 3:
Input: restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 30, maxDistance = 3
Output: [4,5]
","class Solution:
    def filterRestaurants(self, restaurants, veganFriendly, maxPrice, maxDistance):
        result = []

        for i,r,v,p,d in restaurants:
            if veganFriendly == 1:
                if v == veganFriendly and p <= maxPrice and d <= maxDistance:
                    result.append((i,r))
            else:
                if p <= maxPrice and d <= maxDistance:
                    result.append((i,r))

        result.sort(key = lambda x:(-x[1],-x[0]))

        return [i[0] for i in result] ",True
Sort Integers by The Number of 1 Bits,"You are given an integer array arr. Sort the integers in the array in ascending order by the number of 1's in their binary representation and in case of two or more integers have the same number of 1's you have to sort them in ascending order.
Return the array after sorting it.
","Example 1:
Input: arr = [0,1,2,3,4,5,6,7,8]
Output: [0,1,2,4,8,3,5,6,7]
Explantion: [0] is the only integer with 0 bits.
[1,2,4,8] all have 1 bit.
[3,5,6] have 2 bits.
[7] has 3 bits.
The sorted array by bits is [0,1,2,4,8,3,5,6,7]
Example 2:
Input: arr = [1024,512,256,128,64,32,16,8,4,2,1]
Output: [1,2,4,8,16,32,64,128,256,512,1024]
Explantion: All integers have 1 bit in the binary representation, you should just sort them in ascending order.
","class Solution:
    def sortByBits(self, arr: List[int]) -> List[int]:

        def count_ones(num):
            count = 0
            while num:
                num &= (num - 1)
                count += 1
            return count

        one_list = []
        for n in arr:
            ones = count_ones(n)
            one_list.append((ones, n))

        heapq.heapify(one_list)
        res = []

        while one_list:
            res.append(heapq.heappop(one_list)[1])

        return res        ",True
Apply Discount Every n Orders,"There is a supermarket that is frequented by many customers. The products sold at the supermarket are represented as two parallel integer arrays products and prices, where the ith product has an ID of products[i] and a price of prices[i].
When a customer is paying, their bill is represented as two parallel integer arrays product and amount, where the jth product they purchased has an ID of product[j], and amount[j] is how much of the product they bought. Their subtotal is calculated as the sum of each amount[j] * (price of the jth product).
The supermarket decided to have a sale. Every nth customer paying for their groceries will be given a percentage discount. The discount amount is given by discount, where they will be given discount percent off their subtotal. More formally, if their subtotal is bill, then they would actually pay bill * ((100 - discount) / 100).
Implement the Cashier class:
Cashier(int n, int discount, int[] products, int[] prices) Initializes the object with n, the discount, and the products and their prices.
double getBill(int[] product, int[] amount) Returns the final total of the bill with the discount applied (if any). Answers within 10-5 of the actual value will be accepted.
","Example 1:
Input
[""Cashier"",""getBill"",""getBill"",""getBill"",""getBill"",""getBill"",""getBill"",""getBill""]
[[3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]],[[1,2],[1,2]],[[3,7],[10,10]],[[1,2,3,4,5,6,7],[1,1,1,1,1,1,1]],[[4],[10]],[[7,3],[10,10]],[[7,5,3,1,6,4,2],[10,10,10,9,9,9,7]],[[2,3,5],[5,3,2]]]
Output
[null,500.0,4000.0,800.0,4000.0,4000.0,7350.0,2500.0]
Explanation
Cashier cashier = new Cashier(3,50,[1,2,3,4,5,6,7],[100,200,300,400,300,200,100]);
cashier.getBill([1,2],[1,2]);                        // return 500.0. 1st customer, no discount.
                                                     // bill = 1 * 100 + 2 * 200 = 500.
cashier.getBill([3,7],[10,10]);                      // return 4000.0. 2nd customer, no discount.
                                                     // bill = 10 * 300 + 10 * 100 = 4000.
cashier.getBill([1,2,3,4,5,6,7],[1,1,1,1,1,1,1]);    // return 800.0. 3rd customer, 50% discount.
                                                     // Original bill = 1600
                                                     // Actual bill = 1600 * ((100 - 50) / 100) = 800.
cashier.getBill([4],[10]);                           // return 4000.0. 4th customer, no discount.
cashier.getBill([7,3],[10,10]);                      // return 4000.0. 5th customer, no discount.
cashier.getBill([7,5,3,1,6,4,2],[10,10,10,9,9,9,7]); // return 7350.0. 6th customer, 50% discount.
                                                     // Original bill = 14700, but with
                                                     // Actual bill = 14700 * ((100 - 50) / 100) = 7350.
cashier.getBill([2,3,5],[5,3,2]);                    // return 2500.0.  7th customer, no discount.
",,False
The K Weakest Rows in a Matrix,"You are given an m x n binary matrix mat of 1's (representing soldiers) and 0's (representing civilians). The soldiers are positioned in front of the civilians. That is, all the 1's will appear to the left of all the 0's in each row.
A row i is weaker than a row j if one of the following is true:
The number of soldiers in row i is less than the number of soldiers in row j.
Both rows have the same number of soldiers and i < j.
Return the indices of the k weakest rows in the matrix ordered from weakest to strongest.
","Example 1:
Input: mat = 
[[1,1,0,0,0],
 [1,1,1,1,0],
 [1,0,0,0,0],
 [1,1,0,0,0],
 [1,1,1,1,1]], 
k = 3
Output: [2,0,3]
Explanation: 
The number of soldiers in each row is: 
- Row 0: 2 
- Row 1: 4 
- Row 2: 1 
- Row 3: 2 
- Row 4: 5 
The rows ordered from weakest to strongest are [2,0,3,1,4].
Example 2:
Input: mat = 
[[1,0,0,0],
 [1,1,1,1],
 [1,0,0,0],
 [1,0,0,0]], 
k = 2
Output: [0,2]
Explanation: 
The number of soldiers in each row is: 
- Row 0: 1 
- Row 1: 4 
- Row 2: 1 
- Row 3: 1 
The rows ordered from weakest to strongest are [0,2,3,1].
","class Solution:
    def kWeakestRows(self, mat: List[List[int]], k: int) -> List[int]:
        return sorted(range(len(mat)), key = lambda x: sum(mat[x]))[:k]",True
Check If N and Its Double Exist,"Given an array arr of integers, check if there exist two indices i and j such that :
i != j
0 <= i, j < arr.length
arr[i] == 2 * arr[j]
","Example 1:
Input: arr = [10,2,5,3]
Output: true
Explanation: For i = 0 and j = 2, arr[i] == 10 == 2 * 5 == 2 * arr[j]
Example 2:
Input: arr = [3,1,7,11]
Output: false
Explanation: There is no i and j that satisfy the conditions.
","class Solution:
    def checkIfExist(self, arr: List[int]) -> bool:
        l = len(arr)
        for i in range(l-1):
            if  arr[i] * 2 in arr[0:i] + arr[i+1:]  or arr[i] / 2 in arr[0:i]+ arr[i+1:]:
                return True
        return False


 ",True
Count Negative Numbers in a Sorted Matrix,"Given a m x n matrix grid which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in grid.
","Example 1:
Input: grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]
Output: 8
Explanation: There are 8 negatives number in the matrix.
Example 2:
Input: grid = [[3,2],[1,0]]
Output: 0
","class Solution:
    def countNegatives(self, grid: List[List[int]]) -> int:
        ROWS, COLS = len(grid), len(grid[0])
        negatives = 0
        col = 0
        for row in range(ROWS - 1, -1, -1):
            while col < COLS and grid[row][col] >= 0:
                col += 1
            negatives += COLS - col
        return negatives
",True
Product of the Last K Numbers,"Design an algorithm that accepts a stream of integers and retrieves the product of the last k integers of the stream.
Implement the ProductOfNumbers class:
ProductOfNumbers() Initializes the object with an empty stream.
void add(int num) Appends the integer num to the stream.
int getProduct(int k) Returns the product of the last k numbers in the current list. You can assume that always the current list has at least k numbers.
The test cases are generated so that, at any time, the product of any contiguous sequence of numbers will fit into a single 32-bit integer without overflowing.
","Example:
Input
[""ProductOfNumbers"",""add"",""add"",""add"",""add"",""add"",""getProduct"",""getProduct"",""getProduct"",""add"",""getProduct""]
[[],[3],[0],[2],[5],[4],[2],[3],[4],[8],[2]]

Output
[null,null,null,null,null,null,20,40,0,null,32]

Explanation
ProductOfNumbers productOfNumbers = new ProductOfNumbers();
productOfNumbers.add(3);        // [3]
productOfNumbers.add(0);        // [3,0]
productOfNumbers.add(2);        // [3,0,2]
productOfNumbers.add(5);        // [3,0,2,5]
productOfNumbers.add(4);        // [3,0,2,5,4]
productOfNumbers.getProduct(2); // return 20. The product of the last 2 numbers is 5 * 4 = 20
productOfNumbers.getProduct(3); // return 40. The product of the last 3 numbers is 2 * 5 * 4 = 40
productOfNumbers.getProduct(4); // return 0. The product of the last 4 numbers is 0 * 2 * 5 * 4 = 0
productOfNumbers.add(8);        // [3,0,2,5,4,8]
productOfNumbers.getProduct(2); // return 32. The product of the last 2 numbers is 4 * 8 = 32 
",,False
Maximum Number of Events That Can Be Attended,"You are given an array of events where events[i] = [startDayi, endDayi]. Every event i starts at startDayi and ends at endDayi.
You can attend an event i at any day d where startTimei <= d <= endTimei. You can only attend one event at any time d.
Return the maximum number of events you can attend.
","Example 1:

Input: events = [[1,2],[2,3],[3,4]]
Output: 3
Explanation: You can attend all the three events.
One way to attend them all is as shown.
Attend the first event on day 1.
Attend the second event on day 2.
Attend the third event on day 3.
Example 2:
Input: events= [[1,2],[2,3],[3,4],[1,2]]
Output: 4
","class Solution:
    def maxEvents(self, events: List[List[int]]) -> int:
        # 1. person can only attend one event per day, even if there are multiple events on that day.
        # 2. if there are multiple events happen at one day,
        #    person attend the event ends close to current day.
        #.   so we need a data structure hold all the event happend today,
        #    and sorted ascedningly. minimum heap is the data structure we need.
        
        """"""
       [[1,1],[1,2],[2,2],[3,4],[4,4]]
       day one events: [1,1] [1,2]
                       events today:             heap = [1,2]
                       events expire today: none,heap = [1,2]
                       events attend: 1,         heap = [2]
       day two events: [1,2],[2,2]
                       events today:             heap = [2,2]
                       events expire today:none, heap = [2,2]
                       events attend: 2          heap = [2]
       day three events: [2,2][3,4]
                       events today:             heap = [2,4]
                       events expire today;[1,2] heap = [4]
                       events attend:3           heap = []
        """"""
        events = sorted(events,key = lambda x:(x[0],x[1]))  
        #determine the number of days has events
        n = 0
        for i in range(len(events)):
            n = max(n,events[i][1])
            
        attended = 0
        day =  0
        eventIdx = 0
        heap =[]
        
        
        for day in range(1, n + 1):
            #step 1: Add all the events ending time to the heap that start today
            while eventIdx < len(events) and events[eventIdx][0] == day:
                heappush(heap,events[eventIdx][1])
                eventIdx += 1
            
            #step 2: Remove the events expired today
            while heap and heap[0] < day:
                heappop(heap)
            
            #step 3: event that can be attended today,only one event per day.    
            if heap:
                heappop(heap)
                attended += 1
            
        return attended",True
How Many Numbers Are Smaller Than the Current Number,"Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j's such that j != i and nums[j] < nums[i].
Return the answer in an array.
","Example 1:
Input: nums = [8,1,2,2,3]
Output: [4,0,1,1,3]
Explanation: 
For nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). 
For nums[1]=1 does not exist any smaller number than it.
For nums[2]=2 there exist one smaller number than it (1). 
For nums[3]=2 there exist one smaller number than it (1). 
For nums[4]=3 there exist three smaller numbers than it (1, 2 and 2).
Example 2:
Input: nums = [6,5,4,8]
Output: [2,1,0,3]
Example 3:
Input: nums = [7,7,7,7]
Output: [0,0,0,0]
","class Solution:
    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:
      d = {}
      for index,value in enumerate(sorted(nums)):
        if value not in d:
          d[value] = index
          
      ans = [d[value] for value in nums]
      return ans",True
Rank Teams by Votes,"In a special ranking system, each voter gives a rank from highest to lowest to all teams participating in the competition.
The ordering of teams is decided by who received the most position-one votes. If two or more teams tie in the first position, we consider the second position to resolve the conflict, if they tie again, we continue this process until the ties are resolved. If two or more teams are still tied after considering all positions, we rank them alphabetically based on their team letter.
You are given an array of strings votes which is the votes of all voters in the ranking systems. Sort all teams according to the ranking system described above.
Return a string of all teams sorted by the ranking system.
","Example 1:
Input: votes = [""ABC"",""ACB"",""ABC"",""ACB"",""ACB""]
Output: ""ACB""
Explanation: 
Team A was ranked first place by 5 voters. No other team was voted as first place, so team A is the first team.
Team B was ranked second by 2 voters and ranked third by 3 voters.
Team C was ranked second by 3 voters and ranked third by 2 voters.
As most of the voters ranked C second, team C is the second team, and team B is the third.
Example 2:
Input: votes = [""WXYZ"",""XYZW""]
Output: ""XWYZ""
Explanation:
X is the winner due to the tie-breaking rule. X has the same votes as W for the first position, but X has one vote in the second position, while W does not have any votes in the second position. 
Example 3:
Input: votes = [""ZMNAGUEDSJYLBOPHRQICWFXTVK""]
Output: ""ZMNAGUEDSJYLBOPHRQICWFXTVK""
Explanation: Only one voter, so their votes are used for the ranking.
","class Solution:
    def rankTeams(self, votes: List[str]) -> str:
        if len(votes) == 1:
            return votes[0]
        
        vote_count = defaultdict(lambda: [0] * len(votes[0]))
        for vote in votes:
            for position, team in enumerate(vote):
                vote_count[team][position] -= 1
        
        h = []
        for team, votes in vote_count.items():
            heapq.heappush(h, (*votes, team))
        res = []
        while h:
            votes = heapq.heappop(h)
            res.append(votes[-1])
        return """".join(res)
",True
Find the Distance Value Between Two Arrays,"Given two integer arrays arr1 and arr2, and the integer d, return the distance value between the two arrays.
The distance value is defined as the number of elements arr1[i] such that there is not any element arr2[j] where |arr1[i]-arr2[j]| <= d.
","Example 1:
Input: arr1 = [4,5,8], arr2 = [10,9,1,8], d = 2
Output: 2
Explanation: 
For arr1[0]=4 we have: 
|4-10|=6 > d=2 
|4-9|=5 > d=2 
|4-1|=3 > d=2 
|4-8|=4 > d=2 
For arr1[1]=5 we have: 
|5-10|=5 > d=2 
|5-9|=4 > d=2 
|5-1|=4 > d=2 
|5-8|=3 > d=2
For arr1[2]=8 we have:
|8-10|=2 <= d=2
|8-9|=1 <= d=2
|8-1|=7 > d=2
|8-8|=0 <= d=2
Example 2:
Input: arr1 = [1,4,2,3], arr2 = [-4,-3,6,10,20,30], d = 3
Output: 2
Example 3:
Input: arr1 = [2,1,100,3], arr2 = [-5,-2,10,-3,7], d = 6
Output: 1
","class Solution:
    def findTheDistanceValue(self, a: List[int], b: List[int], d: int) -> int:
        # a.sort()
        b.sort()
        result = 0
        for x in a:
            l = x-d
            r = x+d
            li = bisect.bisect_left(b, l)
            ri = bisect.bisect_left(b, r)
            if li >= len(b) and ri>=len(b):
                result += 1
            elif li>=len(b) or ri>=len(b):
                continue
            elif b[li]!=l and b[ri]!=r and li==ri:
                result+=1
            else:
                continue
        return result",True
Lucky Numbers in a Matrix,"Given an m x n matrix of distinct numbers, return all lucky numbers in the matrix in any order.
A lucky number is an element of the matrix such that it is the minimum element in its row and maximum in its column.
","Example 1:
Input: matrix = [[3,7,8],[9,11,13],[15,16,17]]
Output: [15]
Explanation: 15 is the only lucky number since it is the minimum in its row and the maximum in its column.
Example 2:
Input: matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]]
Output: [12]
Explanation: 12 is the only lucky number since it is the minimum in its row and the maximum in its column.
Example 3:
Input: matrix = [[7,8],[1,2]]
Output: [7]
Explanation: 7 is the only lucky number since it is the minimum in its row and the maximum in its column.
","class Solution:
    def luckyNumbers (self, matrix: List[List[int]]) -> List[int]:
        m,n=len(matrix),len(matrix[0])
        lr=[min(i) for i in matrix]
        lc=[]
        ans=[]
        for i in range(n):
            c=[k[i] for k in matrix]
            lc.append(max(c))
        for i in lr:
            if i in lc:ans.append(i)
        return ans",True
Design a Stack With Increment Operation,"Design a stack that supports increment operations on its elements.
Implement the CustomStack class:
CustomStack(int maxSize) Initializes the object with maxSize which is the maximum number of elements in the stack.
void push(int x) Adds x to the top of the stack if the stack has not reached the maxSize.
int pop() Pops and returns the top of the stack or -1 if the stack is empty.
void inc(int k, int val) Increments the bottom k elements of the stack by val. If there are less than k elements in the stack, increment all the elements in the stack.
","Example 1:
Input
[""CustomStack"",""push"",""push"",""pop"",""push"",""push"",""push"",""increment"",""increment"",""pop"",""pop"",""pop"",""pop""]
[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]
Output
[null,null,null,2,null,null,null,null,null,103,202,201,-1]
Explanation
CustomStack stk = new CustomStack(3); // Stack is Empty []
stk.push(1);                          // stack becomes [1]
stk.push(2);                          // stack becomes [1, 2]
stk.pop();                            // return 2 --> Return top of the stack 2, stack becomes [1]
stk.push(2);                          // stack becomes [1, 2]
stk.push(3);                          // stack becomes [1, 2, 3]
stk.push(4);                          // stack still [1, 2, 3], Do not add another elements as size is 4
stk.increment(5, 100);                // stack becomes [101, 102, 103]
stk.increment(2, 100);                // stack becomes [201, 202, 103]
stk.pop();                            // return 103 --> Return top of the stack 103, stack becomes [201, 202]
stk.pop();                            // return 202 --> Return top of the stack 202, stack becomes [201]
stk.pop();                            // return 201 --> Return top of the stack 201, stack becomes []
stk.pop();                            // return -1 --> Stack is empty return -1.
",,False
Create Target Array in the Given Order,"Given two arrays of integers nums and index. Your task is to create target array under the following rules:
Initially target array is empty.
From left to right read nums[i] and index[i], insert at index index[i] the value nums[i] in target array.
Repeat the previous step until there are no elements to read in nums and index.
Return the target array.
It is guaranteed that the insertion operations will be valid.
","Example 1:
Input: nums = [0,1,2,3,4], index = [0,1,2,2,1]
Output: [0,4,1,3,2]
Explanation:
nums       index     target
0            0        [0]
1            1        [0,1]
2            2        [0,1,2]
3            2        [0,1,3,2]
4            1        [0,4,1,3,2]
Example 2:
Input: nums = [1,2,3,4,0], index = [0,1,2,3,0]
Output: [0,1,2,3,4]
Explanation:
nums       index     target
1            0        [1]
2            1        [1,2]
3            2        [1,2,3]
4            3        [1,2,3,4]
0            0        [0,1,2,3,4]
Example 3:
Input: nums = [1], index = [0]
Output: [1]
","class Solution:
    def createTargetArray(self, nums: List[int], index: List[int]) -> List[int]:
        # Initialize an empty list to store the target array
        target = []
        # Iterate through each element in the input lists
        for i in range(len(nums)):
            # Check if the index value matches the current length of the target list
            if index[i] == len(target):
                # If the index is at the end, simply append the current number to the target
                target.append(nums[i])
            else:
                # If the index is not at the end, insert the current number at the specified index
                # This is done by slicing the target list and inserting the number in the middle
                target = target[:index[i]] + [nums[i]] + target[index[i]:]
        # Return the final target array
        return target
",True
Check if There is a Valid Path in a Grid,"You are given an m x n grid. Each cell of grid represents a street. The street of grid[i][j] can be:
1 which means a street connecting the left cell and the right cell.
2 which means a street connecting the upper cell and the lower cell.
3 which means a street connecting the left cell and the lower cell.
4 which means a street connecting the right cell and the lower cell.
5 which means a street connecting the left cell and the upper cell.
6 which means a street connecting the right cell and the upper cell.

You will initially start at the street of the upper-left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1). The path should only follow the streets.
Notice that you are not allowed to change any street.
Return true if there is a valid path in the grid or false otherwise.
","Example 1:

Input: grid = [[2,4,3],[6,5,2]]
Output: true
Explanation: As shown you can start at cell (0, 0) and visit all the cells of the grid to reach (m - 1, n - 1).
Example 2:

Input: grid = [[1,2,1],[1,2,1]]
Output: false
Explanation: As shown you the street at cell (0, 0) is not connected with any street of any other cell and you will get stuck at cell (0, 0)
Example 3:
Input: grid = [[1,1,2]]
Output: false
Explanation: You will get stuck at cell (0, 1) and you cannot reach cell (0, 2).
",,False
Find Lucky Integer in an Array,"Given an array of integers arr, a lucky integer is an integer that has a frequency in the array equal to its value.
Return the largest lucky integer in the array. If there is no lucky integer return -1.
","Example 1:
Input: arr = [2,2,3,4]
Output: 2
Explanation: The only lucky number in the array is 2 because frequency[2] == 2.
Example 2:
Input: arr = [1,2,2,3,3,3]
Output: 3
Explanation: 1, 2 and 3 are all lucky numbers, return the largest of them.
Example 3:
Input: arr = [2,2,2,3,3]
Output: -1
Explanation: There are no lucky numbers in the array.
","class Solution:
    def findLucky(self, arr: List[int]) -> int:
        a=Counter(arr)
        l=[]
        for i in arr:
            if i==a[i]:
                l.append(i)
        if l:
            return max(l)
        return -1",True
Minimum Subsequence in Non-Increasing Order,"Given the array nums, obtain a subsequence of the array whose sum of elements is strictly greater than the sum of the non included elements in such subsequence. 
If there are multiple solutions, return the subsequence with minimum size and if there still exist multiple solutions, return the subsequence with the maximum total sum of all its elements. A subsequence of an array can be obtained by erasing some (possibly zero) elements from the array. 
Note that the solution with the given constraints is guaranteed to be unique. Also return the answer sorted in non-increasing order.
","Example 1:
Input: nums = [4,3,10,9,8]
Output: [10,9] 
Explanation: The subsequences [10,9] and [10,8] are minimal such that the sum of their elements is strictly greater than the sum of elements not included. However, the subsequence [10,9] has the maximum total sum of its elements. 
Example 2:
Input: nums = [4,4,7,6,7]
Output: [7,7,6] 
Explanation: The subsequence [7,7] has the sum of its elements equal to 14 which is not strictly greater than the sum of elements not included (14 = 4 + 4 + 6). Therefore, the subsequence [7,6,7] is the minimal satisfying the conditions. Note the subsequence has to be returned in non-increasing order.  
","class Solution:
    def minSubsequence(self, nums: List[int]) -> List[int]:
        nums.sort()
        l = []
        while sum(l) <= sum(nums):
            l.append(nums.pop())
        return l",True
String Matching in an Array,"Given an array of string words, return all strings in words that is a substring of another word. You can return the answer in any order.
A substring is a contiguous sequence of characters within a string
","Example 1:
Input: words = [""mass"",""as"",""hero"",""superhero""]
Output: [""as"",""hero""]
Explanation: ""as"" is substring of ""mass"" and ""hero"" is substring of ""superhero"".
[""hero"",""as""] is also a valid answer.
Example 2:
Input: words = [""leetcode"",""et"",""code""]
Output: [""et"",""code""]
Explanation: ""et"", ""code"" are substring of ""leetcode"".
Example 3:
Input: words = [""blue"",""green"",""bu""]
Output: []
Explanation: No string of words is substring of another string.
","class Solution:
    def stringMatching(self, words: List[str]) -> List[str]:
        def add(word: str):
            node = trie
            for c in word:
                node = node.setdefault(c, {})
                node['#'] = node.get('#', 0) + 1

        def get(word: str) -> bool:
            node = trie
            for c in word:
                if (node := node.get(c)) is None: return False
            return node['#'] > 1

        trie = {}
        for word in words:
            for i in range(len(word)):
                add(word[i:])
        return [word for word in words if get(word)]",True
Queries on a Permutation With Key,"Given the array queries of positive integers between 1 and m, you have to process all queries[i] (from i=0 to i=queries.length-1) according to the following rules:
In the beginning, you have the permutation P=[1,2,3,...,m].
For the current i, find the position of queries[i] in the permutation P (indexing from 0) and then move this at the beginning of the permutation P. Notice that the position of queries[i] in P is the result for queries[i].
Return an array containing the result for the given queries.
","Example 1:
Input: queries = [3,1,2,1], m = 5
Output: [2,1,2,1] 
Explanation: The queries are processed as follow: 
For i=0: queries[i]=3, P=[1,2,3,4,5], position of 3 in P is 2, then we move 3 to the beginning of P resulting in P=[3,1,2,4,5]. 
For i=1: queries[i]=1, P=[3,1,2,4,5], position of 1 in P is 1, then we move 1 to the beginning of P resulting in P=[1,3,2,4,5]. 
For i=2: queries[i]=2, P=[1,3,2,4,5], position of 2 in P is 2, then we move 2 to the beginning of P resulting in P=[2,1,3,4,5]. 
For i=3: queries[i]=1, P=[2,1,3,4,5], position of 1 in P is 1, then we move 1 to the beginning of P resulting in P=[1,2,3,4,5]. 
Therefore, the array containing the result is [2,1,2,1].  
Example 2:
Input: queries = [4,1,2,2], m = 4
Output: [3,1,2,0]
Example 3:
Input: queries = [7,5,5,8,3], m = 8
Output: [6,5,0,7,5]
","class Solution:
    def processQueries(self, queries: List[int], m: int) -> List[int]:
        arr = [i for i in range(1, m + 1)]
        output = []
        for query in queries:
            index = arr.index(query)
            output.append(index)
            arr.insert(0, arr.pop(index))
        return output",True
Kids With the Greatest Number of Candies,"There are n kids with candies. You are given an integer array candies, where each candies[i] represents the number of candies the ith kid has, and an integer extraCandies, denoting the number of extra candies that you have.
Return a boolean array result of length n, where result[i] is true if, after giving the ith kid all the extraCandies, they will have the greatest number of candies among all the kids, or false otherwise.
Note that multiple kids can have the greatest number of candies.
","Example 1:
Input: candies = [2,3,5,1,3], extraCandies = 3
Output: [true,true,true,false,true] 
Explanation: If you give all extraCandies to:
- Kid 1, they will have 2 + 3 = 5 candies, which is the greatest among the kids.
- Kid 2, they will have 3 + 3 = 6 candies, which is the greatest among the kids.
- Kid 3, they will have 5 + 3 = 8 candies, which is the greatest among the kids.
- Kid 4, they will have 1 + 3 = 4 candies, which is not the greatest among the kids.
- Kid 5, they will have 3 + 3 = 6 candies, which is the greatest among the kids.
Example 2:
Input: candies = [4,2,1,1,2], extraCandies = 1
Output: [true,false,false,false,false] 
Explanation: There is only 1 extra candy.
Kid 1 will always have the greatest number of candies, even if a different kid is given the extra candy.
Example 3:
Input: candies = [12,1,12], extraCandies = 10
Output: [true,false,true]
",,False
Diagonal Traverse II,"Given a 2D integer array nums, return all elements of nums in diagonal order as shown in the below images.
","Example 1:

Input: nums = [[1,2,3],[4,5,6],[7,8,9]]
Output: [1,4,2,7,5,3,8,6,9]
Example 2:

Input: nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]
Output: [1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]
","class Solution:
    def findDiagonalOrder(self, nums: List[List[int]]) -> List[int]:
        ans=[]
        for i,r in enumerate(nums):
            for j ,val in enumerate(r):
                if len(ans)<=i+j:
                    ans.append([])
                ans[i+j].append(val)
        seen=[]
        for r in ans:
            seen+=reversed(r)
        return seen                    ",True
Destination City,"You are given the array paths, where paths[i] = [cityAi, cityBi] means there exists a direct path going from cityAi to cityBi. Return the destination city, that is, the city without any path outgoing to another city.
It is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city.
","Example 1:
Input: paths = [[""London"",""New York""],[""New York"",""Lima""],[""Lima"",""Sao Paulo""]]
Output: ""Sao Paulo"" 
Explanation: Starting at ""London"" city you will reach ""Sao Paulo"" city which is the destination city. Your trip consist of: ""London"" -> ""New York"" -> ""Lima"" -> ""Sao Paulo"".
Example 2:
Input: paths = [[""B"",""C""],[""D"",""B""],[""C"",""A""]]
Output: ""A""
Explanation: All possible trips are: 
""D"" -> ""B"" -> ""C"" -> ""A"". 
""B"" -> ""C"" -> ""A"". 
""C"" -> ""A"". 
""A"". 
Clearly the destination city is ""A"".
Example 3:
Input: paths = [[""A"",""Z""]]
Output: ""Z""
","class Solution:
    def destCity(self, paths: List[List[str]]) -> str:
        start_cities, end_cities = map(set, zip(*paths))
        destination = (end_cities - start_cities).pop()
        return destination",True
Check If All 1's Are at Least Length K Places Away,"Given an binary array nums and an integer k, return true if all 1's are at least k places away from each other, otherwise return false.
","Example 1:

Input: nums = [1,0,0,0,1,0,0,1], k = 2
Output: true
Explanation: Each of the 1s are at least 2 places away from each other.
Example 2:

Input: nums = [1,0,0,1,0,1], k = 2
Output: false
Explanation: The second 1 and third 1 are only one apart from each other.
","class Solution:
    def kLengthApart(self, nums: List[int], k: int) -> bool:
        if sum(nums) in (0, 1):
            return True
        indexes = []
        for i, n in enumerate(nums):
            if n == 1:
                indexes.append(i)
        return min(b - a - 1 for a, b in pairwise(indexes)) >= k
```",True
Build an Array With Stack Operations,"You are given an integer array target and an integer n.
You have an empty stack with the two following operations:
""Push"": pushes an integer to the top of the stack.
""Pop"": removes the integer on the top of the stack.
You also have a stream of the integers in the range [1, n].
Use the two stack operations to make the numbers in the stack (from the bottom to the top) equal to target. You should follow the following rules:
If the stream of the integers is not empty, pick the next integer from the stream and push it to the top of the stack.
If the stack is not empty, pop the integer at the top of the stack.
If, at any moment, the elements in the stack (from the bottom to the top) are equal to target, do not read new integers from the stream and do not do more operations on the stack.
Return the stack operations needed to build target following the mentioned rules. If there are multiple valid answers, return any of them.
","Example 1:
Input: target = [1,3], n = 3
Output: [""Push"",""Push"",""Pop"",""Push""]
Explanation: Initially the stack s is empty. The last element is the top of the stack.
Read 1 from the stream and push it to the stack. s = [1].
Read 2 from the stream and push it to the stack. s = [1,2].
Pop the integer on the top of the stack. s = [1].
Read 3 from the stream and push it to the stack. s = [1,3].
Example 2:
Input: target = [1,2,3], n = 3
Output: [""Push"",""Push"",""Push""]
Explanation: Initially the stack s is empty. The last element is the top of the stack.
Read 1 from the stream and push it to the stack. s = [1].
Read 2 from the stream and push it to the stack. s = [1,2].
Read 3 from the stream and push it to the stack. s = [1,2,3].
Example 3:
Input: target = [1,2], n = 4
Output: [""Push"",""Push""]
Explanation: Initially the stack s is empty. The last element is the top of the stack.
Read 1 from the stream and push it to the stack. s = [1].
Read 2 from the stream and push it to the stack. s = [1,2].
Since the stack (from the bottom to the top) is equal to target, we stop the stack operations.
The answers that read integer 3 from the stream are not accepted.
","class Solution:
    def buildArray(self, target: List[int], n: int) -> List[str]:
        l=[]
        for i in range(1,target[-1]+1):
            l.append(""Push"")
            if i not in target:
                l.append(""Pop"")
        return l",True
Make Two Arrays Equal by Reversing Subarrays,"You are given two integer arrays of equal length target and arr. In one step, you can select any non-empty subarray of arr and reverse it. You are allowed to make any number of steps.
Return true if you can make arr equal to target or false otherwise.
","Example 1:
Input: target = [1,2,3,4], arr = [2,4,1,3]
Output: true
Explanation: You can follow the next steps to convert arr to target:
1- Reverse subarray [2,4,1], arr becomes [1,4,2,3]
2- Reverse subarray [4,2], arr becomes [1,2,4,3]
3- Reverse subarray [4,3], arr becomes [1,2,3,4]
There are multiple ways to convert arr to target, this is not the only way to do so.
Example 2:
Input: target = [7], arr = [7]
Output: true
Explanation: arr is equal to target without any reverses.
Example 3:
Input: target = [3,7,9], arr = [3,7,11]
Output: false
Explanation: arr does not have value 9 and it can never be converted to target.
","class Solution:
    def canBeEqual(self, target: List[int], arr: List[int]) -> bool:
        cache = defaultdict(int)

        for i in range(len(target)):
            cache[target[i]] += 1
            cache[arr[i]] -= 1

        for v in cache.values():
            if v: 
                return False

        return True
",True
Number of Students Doing Homework at a Given Time,"Given two integer arrays startTime and endTime and given an integer queryTime.
The ith student started doing their homework at the time startTime[i] and finished it at time endTime[i].
Return the number of students doing their homework at time queryTime. More formally, return the number of students where queryTime lays in the interval [startTime[i], endTime[i]] inclusive.
","Example 1:
Input: startTime = [1,2,3], endTime = [3,2,7], queryTime = 4
Output: 1
Explanation: We have 3 students where:
The first student started doing homework at time 1 and finished at time 3 and wasn't doing anything at time 4.
The second student started doing homework at time 2 and finished at time 2 and also wasn't doing anything at time 4.
The third student started doing homework at time 3 and finished at time 7 and was the only student doing homework at time 4.
Example 2:
Input: startTime = [4], endTime = [4], queryTime = 4
Output: 1
Explanation: The only student was doing their homework at the queryTime.
","class Solution:
    def busyStudent(self, startTime: List[int], endTime: List[int], queryTime: int) -> int:
        
        j=0
        count=0

        for i in startTime:
            if queryTime >= i and endTime[j] >= queryTime:
                count=count+1
            j=j+1
        return count


        ",True
Subrectangle Queries,"Implement the class SubrectangleQueries which receives a rows x cols rectangle as a matrix of integers in the constructor and supports two methods:
1. updateSubrectangle(int row1, int col1, int row2, int col2, int newValue)
Updates all values with newValue in the subrectangle whose upper left coordinate is (row1,col1) and bottom right coordinate is (row2,col2).
2. getValue(int row, int col)
Returns the current value of the coordinate (row,col) from the rectangle.
","Example 1:
Input
[""SubrectangleQueries"",""getValue"",""updateSubrectangle"",""getValue"",""getValue"",""updateSubrectangle"",""getValue"",""getValue""]
[[[[1,2,1],[4,3,4],[3,2,1],[1,1,1]]],[0,2],[0,0,3,2,5],[0,2],[3,1],[3,0,3,2,10],[3,1],[0,2]]
Output
[null,1,null,5,5,null,10,5]
Explanation
SubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,2,1],[4,3,4],[3,2,1],[1,1,1]]);  
// The initial rectangle (4x3) looks like:
// 1 2 1
// 4 3 4
// 3 2 1
// 1 1 1
subrectangleQueries.getValue(0, 2); // return 1
subrectangleQueries.updateSubrectangle(0, 0, 3, 2, 5);
// After this update the rectangle looks like:
// 5 5 5
// 5 5 5
// 5 5 5
// 5 5 5 
subrectangleQueries.getValue(0, 2); // return 5
subrectangleQueries.getValue(3, 1); // return 5
subrectangleQueries.updateSubrectangle(3, 0, 3, 2, 10);
// After this update the rectangle looks like:
// 5   5   5
// 5   5   5
// 5   5   5
// 10  10  10 
subrectangleQueries.getValue(3, 1); // return 10
subrectangleQueries.getValue(0, 2); // return 5
Example 2:
Input
[""SubrectangleQueries"",""getValue"",""updateSubrectangle"",""getValue"",""getValue"",""updateSubrectangle"",""getValue""]
[[[[1,1,1],[2,2,2],[3,3,3]]],[0,0],[0,0,2,2,100],[0,0],[2,2],[1,1,2,2,20],[2,2]]
Output
[null,1,null,100,100,null,20]
Explanation
SubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,1,1],[2,2,2],[3,3,3]]);
subrectangleQueries.getValue(0, 0); // return 1
subrectangleQueries.updateSubrectangle(0, 0, 2, 2, 100);
subrectangleQueries.getValue(0, 0); // return 100
subrectangleQueries.getValue(2, 2); // return 100
subrectangleQueries.updateSubrectangle(1, 1, 2, 2, 20);
subrectangleQueries.getValue(2, 2); // return 20
",,False
Maximum Product of Two Elements in an Array,"nums
i
j
Return the maximum value of
(nums[i]-1)*(nums[j]-1)
","Example 1:
Input: nums = [3,4,5,2]
Output: 12 
Explanation: If you choose the indices i=1 and j=2 (indexed from 0), you will get the maximum value, that is, (nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12. 
Example 2:
Input: nums = [1,5,4,5]
Output: 16
Explanation: Choosing the indices i=1 and j=3 (indexed from 0), you will get the maximum value of (5-1)*(5-1) = 16.
Example 3:
Input: nums = [3,7]
Output: 12
","class Solution:
    def maxProduct(self, l: List[int]) -> int:
        x,y=-1,-1
        for i in l :
            if i>=x :
                y=x
                x=i
            elif x>=i>=y :
                y=i 
        return (y-1)*(x-1)        ",True
Shuffle the Array,"Given the array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn].
Return the array in the form [x1,y1,x2,y2,...,xn,yn].
","Example 1:
Input: nums = [2,5,1,3,4,7], n = 3
Output: [2,3,5,4,1,7] 
Explanation: Since x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 then the answer is [2,3,5,4,1,7].
Example 2:
Input: nums = [1,2,3,4,4,3,2,1], n = 4
Output: [1,4,2,3,3,2,4,1]
Example 3:
Input: nums = [1,1,2,2], n = 2
Output: [1,2,1,2]
","class Solution:
    def shuffle(self, nums: List[int], n: int) -> List[int]:
        answer = []
        for i in range(0, n):
            answer.append(nums[i])
            answer.append(nums[i + n])
        return answer",True
Design Browser History,"You have a browser of one tab where you start on the homepage and you can visit another url, get back in the history number of steps or move forward in the history number of steps.
Implement the BrowserHistory class:
BrowserHistory(string homepage) Initializes the object with the homepage of the browser.
void visit(string url) Visits url from the current page. It clears up all the forward history.
string back(int steps) Move steps back in history. If you can only return x steps in the history and steps > x, you will return only x steps. Return the current url after moving back in history at most steps.
string forward(int steps) Move steps forward in history. If you can only forward x steps in the history and steps > x, you will forward only x steps. Return the current url after forwarding in history at most steps.
","Example:
Input:
[""BrowserHistory"",""visit"",""visit"",""visit"",""back"",""back"",""forward"",""visit"",""forward"",""back"",""back""]
[[""leetcode.com""],[""google.com""],[""facebook.com""],[""youtube.com""],[1],[1],[1],[""linkedin.com""],[2],[2],[7]]
Output:
[null,null,null,null,""facebook.com"",""google.com"",""facebook.com"",null,""linkedin.com"",""google.com"",""leetcode.com""]

Explanation:
BrowserHistory browserHistory = new BrowserHistory(""leetcode.com"");
browserHistory.visit(""google.com"");       // You are in ""leetcode.com"". Visit ""google.com""
browserHistory.visit(""facebook.com"");     // You are in ""google.com"". Visit ""facebook.com""
browserHistory.visit(""youtube.com"");      // You are in ""facebook.com"". Visit ""youtube.com""
browserHistory.back(1);                   // You are in ""youtube.com"", move back to ""facebook.com"" return ""facebook.com""
browserHistory.back(1);                   // You are in ""facebook.com"", move back to ""google.com"" return ""google.com""
browserHistory.forward(1);                // You are in ""google.com"", move forward to ""facebook.com"" return ""facebook.com""
browserHistory.visit(""linkedin.com"");     // You are in ""facebook.com"". Visit ""linkedin.com""
browserHistory.forward(2);                // You are in ""linkedin.com"", you cannot move forward any steps.
browserHistory.back(2);                   // You are in ""linkedin.com"", move back two steps to ""facebook.com"" then to ""google.com"". return ""google.com""
browserHistory.back(7);                   // You are in ""google.com"", you can move back only one step to ""leetcode.com"". return ""leetcode.com""
",,False
Average Salary Excluding the Minimum and Maximum Salary,"You are given an array of unique integers salary where salary[i] is the salary of the ith employee.
Return the average salary of employees excluding the minimum and maximum salary. Answers within 10-5 of the actual answer will be accepted.
","Example 1:
Input: salary = [4000,3000,1000,2000]
Output: 2500.00000
Explanation: Minimum salary and maximum salary are 1000 and 4000 respectively.
Average salary excluding minimum and maximum salary is (2000+3000) / 2 = 2500
Example 2:
Input: salary = [1000,2000,3000]
Output: 2000.00000
Explanation: Minimum salary and maximum salary are 1000 and 3000 respectively.
Average salary excluding minimum and maximum salary is (2000) / 1 = 2000
","class Solution:
    def average(self, salary: List[int]) -> float:
        salary.remove(max(salary))
        salary.remove(min(salary))
        return sum(salary)/len(salary)
#please upvote me it would encourage me alot",True
Longest Subarray of 1's After Deleting One Element,"Given a binary array nums, you should delete one element from it.
Return the size of the longest non-empty subarray containing only 1's in the resulting array. Return 0 if there is no such subarray.
","Example 1:
Input: nums = [1,1,0,1]
Output: 3
Explanation: After deleting the number in position 2, [1,1,1] contains 3 numbers with value of 1's.
Example 2:
Input: nums = [0,1,1,1,0,1,1,0,1]
Output: 5
Explanation: After deleting the number in position 4, [0,1,1,1,1,1,0,1] longest subarray with value of 1's is [1,1,1,1,1].
Example 3:
Input: nums = [1,1,1]
Output: 2
Explanation: You must delete one element.
","class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        if nums.count(1)==len(nums):
            return len(nums)-1
        res=[]
        cnt=0
        for i in nums:
            if i==1:
                cnt+=1
            else:
                res.append(cnt)
                cnt=0
        res.append(cnt)
        maxi=res[0]
        for i in range(1,len(res)):
            if res[i]+res[i-1]>maxi:
                maxi=res[i]+res[i-1]
        return maxi",True
Running Sum of 1d Array,"Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]…nums[i]).
Return the running sum of nums.
","Example 1:
Input: nums = [1,2,3,4]
Output: [1,3,6,10]
Explanation: Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4].
Example 2:
Input: nums = [1,1,1,1,1]
Output: [1,2,3,4,5]
Explanation: Running sum is obtained as follows: [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1].
Example 3:
Input: nums = [3,1,2,10,1]
Output: [3,4,6,16,17]
",,False
Least Number of Unique Integers after K Removals,"Given an array of integers arr and an integer k. Find the least number of unique integers after removing exactly k elements.

","Example 1:
Input: arr = [5,5,4], k = 1
Output: 1
Explanation: Remove the single 4, only 5 is left.
Example 2:
Input: arr = [4,3,1,1,3,3,2], k = 3
Output: 2
Explanation: Remove 4, 2 and either one of the two 1s or three 3s. 1 and 3 will be left.
","class Solution:
    def findLeastNumOfUniqueInts(self, arr: List[int], k: int) -> int:
        hm = Counter(arr)
        hm_sorted_values = sorted(hm.values()) 
        hm_values_queue = deque(hm_sorted_values)

        while hm_values_queue and k >= hm_values_queue[0]:
            k -= hm_values_queue[0]
            hm_values_queue.popleft()

        return len(hm_values_queue)",True
Minimum Difference Between Largest and Smallest Value in Three Moves,"You are given an integer array nums.
In one move, you can choose one element of nums and change it to any value.
Return the minimum difference between the largest and smallest value of nums after performing at most three moves.
","Example 1:
Input: nums = [5,3,2,4]
Output: 0
Explanation: We can make at most 3 moves.
In the first move, change 2 to 3. nums becomes [5,3,3,4].
In the second move, change 4 to 3. nums becomes [5,3,3,3].
In the third move, change 5 to 3. nums becomes [3,3,3,3].
After performing 3 moves, the difference between the minimum and maximum is 3 - 3 = 0.
Example 2:
Input: nums = [1,5,0,10,14]
Output: 1
Explanation: We can make at most 3 moves.
In the first move, change 5 to 0. nums becomes [1,0,0,10,14].
In the second move, change 10 to 0. nums becomes [1,0,0,0,14].
In the third move, change 14 to 1. nums becomes [1,0,0,0,1].
After performing 3 moves, the difference between the minimum and maximum is 1 - 0 = 1.
It can be shown that there is no way to make the difference 0 in 3 moves.
Example 3:
Input: nums = [3,100,20]
Output: 0
Explanation: We can make at most 3 moves.
In the first move, change 100 to 7. nums becomes [3,7,20].
In the second move, change 20 to 7. nums becomes [3,7,7].
In the third move, change 3 to 7. nums becomes [7,7,7].
After performing 3 moves, the difference between the minimum and maximum is 7 - 7 = 0.
","class Solution:
    def minDifference(self, nums: List[int]) -> int:
        if len(nums) <= 4:
            return 0
        nums.sort()
        min_diff = nums[-1] - nums[3]
        for i in range(1, 4):
            min_diff = min(min_diff, nums[-1 - i] - nums[3 - i])
        return min_diff",True
Number of Subsequences That Satisfy the Given Sum Condition,"You are given an array of integers nums and an integer target.
Return the number of non-empty subsequences of nums such that the sum of the minimum and maximum element on it is less or equal to target. Since the answer may be too large, return it modulo 109 + 7.
","Example 1:
Input: nums = [3,5,6,7], target = 9
Output: 4
Explanation: There are 4 subsequences that satisfy the condition.
[3] -> Min value + max value <= target (3 + 3 <= 9)
[3,5] -> (3 + 5 <= 9)
[3,5,6] -> (3 + 6 <= 9)
[3,6] -> (3 + 6 <= 9)
Example 2:
Input: nums = [3,3,6,8], target = 10
Output: 6
Explanation: There are 6 subsequences that satisfy the condition. (nums can have repeated numbers).
[3] , [3] , [3,3], [3,6] , [3,6] , [3,3,6]
Example 3:
Input: nums = [2,3,3,4,6,7], target = 12
Output: 61
Explanation: There are 63 non-empty subsequences, two of them do not satisfy the condition ([6,7], [7]).
Number of valid subsequences (63 - 2 = 61).
","class Solution:
    def numSubseq(self, nums: List[int], target: int) -> int:
        mod = 10**9 +7
        result = 0
        nums.sort()
        left,right = 0, len(nums) - 1
        while left <= right:
            if nums[left] + nums[right] <= target:
                result = (result+ pow(2, right-left,mod))% mod
                left += 1
            else:
                right -= 1
        return result",True
Can Make Arithmetic Progression From Sequence,"A sequence of numbers is called an arithmetic progression if the difference between any two consecutive elements is the same.
Given an array of numbers arr, return true if the array can be rearranged to form an arithmetic progression. Otherwise, return false.
","Example 1:
Input: arr = [3,5,1]
Output: true
Explanation: We can reorder the elements as [1,3,5] or [5,3,1] with differences 2 and -2 respectively, between each consecutive elements.
Example 2:
Input: arr = [1,2,4]
Output: false
Explanation: There is no way to reorder the elements to obtain an arithmetic progression.
","class Solution:
    def canMakeArithmeticProgression(self, arr: List[int]) -> bool:
        first,last,n,arrValues = arr[0],arr[0],0,set()
        for i in arr:
            first,last,n = min(first,i),max(last,i),n+1
            arrValues.add(i)
        if (last-first)%(n-1)!=0:
            return False
        d = (last-first)//(n-1)
        if n<=2 or d==0:
            return True
        for i in range(first,last+1,d):
            if i not in arrValues:
                return False
        return True
",True
Last Moment Before All Ants Fall Out of a Plank,"We have a wooden plank of the length n units. Some ants are walking on the plank, each ant moves with a speed of 1 unit per second. Some of the ants move to the left, the other move to the right.
When two ants moving in two different directions meet at some point, they change their directions and continue moving again. Assume changing directions does not take any additional time.
When an ant reaches one end of the plank at a time t, it falls out of the plank immediately.
Given an integer n and two integer arrays left and right, the positions of the ants moving to the left and the right, return the moment when the last ant(s) fall out of the plank.
","Example 1:

Input: n = 4, left = [4,3], right = [0,1]
Output: 4
Explanation: In the image above:
-The ant at index 0 is named A and going to the right.
-The ant at index 1 is named B and going to the right.
-The ant at index 3 is named C and going to the left.
-The ant at index 4 is named D and going to the left.
The last moment when an ant was on the plank is t = 4 seconds. After that, it falls immediately out of the plank. (i.e., We can say that at t = 4.0000000001, there are no ants on the plank).
Example 2:

Input: n = 7, left = [], right = [0,1,2,3,4,5,6,7]
Output: 7
Explanation: All ants are going to the right, the ant at index 0 needs 7 seconds to fall.
Example 3:

Input: n = 7, left = [0,1,2,3,4,5,6,7], right = []
Output: 7
Explanation: All ants are going to the left, the ant at index 7 needs 7 seconds to fall.
","class Solution:
    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:
        farthest_left = max(left) if len(left) != 0 else 0
        farthest_right = n - min(right) if len(right) != 0 else 0
        return max(farthest_left, farthest_right)",True
Number of Good Pairs,"Given an array of integers nums, return the number of good pairs.
A pair (i, j) is called good if nums[i] == nums[j] and i < j.
","Example 1:
Input: nums = [1,2,3,1,1,3]
Output: 4
Explanation: There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed.
Example 2:
Input: nums = [1,1,1,1]
Output: 6
Explanation: Each pair in the array are good.
Example 3:
Input: nums = [1,2,3]
Output: 0
","class Solution:
    def numIdenticalPairs(self, nums: List[int]) -> int:
        hashmap = {}
        counter = 0
        for num in nums:
            if num not in hashmap:
            // If not in hashmap, then create a new key and set the value to 1
                hashmap[num] = 1
            else:
            // If already exists, then update the counter as well as the value of corresponding key in the hashmap
                counter += hashmap[num]
                hashmap[num] += 1
        return counter",True
Kth Missing Positive Number,"Given an array arr of positive integers sorted in a strictly increasing order, and an integer k.
Return the kth positive integer that is missing from this array.
","Example 1:
Input: arr = [2,3,4,7,11], k = 5
Output: 9
Explanation: The missing positive integers are [1,5,6,8,9,10,12,13,...]. The 5th missing positive integer is 9.
Example 2:
Input: arr = [1,2,3,4], k = 2
Output: 6
Explanation: The missing positive integers are [5,6,7,...]. The 2nd missing positive integer is 6.
","class Solution:
    def findKthPositive(self, arr: List[int], k: int) -> int:
        count = 0
        i = 0
        while count != k:
            i += 1
            if i not in arr:
                count += 1
                if count  == k:
                    return i
",True
Shuffle String,"You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.
Return the shuffled string.
","Example 1:

Input: s = ""codeleet"", indices = [4,5,6,7,0,2,1,3]
Output: ""leetcode""
Explanation: As shown, ""codeleet"" becomes ""leetcode"" after shuffling.
Example 2:
Input: s = ""abc"", indices = [0,1,2]
Output: ""abc""
Explanation: After shuffling, each character remains in its position.
","class Solution:
    def restoreString(self, s: str, indices: List[int]) -> str:
        outcome=""""
        for i in range(len(s)):
            outcome=outcome+s[indices.index(i)]
        return outcome

        ",True
Count Good Triplets,"Given an array of integers arr, and three integers a, b and c. You need to find the number of good triplets.
A triplet (arr[i], arr[j], arr[k]) is good if the following conditions are true:
0 <= i < j < k < arr.length
|arr[i] - arr[j]| <= a
|arr[j] - arr[k]| <= b
|arr[i] - arr[k]| <= c
Where |x| denotes the absolute value of x.
Return the number of good triplets.
","Example 1:
Input: arr = [3,0,1,1,9,7], a = 7, b = 2, c = 3
Output: 4
Explanation: There are 4 good triplets: [(3,0,1), (3,0,1), (3,1,1), (0,1,1)].
Example 2:
Input: arr = [1,1,2,2,3], a = 0, b = 0, c = 1
Output: 0
Explanation: No triplet satisfies all conditions.
",,False
Find the Winner of an Array Game,"Given an integer array arr of distinct integers and an integer k.
A game will be played between the first two elements of the array (i.e. arr[0] and arr[1]). In each round of the game, we compare arr[0] with arr[1], the larger integer wins and remains at position 0, and the smaller integer moves to the end of the array. The game ends when an integer wins k consecutive rounds.
Return the integer which will win the game.
It is guaranteed that there will be a winner of the game.
","Example 1:
Input: arr = [2,1,3,5,4,6,7], k = 2
Output: 5
Explanation: Let's see the rounds of the game:
Round |       arr       | winner | win_count
  1   | [2,1,3,5,4,6,7] | 2      | 1
  2   | [2,3,5,4,6,7,1] | 3      | 1
  3   | [3,5,4,6,7,1,2] | 5      | 1
  4   | [5,4,6,7,1,2,3] | 5      | 2
So we can see that 4 rounds will be played and 5 is the winner because it wins 2 consecutive games.
Example 2:
Input: arr = [3,2,1], k = 10
Output: 3
Explanation: 3 will win the first 10 rounds consecutively.
","class Solution:
    def getWinner(self, arr: List[int], k: int) -> int:
        if k == 1:
            return max(arr[0], arr[1])
        if k >= len(arr):
            return max(arr)
        
        current_winner = arr[0]
        consecutive_wins = 0
        
        for i in range(1, len(arr)):
            if current_winner > arr[i]:
                consecutive_wins += 1
            else:
                current_winner = arr[i]
                consecutive_wins = 1
            
            if consecutive_wins == k:
                return current_winner
        
        return current_winner",True
Matrix Diagonal Sum,"Given a square matrix mat, return the sum of the matrix diagonals.
Only include the sum of all the elements on the primary diagonal and all the elements on the secondary diagonal that are not part of the primary diagonal.
","Example 1:

Input: mat = [[1,2,3],
              [4,5,6],
              [7,8,9]]
Output: 25
Explanation: Diagonals sum: 1 + 5 + 9 + 3 + 7 = 25
Notice that element mat[1][1] = 5 is counted only once.
Example 2:
Input: mat = [[1,1,1,1],
              [1,1,1,1],
              [1,1,1,1],
              [1,1,1,1]]
Output: 8
Example 3:
Input: mat = [[5]]
Output: 5
","class Solution:
    def diagonalSum(self, mat: List[List[int]]) -> int:
        n = len(mat)
        suma = 0
        for i in range(n):
            suma += mat[i][i] + mat[i][-i-1]
        return suma if n % 2 == 0 else suma - mat[n//2][n//2]",True
Maximum Number of Coins You Can Get,"There are 3n piles of coins of varying size, you and your friends will take piles of coins as follows:
In each step, you will choose any 3 piles of coins (not necessarily consecutive).
Of your choice, Alice will pick the pile with the maximum number of coins.
You will pick the next pile with the maximum number of coins.
Your friend Bob will pick the last pile.
Repeat until there are no more piles of coins.
Given an array of integers piles where piles[i] is the number of coins in the ith pile.
Return the maximum number of coins that you can have.
","Example 1:
Input: piles = [2,4,1,2,7,8]
Output: 9
Explanation: Choose the triplet (2, 7, 8), Alice Pick the pile with 8 coins, you the pile with 7 coins and Bob the last one.
Choose the triplet (1, 2, 4), Alice Pick the pile with 4 coins, you the pile with 2 coins and Bob the last one.
The maximum number of coins which you can have are: 7 + 2 = 9.
On the other hand if we choose this arrangement (1, 2, 8), (2, 4, 7) you only get 2 + 4 = 6 coins which is not optimal.
Example 2:
Input: piles = [2,4,5]
Output: 4
Example 3:
Input: piles = [9,8,7,6,5,1,2,3,4]
Output: 18
","class Solution:
    def maxCoins(self, piles: List[int]) -> int:
        piles.sort()
        you = 0
        for i in range(len(piles)//3):
            piles.pop()
            you += piles.pop()        
            piles.pop(0)
        return you",True
Number of Ways Where Square of Number Is Equal to Product of Two Numbers,"Given two arrays of integers nums1 and nums2, return the number of triplets formed (type 1 and type 2) under the following rules:
Type 1: Triplet (i, j, k) if nums1[i]2 == nums2[j] * nums2[k] where 0 <= i < nums1.length and 0 <= j < k < nums2.length.
Type 2: Triplet (i, j, k) if nums2[i]2 == nums1[j] * nums1[k] where 0 <= i < nums2.length and 0 <= j < k < nums1.length.
","Example 1:
Input: nums1 = [7,4], nums2 = [5,2,8,9]
Output: 1
Explanation: Type 1: (1, 1, 2), nums1[1]2 = nums2[1] * nums2[2]. (42 = 2 * 8). 
Example 2:
Input: nums1 = [1,1], nums2 = [1,1,1]
Output: 9
Explanation: All Triplets are valid, because 12 = 1 * 1.
Type 1: (0,0,1), (0,0,2), (0,1,2), (1,0,1), (1,0,2), (1,1,2).  nums1[i]2 = nums2[j] * nums2[k].
Type 2: (0,0,1), (1,0,1), (2,0,1). nums2[i]2 = nums1[j] * nums1[k].
Example 3:
Input: nums1 = [7,7,8,3], nums2 = [1,2,9,7]
Output: 2
Explanation: There are 2 valid triplets.
Type 1: (3,0,2).  nums1[3]2 = nums2[0] * nums2[2].
Type 2: (3,0,1).  nums2[3]2 = nums1[0] * nums1[1].
","class Solution:
    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:
        Count1 = Counter(nums1)
        Count2 = Counter(nums2)
        res = 0
        for i in Count1:
            db = Count2.copy()
            while db:
                item = db.popitem()
                Q, r = divmod(i*i, item[0])
                if r == 0 and Q in db:
                    res += db[Q]*item[1]*Count1[i]
                    db.pop(Q)
                elif r == 0 and Q == item[0]:
                    res += comb(item[1],2)*Count1[i]
                    
        for i in Count2:
            db = Count1.copy()
            while db:
                item = db.popitem()
                Q, r = divmod(i*i, item[0])
                if r == 0 and Q in db:
                    res += db[Q]*item[1]*Count2[i]
                    db.pop(Q)
                elif r == 0 and Q == item[0]:
                    res += comb(item[1],2)*Count2[i]

        return res
                    
",True
Minimum Time to Make Rope Colorful,"Alice has n balloons arranged on a rope. You are given a 0-indexed string colors where colors[i] is the color of the ith balloon.
Alice wants the rope to be colorful. She does not want two consecutive balloons to be of the same color, so she asks Bob for help. Bob can remove some balloons from the rope to make it colorful. You are given a 0-indexed integer array neededTime where neededTime[i] is the time (in seconds) that Bob needs to remove the ith balloon from the rope.
Return the minimum time Bob needs to make the rope colorful.
","Example 1:

Input: colors = ""abaac"", neededTime = [1,2,3,4,5]
Output: 3
Explanation: In the above image, 'a' is blue, 'b' is red, and 'c' is green.
Bob can remove the blue balloon at index 2. This takes 3 seconds.
There are no longer two consecutive balloons of the same color. Total time = 3.
Example 2:

Input: colors = ""abc"", neededTime = [1,2,3]
Output: 0
Explanation: The rope is already colorful. Bob does not need to remove any balloons from the rope.
Example 3:

Input: colors = ""aabaa"", neededTime = [1,2,3,4,1]
Output: 2
Explanation: Bob will remove the balloons at indices 0 and 4. Each balloons takes 1 second to remove.
There are no longer two consecutive balloons of the same color. Total time = 1 + 1 = 2.
","class Solution:
    def minCost(self, colors: str, neededTime: List[int]) -> int:
        prev=colors[0]
        curr_max = neededTime[0]
        cost = 0
        for i in range(1,len(colors)):
            curr = colors[i]
            if curr == prev :
                if neededTime[i] > curr_max :
                    cost += curr_max
                    curr_max = neededTime[i]
                else :
                    cost += neededTime[i]
            if curr != prev :
                curr_max = neededTime[i]
                prev = colors[i]
        return cost

",True
Special Positions in a Binary Matrix,"Given an m x n binary matrix mat, return the number of special positions in mat.
A position (i, j) is called special if mat[i][j] == 1 and all other elements in row i and column j are 0 (rows and columns are 0-indexed).
","Example 1:

Input: mat = [[1,0,0],[0,0,1],[1,0,0]]
Output: 1
Explanation: (1, 2) is a special position because mat[1][2] == 1 and all other elements in row 1 and column 2 are 0.
Example 2:

Input: mat = [[1,0,0],[0,1,0],[0,0,1]]
Output: 3
Explanation: (0, 0), (1, 1) and (2, 2) are special positions.
","class Solution:
    def numSpecial(self, mat: List[List[int]]) -> int:
        row=[0]*len(mat)
        col=[0]*len(mat[0])
        for i in range(len(mat)):
            for j in range(len(mat[0])):
                if(mat[i][j]==1):
                    row[i]+=1
                    col[j]+=1
        ans = 0 
        for i in range(len(mat)):
            for j in range(len(mat[0])):
                if(mat[i][j]==1 and row[i]==1 and col[j]==1 ):
                    ans+=1
        return ans",True
Min Cost to Connect All Points,"You are given an array points representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi].
The cost of connecting two points [xi, yi] and [xj, yj] is the manhattan distance between them: |xi - xj| + |yi - yj|, where |val| denotes the absolute value of val.
Return the minimum cost to make all points connected. All points are connected if there is exactly one simple path between any two points.
","Example 1:

Input: points = [[0,0],[2,2],[3,10],[5,2],[7,0]]
Output: 20
Explanation: 
We can connect the points as shown above to get the minimum cost of 20.
Notice that there is a unique path between every pair of points.
Example 2:
Input: points = [[3,12],[-2,5],[-4,1]]
Output: 18
","class Solution {
    // Function to find the index of the minimum key in 'key' array that is not yet included in MST
    minKey(inMST, key) {
        let minIndex = 0;
        let minVal = Number.MAX_SAFE_INTEGER;
        // Loop through all vertices to find the minimum key
        for (let i = 0; i < key.length; i++) {
            // Check if the vertex is not in MST and its key is smaller than the current minimum value
            if (!inMST[i] && key[i] < minVal) {
                minIndex = i;
                minVal = key[i];
            }
        }
        return minIndex; // Return the index of the minimum key
    }

    // Function to calculate the minimum spanning tree (MST) of a given 'graph' with 'V' vertices
    MST(graph, V) {
        const key = new Array(V).fill(Number.MAX_SAFE_INTEGER); // Initialize key values for all vertices to be infinity
        const inMST = new Array(V).fill(false); // Initialize all vertices as not included in MST
        key[0] = 0; // Start with the first vertex as the source
        
        // Loop through V-1 vertices (all except the first one)
        for (let count = 1; count <= V - 1; count++) {
            const u = this.minKey(inMST, key); // Find the vertex with the minimum key not in MST
            inMST[u] = true; // Include the selected vertex in MST
            
            // Update the key values of adjacent vertices
            for (let v = 0; v < V; v++) {
                // If there is an edge from 'u' to 'v', 'v' is not in MST, and the edge weight is smaller than 'key[v]'
                if (graph[u][v] && !inMST[v] && graph[u][v] < key[v]) {
                    key[v] = graph[u][v]; // Update the key value of 'v'
                }
            }
        }
        
        let cost = 0;
        for (const i of key) {
            cost += i; // Calculate the sum of key values, which represents the minimum cost of MST
        }
        return cost; // Return the minimum cost of MST
    }

    // Function to calculate the minimum cost to connect all points using Prim's Algorithm
    minCostConnectPoints(points) {
        const n = points.length;
        const graph = new Array(n).fill().map(() => new Array(n).fill(0)); // Create a 2D matrix 'graph' to represent the distances between points
        
        // Calculate the Manhattan distance (md) between all pairs of points and populate the 'graph' matrix
        for (let i = 0; i < n - 1; i++) {
            for (let j = i + 1; j < n; j++) {
                const p1 = points[i];
                const p2 = points[j];
                const md = Math.abs(p1[0] - p2[0]) + Math.abs(p1[1] - p2[1]); // Calculate Manhattan distance
                graph[i][j] = md; // Store the distance in both directions since it's an undirected graph
                graph[j][i] = md;
            }
        }
        
        return this.MST(graph, n); // Find and return the minimum cost of connecting all points using MST
    }
}
",False
Alert Using Same Key-Card Three or More Times in a One Hour Period,"LeetCode company workers use key-cards to unlock office doors. Each time a worker uses their key-card, the security system saves the worker's name and the time when it was used. The system emits an alert if any worker uses the key-card three or more times in a one-hour period.
You are given a list of strings keyName and keyTime where [keyName[i], keyTime[i]] corresponds to a person's name and the time when their key-card was used in a single day.
Access times are given in the 24-hour time format ""HH:MM"", such as ""23:51"" and ""09:49"".
Return a list of unique worker names who received an alert for frequent keycard use. Sort the names in ascending order alphabetically.
Notice that ""10:00"" - ""11:00"" is considered to be within a one-hour period, while ""22:51"" - ""23:52"" is not considered to be within a one-hour period.
","Example 1:
Input: keyName = [""daniel"",""daniel"",""daniel"",""luis"",""luis"",""luis"",""luis""], keyTime = [""10:00"",""10:40"",""11:00"",""09:00"",""11:00"",""13:00"",""15:00""]
Output: [""daniel""]
Explanation: ""daniel"" used the keycard 3 times in a one-hour period (""10:00"",""10:40"", ""11:00"").
Example 2:
Input: keyName = [""alice"",""alice"",""alice"",""bob"",""bob"",""bob"",""bob""], keyTime = [""12:01"",""12:00"",""18:00"",""21:00"",""21:20"",""21:30"",""23:00""]
Output: [""bob""]
Explanation: ""bob"" used the keycard 3 times in a one-hour period (""21:00"",""21:20"", ""21:30"").
","class Solution {
    public List<String> alertNames(String[] keyName, String[] keyTime) {
        Map<String, List<Integer>> map = new HashMap<>();
        List<String> res = new ArrayList<>();
        for (int i = 0; i < keyName.length; i++) { // cache all visits for same person.
            String k = keyName[i];
            map.computeIfAbsent(k, g -> new ArrayList<>());
            map.get(k).add(getTime(keyTime[i]));
        }
        
        for (String k : map.keySet()) {
            List<Integer> l = map.get(k);
            Collections.sort(l);  // sort to find the connective checkins
            for (int i = 2; i < l.size(); i++)
                if (l.get(i) - l.get(i - 2) <= 60) {  // connective 3 within 60 mins.
                    res.add(k);
                    break;
                }
        }
        
        Collections.sort(res);
        return res;
    }
    
    private int getTime(String t) {  // transfer stirng to relative mins.
        String[] ss = t.split("":"");
        return Integer.parseInt(ss[1]) + 60 * Integer.parseInt(ss[0]);
    }
}",False
Crawler Log Folder,"The Leetcode file system keeps a log each time some user performs a change folder operation.
The operations are described below:
""../"" : Move to the parent folder of the current folder. (If you are already in the main folder, remain in the same folder).
""./"" : Remain in the same folder.
""x/"" : Move to the child folder named x (This folder is guaranteed to always exist).
You are given a list of strings logs where logs[i] is the operation performed by the user at the ith step.
The file system starts in the main folder, then the operations in logs are performed.
Return the minimum number of operations needed to go back to the main folder after the change folder operations.
","Example 1:

Input: logs = [""d1/"",""d2/"",""../"",""d21/"",""./""]
Output: 2
Explanation: Use this change folder operation ""../"" 2 times and go back to the main folder.
Example 2:

Input: logs = [""d1/"",""d2/"",""./"",""d3/"",""../"",""d31/""]
Output: 3
Example 3:
Input: logs = [""d1/"",""../"",""../"",""../""]
Output: 0
","class Solution:
    def minOperations(self, logs: List[str]) -> int:
        ans = 0
        for log in logs: 
            if log == ""./"": continue
            elif log == ""../"": ans = max(0, ans-1) # parent directory
            else: ans += 1 # child directory 
        return ans ",True
Special Array With X Elements Greater Than or Equal X,"You are given an array nums of non-negative integers. nums is considered special if there exists a number x such that there are exactly x numbers in nums that are greater than or equal to x.
Notice that x does not have to be an element in nums.
Return x if the array is special, otherwise, return -1. It can be proven that if nums is special, the value for x is unique.
","Example 1:
Input: nums = [3,5]
Output: 2
Explanation: There are 2 values (3 and 5) that are greater than or equal to 2.
Example 2:
Input: nums = [0,0]
Output: -1
Explanation: No numbers fit the criteria for x.
If x = 0, there should be 0 numbers >= x, but there are 2.
If x = 1, there should be 1 number >= x, but there are 0.
If x = 2, there should be 2 numbers >= x, but there are 0.
x cannot be greater since there are only 2 numbers in nums.
Example 3:
Input: nums = [0,4,3,0,4]
Output: 3
Explanation: There are 3 values that are greater than or equal to 3.
","class Solution:
    def specialArray(self, nums: List[int]) -> int:
        nums.sort()
        n=len(nums)
        for i in range(n+1):
            c=i
            for j in nums:
                if j>=i:
                    c-=1
                if c<0:
                    break
            if c==0:
                return i
        return -1


",True
Sort Array by Increasing Frequency,"Given an array of integers nums, sort the array in increasing order based on the frequency of the values. If multiple values have the same frequency, sort them in decreasing order.
Return the sorted array.
","Example 1:
Input: nums = [1,1,2,2,2,3]
Output: [3,1,1,2,2,2]
Explanation: '3' has a frequency of 1, '1' has a frequency of 2, and '2' has a frequency of 3.
Example 2:
Input: nums = [2,3,1,3,2]
Output: [1,3,3,2,2]
Explanation: '2' and '3' both have a frequency of 2, so they are sorted in decreasing order.
Example 3:
Input: nums = [-1,1,-6,4,5,-6,1,4,1]
Output: [5,-1,4,4,-6,-6,1,1,1]
","class Solution:
    def frequencySort(self, nums: List[int]) -> List[int]:
        return sorted(sorted(nums,reverse=1),key=nums.count)

    #please do upvote it will encourage me alot
		
		
        ",True
Best Team With No Conflicts,"You are the manager of a basketball team. For the upcoming tournament, you want to choose the team with the highest overall score. The score of the team is the sum of scores of all the players in the team.
However, the basketball team is not allowed to have conflicts. A conflict exists if a younger player has a strictly higher score than an older player. A conflict does not occur between players of the same age.
Given two lists, scores and ages, where each scores[i] and ages[i] represents the score and age of the ith player, respectively, return the highest overall score of all possible basketball teams.
","Example 1:
Input: scores = [1,3,5,10,15], ages = [1,2,3,4,5]
Output: 34
Explanation: You can choose all the players.
Example 2:
Input: scores = [4,5,6,5], ages = [2,1,2,1]
Output: 16
Explanation: It is best to choose the last 3 players. Notice that you are allowed to choose multiple people of the same age.
Example 3:
Input: scores = [1,2,3,5], ages = [8,9,10,1]
Output: 6
Explanation: It is best to choose the first 3 players. 
","class Solution {
public:
    int bestTeamScore(vector<int>& scores, vector<int>& ages) {
        int n = scores.size();
        
        vector<pair<int, int>> vc(n);
        for (int i = 0; i < n; ++i)
            vc[i] = {ages[i], scores[i]};
        
        sort(vc.begin(), vc.end());

        return highestScore(n, vc);
    }

    int highestScore(int n, vector<pair<int, int>> &vc) {
        int maxScore = 0;
        vector<int> dp(n);

        for (int i = 0; i < n; ++i) {
            dp[i] = vc[i].second;
            
            for (int j = i - 1; j >= 0; --j) 
                if (vc[i].second >= vc[j].second)
                    dp[i] = max(dp[i], dp[j] + vc[i].second);
            
            maxScore = max(maxScore, dp[i]);
        }

        return maxScore;
    }
};",False
Slowest Key,"A newly designed keypad was tested, where a tester pressed a sequence of n keys, one at a time.
You are given a string keysPressed of length n, where keysPressed[i] was the ith key pressed in the testing sequence, and a sorted list releaseTimes, where releaseTimes[i] was the time the ith key was released. Both arrays are 0-indexed. The 0th key was pressed at the time 0, and every subsequent key was pressed at the exact time the previous key was released.
The tester wants to know the key of the keypress that had the longest duration. The ith keypress had a duration of releaseTimes[i] - releaseTimes[i - 1], and the 0th keypress had a duration of releaseTimes[0].
Note that the same key could have been pressed multiple times during the test, and these multiple presses of the same key may not have had the same duration.
Return the key of the keypress that had the longest duration. If there are multiple such keypresses, return the lexicographically largest key of the keypresses.
","Example 1:
Input: releaseTimes = [9,29,49,50], keysPressed = ""cbcd""
Output: ""c""
Explanation: The keypresses were as follows:
Keypress for 'c' had a duration of 9 (pressed at time 0 and released at time 9).
Keypress for 'b' had a duration of 29 - 9 = 20 (pressed at time 9 right after the release of the previous character and released at time 29).
Keypress for 'c' had a duration of 49 - 29 = 20 (pressed at time 29 right after the release of the previous character and released at time 49).
Keypress for 'd' had a duration of 50 - 49 = 1 (pressed at time 49 right after the release of the previous character and released at time 50).
The longest of these was the keypress for 'b' and the second keypress for 'c', both with duration 20.
'c' is lexicographically larger than 'b', so the answer is 'c'.
Example 2:
Input: releaseTimes = [12,23,36,46,62], keysPressed = ""spuda""
Output: ""a""
Explanation: The keypresses were as follows:
Keypress for 's' had a duration of 12.
Keypress for 'p' had a duration of 23 - 12 = 11.
Keypress for 'u' had a duration of 36 - 23 = 13.
Keypress for 'd' had a duration of 46 - 36 = 10.
Keypress for 'a' had a duration of 62 - 46 = 16.
The longest of these was the keypress for 'a' with duration 16.
","class Solution:
    def slowestKey(self, r: List[int], k: str) -> str:
        times = {r[0]: [k[0]]}
        
        for i in range(1 , len(r)):
            t = r[i] - r[i - 1]
            if(t in times):
                times[t].append(k[i])
            else:
                times[t] = [k[i]]
        
        keys = times[max(times.keys())]
        
        return max(keys)",True
Arithmetic Subarrays,"A sequence of numbers is called arithmetic if it consists of at least two elements, and the difference between every two consecutive elements is the same. More formally, a sequence s is arithmetic if and only if s[i+1] - s[i] == s[1] - s[0] for all valid i.
For example, these are arithmetic sequences:
1, 3, 5, 7, 9
7, 7, 7, 7
3, -1, -5, -9
The following sequence is not arithmetic:
1, 1, 2, 5, 7
You are given an array of n integers, nums, and two arrays of m integers each, l and r, representing the m range queries, where the ith query is the range [l[i], r[i]]. All the arrays are 0-indexed.
Return a list of boolean elements answer, where answer[i] is true if the subarray nums[l[i]], nums[l[i]+1], ... , nums[r[i]] can be rearranged to form an arithmetic sequence, and false otherwise.
","Example 1:
Input: nums = [4,6,5,9,3,7], l = [0,0,2], r = [2,3,5]
Output: [true,false,true]
Explanation:
In the 0th query, the subarray is [4,6,5]. This can be rearranged as [6,5,4], which is an arithmetic sequence.
In the 1st query, the subarray is [4,6,5,9]. This cannot be rearranged as an arithmetic sequence.
In the 2nd query, the subarray is [5,9,3,7]. This can be rearranged as [3,5,7,9], which is an arithmetic sequence.
Example 2:
Input: nums = [-12,-9,-3,-12,-6,15,20,-25,-20,-15,-10], l = [0,1,6,4,8,7], r = [4,4,9,7,9,10]
Output: [false,true,false,false,true,true]
","class Solution:
    def checkArithmeticSubarrays(self, nums: List[int], l: List[int], r: List[int]) -> List[bool]:
        #variable to store the result
        n=[]
        for i in range(len(l)):
            #taking the subarray which is need to be checked and sorted
            a=nums[l[i]:r[i]+1]
            a.sort()
            check=[]
            #calculating the difference to check whether it is a arithematic subarray
            for j in range(len(a)-1):
                val=a[j+1]-a[j]
                check.append(val)
            check.sort()
            if check[0]==check[-1]:
                n.append(True)
            else:
                n.append(False)
        return n
",True
Defuse the Bomb,"You have a bomb to defuse, and your time is running out! Your informer will provide you with a circular array code of length of n and a key k.
To decrypt the code, you must replace every number. All the numbers are replaced simultaneously.
If k > 0, replace the ith number with the sum of the next k numbers.
If k < 0, replace the ith number with the sum of the previous k numbers.
If k == 0, replace the ith number with 0.
As code is circular, the next element of code[n-1] is code[0], and the previous element of code[0] is code[n-1].
Given the circular array code and an integer key k, return the decrypted code to defuse the bomb!
","Example 1:
Input: code = [5,7,1,4], k = 3
Output: [12,10,16,13]
Explanation: Each number is replaced by the sum of the next 3 numbers. The decrypted code is [7+1+4, 1+4+5, 4+5+7, 5+7+1]. Notice that the numbers wrap around.
Example 2:
Input: code = [1,2,3,4], k = 0
Output: [0,0,0,0]
Explanation: When k is zero, the numbers are replaced by 0. 
Example 3:
Input: code = [2,4,9,3], k = -2
Output: [12,5,6,13]
Explanation: The decrypted code is [3+9, 2+3, 4+2, 9+4]. Notice that the numbers wrap around again. If k is negative, the sum is of the previous numbers.
",,False
Check Array Formation Through Concatenation,"You are given an array of distinct integers arr and an array of integer arrays pieces, where the integers in pieces are distinct. Your goal is to form arr by concatenating the arrays in pieces in any order. However, you are not allowed to reorder the integers in each array pieces[i].
Return true if it is possible to form the array arr from pieces. Otherwise, return false.
","Example 1:
Input: arr = [15,88], pieces = [[88],[15]]
Output: true
Explanation: Concatenate [15] then [88]
Example 2:
Input: arr = [49,18,16], pieces = [[16,18,49]]
Output: false
Explanation: Even though the numbers match, we cannot reorder pieces[0].
Example 3:
Input: arr = [91,4,64,78], pieces = [[78],[4,64],[91]]
Output: true
Explanation: Concatenate [91] then [4,64] then [78]
","class Solution:
    def canFormArray(self, arr: List[int], pieces: List[List[int]]) -> bool:
        array_length = len(arr)
        for piece in pieces:
            i, j, piece_length = 0, 0, len(piece)
            while j < array_length and arr[j] != piece[i]:
                j += 1
            if j == len(arr):
                return False
            if arr[j: j+piece_length] != piece:
                return False
        return True
",True
Design Front Middle Back Queue,"Design a queue that supports push and pop operations in the front, middle, and back.
Implement the FrontMiddleBack class:
FrontMiddleBack() Initializes the queue.
void pushFront(int val) Adds val to the front of the queue.
void pushMiddle(int val) Adds val to the middle of the queue.
void pushBack(int val) Adds val to the back of the queue.
int popFront() Removes the front element of the queue and returns it. If the queue is empty, return -1.
int popMiddle() Removes the middle element of the queue and returns it. If the queue is empty, return -1.
int popBack() Removes the back element of the queue and returns it. If the queue is empty, return -1.
Notice that when there are two middle position choices, the operation is performed on the frontmost middle position choice. For example:
Pushing 6 into the middle of [1, 2, 3, 4, 5] results in [1, 2, 6, 3, 4, 5].
Popping the middle from [1, 2, 3, 4, 5, 6] returns 3 and results in [1, 2, 4, 5, 6].
","Example 1:
Input:
[""FrontMiddleBackQueue"", ""pushFront"", ""pushBack"", ""pushMiddle"", ""pushMiddle"", ""popFront"", ""popMiddle"", ""popMiddle"", ""popBack"", ""popFront""]
[[], [1], [2], [3], [4], [], [], [], [], []]
Output:
[null, null, null, null, null, 1, 3, 4, 2, -1]

Explanation:
FrontMiddleBackQueue q = new FrontMiddleBackQueue();
q.pushFront(1);   // [1]
q.pushBack(2);    // [1, 2]
q.pushMiddle(3);  // [1, 3, 2]
q.pushMiddle(4);  // [1, 4, 3, 2]
q.popFront();     // return 1 -> [4, 3, 2]
q.popMiddle();    // return 3 -> [4, 2]
q.popMiddle();    // return 4 -> [2]
q.popBack();      // return 2 -> []
q.popFront();     // return -1 -> [] (The queue is empty)
",,False
Design an Ordered Stream,"There is a stream of n (idKey, value) pairs arriving in an arbitrary order, where idKey is an integer between 1 and n and value is a string. No two pairs have the same id.
Design a stream that returns the values in increasing order of their IDs by returning a chunk (list) of values after each insertion. The concatenation of all the chunks should result in a list of the sorted values.
Implement the OrderedStream class:
OrderedStream(int n) Constructs the stream to take n values.
String[] insert(int idKey, String value) Inserts the pair (idKey, value) into the stream, then returns the largest possible chunk of currently inserted values that appear next in the order.
","Example:

Input
[""OrderedStream"", ""insert"", ""insert"", ""insert"", ""insert"", ""insert""]
[[5], [3, ""ccccc""], [1, ""aaaaa""], [2, ""bbbbb""], [5, ""eeeee""], [4, ""ddddd""]]
Output
[null, [], [""aaaaa""], [""bbbbb"", ""ccccc""], [], [""ddddd"", ""eeeee""]]

Explanation
// Note that the values ordered by ID is [""aaaaa"", ""bbbbb"", ""ccccc"", ""ddddd"", ""eeeee""].
OrderedStream os = new OrderedStream(5);
os.insert(3, ""ccccc""); // Inserts (3, ""ccccc""), returns [].
os.insert(1, ""aaaaa""); // Inserts (1, ""aaaaa""), returns [""aaaaa""].
os.insert(2, ""bbbbb""); // Inserts (2, ""bbbbb""), returns [""bbbbb"", ""ccccc""].
os.insert(5, ""eeeee""); // Inserts (5, ""eeeee""), returns [].
os.insert(4, ""ddddd""); // Inserts (4, ""ddddd""), returns [""ddddd"", ""eeeee""].
// Concatentating all the chunks returned:
// [] + [""aaaaa""] + [""bbbbb"", ""ccccc""] + [] + [""ddddd"", ""eeeee""] = [""aaaaa"", ""bbbbb"", ""ccccc"", ""ddddd"", ""eeeee""]
// The resulting order is the same as the order above.
",,False
Check If Two String Arrays are Equivalent,"Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.
A string is represented by an array if the array elements concatenated in order forms the string.
","Example 1:
Input: word1 = [""ab"", ""c""], word2 = [""a"", ""bc""]
Output: true
Explanation:
word1 represents string ""ab"" + ""c"" -> ""abc""
word2 represents string ""a"" + ""bc"" -> ""abc""
The strings are the same, so return true.
Example 2:
Input: word1 = [""a"", ""cb""], word2 = [""ab"", ""c""]
Output: false
Example 3:
Input: word1  = [""abc"", ""d"", ""defg""], word2 = [""abcddefg""]
Output: true
","class Solution:
    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:
        return True if ''.join(word1) == ''.join(word2) else False",True
Count the Number of Consistent Strings,"You are given a string allowed consisting of distinct characters and an array of strings words. A string is consistent if all characters in the string appear in the string allowed.
Return the number of consistent strings in the array words.
","Example 1:
Input: allowed = ""ab"", words = [""ad"",""bd"",""aaab"",""baa"",""badab""]
Output: 2
Explanation: Strings ""aaab"" and ""baa"" are consistent since they only contain characters 'a' and 'b'.
Example 2:
Input: allowed = ""abc"", words = [""a"",""b"",""c"",""ab"",""ac"",""bc"",""abc""]
Output: 7
Explanation: All strings are consistent.
Example 3:
Input: allowed = ""cad"", words = [""cc"",""acd"",""b"",""ba"",""bac"",""bad"",""ac"",""d""]
Output: 4
Explanation: Strings ""cc"", ""acd"", ""ac"", and ""d"" are consistent.
","class Solution:
    def countConsistentStrings(self, allowed: str, words: List[str]) -> int:
        return sum(set(allowed) >= set(i) for i in words)",True
Sum of Absolute Differences in a Sorted Array,"You are given an integer array nums sorted in non-decreasing order.
Build and return an integer array result with the same length as nums such that result[i] is equal to the summation of absolute differences between nums[i] and all the other elements in the array.
In other words, result[i] is equal to sum(|nums[i]-nums[j]|) where 0 <= j < nums.length and j != i (0-indexed).
","Example 1:
Input: nums = [2,3,5]
Output: [4,3,5]
Explanation: Assuming the arrays are 0-indexed, then
result[0] = |2-2| + |2-3| + |2-5| = 0 + 1 + 3 = 4,
result[1] = |3-2| + |3-3| + |3-5| = 1 + 0 + 2 = 3,
result[2] = |5-2| + |5-3| + |5-5| = 3 + 2 + 0 = 5.
Example 2:
Input: nums = [1,4,6,8,10]
Output: [24,15,13,15,21]
","class Solution:
    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:
        s,n=0,len(nums)
        ps,ans=[0]*n,[0]*n
        for i in range(n):
            s+=nums[i]
            ps[i]=s
        for i in range(n):
            ans[i] = s - 2*ps[i] - nums[i]*(n-1-i) + nums[i]*(i+1)
        return ans",True
Richest Customer Wealth,"You are given an m x n integer grid accounts where accounts[i][j] is the amount of money the ith customer has in the jth bank. Return the wealth that the richest customer has.
A customer's wealth is the amount of money they have in all their bank accounts. The richest customer is the customer that has the maximum wealth.
","Example 1:
Input: accounts = [[1,2,3],[3,2,1]]
Output: 6
Explanation:
1st customer has wealth = 1 + 2 + 3 = 6
2nd customer has wealth = 3 + 2 + 1 = 6
Both customers are considered the richest with a wealth of 6 each, so return 6.
Example 2:
Input: accounts = [[1,5],[7,3],[3,5]]
Output: 10
Explanation: 
1st customer has wealth = 6
2nd customer has wealth = 10 
3rd customer has wealth = 8
The 2nd customer is the richest with a wealth of 10.
Example 3:
Input: accounts = [[2,8,7],[7,1,3],[1,9,5]]
Output: 17
","class Solution:
    def maximumWealth(self, accounts: List[List[int]]) -> int:
        m = sum(accounts[0])
        for i in accounts:
            m = max(m, sum(i))
        return m",True
Minimum Moves to Make Array Complementary,"You are given an integer array nums of even length n and an integer limit. In one move, you can replace any integer from nums with another integer between 1 and limit, inclusive.
The array nums is complementary if for all indices i (0-indexed), nums[i] + nums[n - 1 - i] equals the same number. For example, the array [1,2,3,4] is complementary because for all indices i, nums[i] + nums[n - 1 - i] = 5.
Return the minimum number of moves required to make nums complementary.
","Example 1:
Input: nums = [1,2,4,3], limit = 4
Output: 1
Explanation: In 1 move, you can change nums to [1,2,2,3] (underlined elements are changed).
nums[0] + nums[3] = 1 + 3 = 4.
nums[1] + nums[2] = 2 + 2 = 4.
nums[2] + nums[1] = 2 + 2 = 4.
nums[3] + nums[0] = 3 + 1 = 4.
Therefore, nums[i] + nums[n-1-i] = 4 for every i, so nums is complementary.
Example 2:
Input: nums = [1,2,2,1], limit = 2
Output: 2
Explanation: In 2 moves, you can change nums to [2,2,2,2]. You cannot change any number to 3 since 3 > limit.
Example 3:
Input: nums = [1,2,1,2], limit = 2
Output: 0
Explanation: nums is already complementary.
",,False
Max Number of K-Sum Pairs,"You are given an integer array nums and an integer k.
In one operation, you can pick two numbers from the array whose sum equals k and remove them from the array.
Return the maximum number of operations you can perform on the array.
","Example 1:
Input: nums = [1,2,3,4], k = 5
Output: 2
Explanation: Starting with nums = [1,2,3,4]:
- Remove numbers 1 and 4, then nums = [2,3]
- Remove numbers 2 and 3, then nums = []
There are no more pairs that sum up to 5, hence a total of 2 operations.
Example 2:
Input: nums = [3,1,3,4,3], k = 6
Output: 1
Explanation: Starting with nums = [3,1,3,4,3]:
- Remove the first two 3's, then nums = [1,4,3]
There are no more pairs that sum up to 6, hence a total of 1 operation.
",,False
Number of Students Unable to Eat Lunch,"The school cafeteria offers circular and square sandwiches at lunch break, referred to by numbers 0 and 1 respectively. All students stand in a queue. Each student either prefers square or circular sandwiches.
The number of sandwiches in the cafeteria is equal to the number of students. The sandwiches are placed in a stack. At each step:
If the student at the front of the queue prefers the sandwich on the top of the stack, they will take it and leave the queue.
Otherwise, they will leave it and go to the queue's end.
This continues until none of the queue students want to take the top sandwich and are thus unable to eat.
You are given two integer arrays students and sandwiches where sandwiches[i] is the type of the ith sandwich in the stack (i = 0 is the top of the stack) and students[j] is the preference of the jth student in the initial queue (j = 0 is the front of the queue). Return the number of students that are unable to eat.
","Example 1:
Input: students = [1,1,0,0], sandwiches = [0,1,0,1]
Output: 0 
Explanation:
- Front student leaves the top sandwich and returns to the end of the line making students = [1,0,0,1].
- Front student leaves the top sandwich and returns to the end of the line making students = [0,0,1,1].
- Front student takes the top sandwich and leaves the line making students = [0,1,1] and sandwiches = [1,0,1].
- Front student leaves the top sandwich and returns to the end of the line making students = [1,1,0].
- Front student takes the top sandwich and leaves the line making students = [1,0] and sandwiches = [0,1].
- Front student leaves the top sandwich and returns to the end of the line making students = [0,1].
- Front student takes the top sandwich and leaves the line making students = [1] and sandwiches = [1].
- Front student takes the top sandwich and leaves the line making students = [] and sandwiches = [].
Hence all students are able to eat.
Example 2:
Input: students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1]
Output: 3
",,False
Construct the Lexicographically Largest Valid Sequence,"Given an integer n, find a sequence that satisfies all of the following:
The integer 1 occurs once in the sequence.
Each integer between 2 and n occurs twice in the sequence.
For every integer i between 2 and n, the distance between the two occurrences of i is exactly i.
The distance between two numbers on the sequence, a[i] and a[j], is the absolute difference of their indices, |j - i|.
Return the lexicographically largest sequence. It is guaranteed that under the given constraints, there is always a solution.
A sequence a is lexicographically larger than a sequence b (of the same length) if in the first position where a and b differ, sequence a has a number greater than the corresponding number in b. For example, [0,1,9,0] is lexicographically larger than [0,1,5,6] because the first position they differ is at the third number, and 9 is greater than 5.
","Example 1:
Input: n = 3
Output: [3,1,2,3,2]
Explanation: [2,3,2,1,3] is also a valid sequence, but [3,1,2,3,2] is the lexicographically largest valid sequence.
Example 2:
Input: n = 5
Output: [5,3,1,4,3,5,2,4,2]
","class Solution:
    def constructDistancedSequence(self, n: int) -> List[int]:
        m = 2*n - 1
        A = [0]*m
        path = set()
        def dfs(i):
            if i == m:
                return all(A)
            if A[i]:
                return dfs(i+1)
            for v in range(n, 0, -1):
                j = i if v == 1 else i + v
                if v not in path and j < m and not A[j]:
                    A[i], A[j] = v, v
                    path.add(v)
                    if dfs(i+1): return True
                    A[i], A[j] = 0, 0
                    path.remove(v)
            return False
        if dfs(0): return A
        return []
",True
Count Good Meals,"A good meal is a meal that contains exactly two different food items with a sum of deliciousness equal to a power of two.
You can pick any two different foods to make a good meal.
Given an array of integers deliciousness where deliciousness[i] is the deliciousness of the ith item of food, return the number of different good meals you can make from this list modulo 109 + 7.
Note that items with different indices are considered different even if they have the same deliciousness value.
","Example 1:
Input: deliciousness = [1,3,5,7,9]
Output: 4
Explanation: The good meals are (1,3), (1,7), (3,5) and, (7,9).
Their respective sums are 4, 8, 8, and 16, all of which are powers of 2.
Example 2:
Input: deliciousness = [1,1,1,3,3,3,7]
Output: 15
Explanation: The good meals are (1,1) with 3 ways, (1,3) with 9 ways, and (1,7) with 3 ways.
","class Solution:
    def countPairs(self, deliciousness):
        total, dict1, mod = 0, defaultdict(int), 10**9+7

        for i in deliciousness:
            for k in range(30): total += dict1[2**k-i]
            dict1[i] += 1 

        return total%mod",True
Find the Highest Altitude,"There is a biker going on a road trip. The road trip consists of n + 1 points at different altitudes. The biker starts his trip on point 0 with altitude equal 0.
You are given an integer array gain of length n where gain[i] is the net gain in altitude between points i and i + 1 for all (0 <= i < n). Return the highest altitude of a point.
","Example 1:
Input: gain = [-5,1,5,0,-7]
Output: 1
Explanation: The altitudes are [0,-5,-4,1,1,-6]. The highest is 1.
Example 2:
Input: gain = [-4,-3,-2,-1,4,3,2]
Output: 0
Explanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest is 0.
","class Solution:
    def largestAltitude(self, gain: List[int]) -> int:
        height = 0
        m_height = 0
        for i in range(len(gain)):
            height +=gain[i]
            m_height = max(m_height,height)
        return m_height",True
Decode XORed Permutation,"There is an integer array perm that is a permutation of the first n positive integers, where n is always odd.
It was encoded into another integer array encoded of length n - 1, such that encoded[i] = perm[i] XOR perm[i + 1]. For example, if perm = [1,3,2], then encoded = [2,1].
Given the encoded array, return the original array perm. It is guaranteed that the answer exists and is unique.
","Example 1:
Input: encoded = [3,1]
Output: [1,2,3]
Explanation: If perm = [1,2,3], then encoded = [1 XOR 2,2 XOR 3] = [3,1]
Example 2:
Input: encoded = [6,5,4,6]
Output: [2,4,1,5,3]
","class Solution:
    def decode(self, encoded: List[int]) -> List[int]:
        
        # The main goal is to just find the first element in perm
        # After that we can just apply, 
        # A XOR B = C ==> B = C XOR A

        # So for finding that,
        # We are told that perm has 1 to len(encoded)+1
        # Say, n = len(encoded) + 1
        # Say, encoded = [6,5,4,6] = [a^b,b^c,c^d,d^e]
        # Say, perm = [a,b,c,d,e]
        # Now to find a,
        # (XOR of all elements from 1 to n) ^ (b^c^d^e)
        # i.e, (a^b^c^d^e) ^ (b^c^d^e)
        # For (b^c^d^e), find XOR of alternative elements in encoded
        # encoded = [a^b,b^c,c^d,d^e]
        # XOR(encoded[1]^encoded[3]...)

        first = 0
        perm = []

        for i in range(1,len(encoded)+2):
            first ^= i

        for i in range(1,len(encoded),2):
            first ^= encoded[i]
        
        perm.append(first)

        for i in range(len(encoded)):
            perm.append(perm[i] ^ encoded[i])

        return perm",True
Number Of Rectangles That Can Form The Largest Square,"You are given an array rectangles where rectangles[i] = [li, wi] represents the ith rectangle of length li and width wi.
You can cut the ith rectangle to form a square with a side length of k if both k <= li and k <= wi. For example, if you have a rectangle [4,6], you can cut it to get a square with a side length of at most 4.
Let maxLen be the side length of the largest square you can obtain from any of the given rectangles.
Return the number of rectangles that can make a square with a side length of maxLen.
","Example 1:
Input: rectangles = [[5,8],[3,9],[5,12],[16,5]]
Output: 3
Explanation: The largest squares you can get from each rectangle are of lengths [5,3,5,5].
The largest possible square is of length 5, and you can get it out of 3 rectangles.
Example 2:
Input: rectangles = [[2,3],[3,7],[4,3],[3,7]]
Output: 3
","class Solution:
    def countGoodRectangles(self, rectangles: List[List[int]]) -> int:
        c = []
        count = 0
        for i in rectangles:
            c.append(min(i))
        ans = max(c)
        for j in range(len(c)):
            if c[j] == ans:
                count = count+1
        return count",True
Largest Submatrix With Rearrangements,"You are given a binary matrix matrix of size m x n, and you are allowed to rearrange the columns of the matrix in any order.
Return the area of the largest submatrix within matrix where every element of the submatrix is 1 after reordering the columns optimally.
","Example 1:

Input: matrix = [[0,0,1],[1,1,1],[1,0,1]]
Output: 4
Explanation: You can rearrange the columns as shown above.
The largest submatrix of 1s, in bold, has an area of 4.
Example 2:

Input: matrix = [[1,0,1,0,1]]
Output: 3
Explanation: You can rearrange the columns as shown above.
The largest submatrix of 1s, in bold, has an area of 3.
Example 3:
Input: matrix = [[1,1,0],[1,0,1]]
Output: 2
Explanation: Notice that you must rearrange entire columns, and there is no way to make a submatrix of 1s larger than an area of 2.
","class Solution:
    def largestSubmatrix(self, matrix: List[List[int]]) -> int:
        row, col = len(matrix), len(matrix[0])

        # Calculate heights for each column
        for i in range(1, row):
            for j in range(col):
                if matrix[i][j] == 1:
                    matrix[i][j] += matrix[i - 1][j]

        res = 0
        for i in range(row):
            # Sort the heights in ascending order
            matrix[i].sort()

            # Iterate through the sorted heights
            for j in range(col):
                height = matrix[i][j]
                width = col - j
                res = max(res, height * width)

        return res",True
Sum of Unique Elements,"You are given an integer array nums. The unique elements of an array are the elements that appear exactly once in the array.
Return the sum of all the unique elements of nums.
","Example 1:
Input: nums = [1,2,3,2]
Output: 4
Explanation: The unique elements are [1,3], and the sum is 4.
Example 2:
Input: nums = [1,1,1,1,1]
Output: 0
Explanation: There are no unique elements, and the sum is 0.
Example 3:
Input: nums = [1,2,3,4,5]
Output: 15
Explanation: The unique elements are [1,2,3,4,5], and the sum is 15.
","class Solution:
    def sumOfUnique(self, nums: List[int]) -> int:

        a=0

        for i in nums:
            if nums.count(i)==1:
                a=a+i
        return a",True
Check if Array Is Sorted and Rotated,"Given an array nums, return true if the array was originally sorted in non-decreasing order, then rotated some number of positions (including zero). Otherwise, return false.
There may be duplicates in the original array.
Note: An array A rotated by x positions results in an array B of the same length such that A[i] == B[(i+x) % A.length], where % is the modulo operation.
","Example 1:
Input: nums = [3,4,5,1,2]
Output: true
Explanation: [1,2,3,4,5] is the original sorted array.
You can rotate the array by x = 3 positions to begin on the the element of value 3: [3,4,5,1,2].
Example 2:
Input: nums = [2,1,3,4]
Output: false
Explanation: There is no sorted array once rotated that can make nums.
Example 3:
Input: nums = [1,2,3]
Output: true
Explanation: [1,2,3] is the original sorted array.
You can rotate the array by x = 0 positions (i.e. no rotation) to make nums.
","class Solution:
    def check(self, nums: List[int]) -> bool:
        cliff = None
        for i in range(len(nums)-1):
            if nums[i] > nums[i+1]:
                if cliff is not None:
                    return False
                cliff = i
        if cliff is None:
            return True
        return nums[0] >= nums[-1]
            ",True
Find Nearest Point That Has the Same X or Y Coordinate,"You are given two integers, x and y, which represent your current location on a Cartesian grid: (x, y). You are also given an array points where each points[i] = [ai, bi] represents that a point exists at (ai, bi). A point is valid if it shares the same x-coordinate or the same y-coordinate as your location.
Return the index (0-indexed) of the valid point with the smallest Manhattan distance from your current location. If there are multiple, return the valid point with the smallest index. If there are no valid points, return -1.
The Manhattan distance between two points (x1, y1) and (x2, y2) is abs(x1 - x2) + abs(y1 - y2).
","Example 1:
Input: x = 3, y = 4, points = [[1,2],[3,1],[2,4],[2,3],[4,4]]
Output: 2
Explanation: Of all the points, only [3,1], [2,4] and [4,4] are valid. Of the valid points, [2,4] and [4,4] have the smallest Manhattan distance from your current location, with a distance of 1. [2,4] has the smallest index, so return 2.
Example 2:
Input: x = 3, y = 4, points = [[3,4]]
Output: 0
Explanation: The answer is allowed to be on the same location as your current location.
Example 3:
Input: x = 3, y = 4, points = [[2,3]]
Output: -1
Explanation: There are no valid points.
","class Solution:
    def nearestValidPoint(self, x: int, y: int, points: List[List[int]]) -> int:

        minn=float('inf')
        index=-1
        for i , v in enumerate(points):
            if v[0]==x or v[1]==y:
                man_dis=abs(x - v[0]) + abs(y - v[1])
                if(man_dis<minn) :
                    minn=man_dis
                    index=i
        
        return index",True
Count Items Matching a Rule,"You are given an array items, where each items[i] = [typei, colori, namei] describes the type, color, and name of the ith item. You are also given a rule represented by two strings, ruleKey and ruleValue.
The ith item is said to match the rule if one of the following is true:
ruleKey == ""type"" and ruleValue == typei.
ruleKey == ""color"" and ruleValue == colori.
ruleKey == ""name"" and ruleValue == namei.
Return the number of items that match the given rule.
","Example 1:
Input: items = [[""phone"",""blue"",""pixel""],[""computer"",""silver"",""lenovo""],[""phone"",""gold"",""iphone""]], ruleKey = ""color"", ruleValue = ""silver""
Output: 1
Explanation: There is only one item matching the given rule, which is [""computer"",""silver"",""lenovo""].
Example 2:
Input: items = [[""phone"",""blue"",""pixel""],[""computer"",""silver"",""phone""],[""phone"",""gold"",""iphone""]], ruleKey = ""type"", ruleValue = ""phone""
Output: 2
Explanation: There are only two items matching the given rule, which are [""phone"",""blue"",""pixel""] and [""phone"",""gold"",""iphone""]. Note that the item [""computer"",""silver"",""phone""] does not match.
","class Solution:
    def countMatches(self, items: List[List[str]], ruleKey: str, ruleValue: str) -> int:
        dict = {'type': 0, 'color': 1, 'name': 2}
        cnt = 0
        for i in items:
            if i[dict[ruleKey]] == ruleValue: cnt+=1
        return cnt",True
Maximum Average Pass Ratio,"There is a school that has classes of students and each class will be having a final exam. You are given a 2D integer array classes, where classes[i] = [passi, totali]. You know beforehand that in the ith class, there are totali total students, but only passi number of students will pass the exam.
You are also given an integer extraStudents. There are another extraStudents brilliant students that are guaranteed to pass the exam of any class they are assigned to. You want to assign each of the extraStudents students to a class in a way that maximizes the average pass ratio across all the classes.
The pass ratio of a class is equal to the number of students of the class that will pass the exam divided by the total number of students of the class. The average pass ratio is the sum of pass ratios of all the classes divided by the number of the classes.
Return the maximum possible average pass ratio after assigning the extraStudents students. Answers within 10-5 of the actual answer will be accepted.
","Example 1:
Input: classes = [[1,2],[3,5],[2,2]], extraStudents = 2
Output: 0.78333
Explanation: You can assign the two extra students to the first class. The average pass ratio will be equal to (3/4 + 3/5 + 2/2) / 3 = 0.78333.
Example 2:
Input: classes = [[2,4],[3,9],[4,5],[2,10]], extraStudents = 4
Output: 0.53485
","class Solution:
    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:

        hq = []

        for p,t in classes:
            heappush(hq, ( (p/t) - ( (p+1)/(t+1) ) , p, t))

        curr = 0

        while curr<extraStudents:
            _, p, t = heappop(hq)
            p+=1
            t+=1
            curr+=1
            heappush(hq, ( (p/t) - ( (p+1)/(t+1) ) , p, t))

        res = 0
        for _, p, t in hq:
            res+= (p/t)

        return res/len(classes)",True
Count Nice Pairs in an Array,"You are given an array nums that consists of non-negative integers. Let us define rev(x) as the reverse of the non-negative integer x. For example, rev(123) = 321, and rev(120) = 21. A pair of indices (i, j) is nice if it satisfies all of the following conditions:
0 <= i < j < nums.length
nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])
Return the number of nice pairs of indices. Since that number can be too large, return it modulo 109 + 7.
","Example 1:
Input: nums = [42,11,1,97]
Output: 2
Explanation: The two pairs are:
 - (0,3) : 42 + rev(97) = 42 + 79 = 121, 97 + rev(42) = 97 + 24 = 121.
 - (1,2) : 11 + rev(1) = 11 + 1 = 12, 1 + rev(11) = 1 + 11 = 12.
Example 2:
Input: nums = [13,10,35,24,76]
Output: 4
","class Solution:
    def countNicePairs(self, nums: List[int]) -> int:
        #reversing the numbers in the nums list
        reverse=[int(str(s)[::-1]) for s in nums]
        #Finding the difference between orginal and reversed numbers
        diff=[]
        for i in range(len(nums)):
            a=nums[i]-reverse[i]
            diff.append(a)
        #Count the frequency(numbers which have same value difference)
        frq_count=Counter(diff)
        count=list(frq_count.values())
        sum=0
        #Finding the count of nice pairs
        for n in count:
            sum+=(n*(n-1))//2
        return sum%(10**9+7)

",True
Number of Orders in the Backlog,"You are given a 2D integer array orders, where each orders[i] = [pricei, amounti, orderTypei] denotes that amounti orders have been placed of type orderTypei at the price pricei. The orderTypei is:
0 if it is a batch of buy orders, or
1 if it is a batch of sell orders.
Note that orders[i] represents a batch of amounti independent orders with the same price and order type. All orders represented by orders[i] will be placed before all orders represented by orders[i+1] for all valid i.
There is a backlog that consists of orders that have not been executed. The backlog is initially empty. When an order is placed, the following happens:
If the order is a buy order, you look at the sell order with the smallest price in the backlog. If that sell order's price is smaller than or equal to the current buy order's price, they will match and be executed, and that sell order will be removed from the backlog. Else, the buy order is added to the backlog.
Vice versa, if the order is a sell order, you look at the buy order with the largest price in the backlog. If that buy order's price is larger than or equal to the current sell order's price, they will match and be executed, and that buy order will be removed from the backlog. Else, the sell order is added to the backlog.
Return the total amount of orders in the backlog after placing all the orders from the input. Since this number can be large, return it modulo 109 + 7.
","Example 1:

Input: orders = [[10,5,0],[15,2,1],[25,1,1],[30,4,0]]
Output: 6
Explanation: Here is what happens with the orders:
- 5 orders of type buy with price 10 are placed. There are no sell orders, so the 5 orders are added to the backlog.
- 2 orders of type sell with price 15 are placed. There are no buy orders with prices larger than or equal to 15, so the 2 orders are added to the backlog.
- 1 order of type sell with price 25 is placed. There are no buy orders with prices larger than or equal to 25 in the backlog, so this order is added to the backlog.
- 4 orders of type buy with price 30 are placed. The first 2 orders are matched with the 2 sell orders of the least price, which is 15 and these 2 sell orders are removed from the backlog. The 3rd order is matched with the sell order of the least price, which is 25 and this sell order is removed from the backlog. Then, there are no more sell orders in the backlog, so the 4th order is added to the backlog.
Finally, the backlog has 5 buy orders with price 10, and 1 buy order with price 30. So the total number of orders in the backlog is 6.
Example 2:

Input: orders = [[7,1000000000,1],[15,3,0],[5,999999995,0],[5,1,1]]
Output: 999999984
Explanation: Here is what happens with the orders:
- 109 orders of type sell with price 7 are placed. There are no buy orders, so the 109 orders are added to the backlog.
- 3 orders of type buy with price 15 are placed. They are matched with the 3 sell orders with the least price which is 7, and those 3 sell orders are removed from the backlog.
- 999999995 orders of type buy with price 5 are placed. The least price of a sell order is 7, so the 999999995 orders are added to the backlog.
- 1 order of type sell with price 5 is placed. It is matched with the buy order of the highest price, which is 5, and that buy order is removed from the backlog.
Finally, the backlog has (1000000000-3) sell orders with price 7, and (999999995-1) buy orders with price 5. So the total number of orders = 1999999991, which is equal to 999999984 % (109 + 7).
","class Solution:
    def getNumberOfBacklogOrders(self, orders: List[List[int]]) -> int:
        bidbook = []
        askbook = []
        for price,amount,otype in orders:
            if otype == 0:
                while amount and askbook and askbook[0][0]<=price:
                    askp,asks = heapq.heappop(askbook)
                    if amount >= asks:
                        amount -= asks
                    else:
                        asks -= amount
                        amount = 0
                        heapq.heappush(askbook,(askp,asks))
                if amount:
                    heapq.heappush(bidbook,(-price,amount))
            else:
                while amount and bidbook and -bidbook[0][0]>=price:
                    bidp,bids = heapq.heappop(bidbook)
                    if amount >= bids:
                        amount -= bids
                    else:
                        bids -= amount
                        amount = 0
                        heapq.heappush(bidbook,(bidp,bids))
                if amount:
                    heapq.heappush(askbook,(price,amount))
        res = 0
        for p,m in bidbook:
            res += m
        for p,m in askbook:
            res += m
        return res % (10**9+7)
                    


        
",True
Truncate Sentence,"A sentence is a list of words that are separated by a single space with no leading or trailing spaces. Each of the words consists of only uppercase and lowercase English letters (no punctuation).
For example, ""Hello World"", ""HELLO"", and ""hello world hello world"" are all sentences.
You are given a sentence s and an integer k. You want to truncate s such that it contains only the first k words. Return s after truncating it.
","Example 1:
Input: s = ""Hello how are you Contestant"", k = 4
Output: ""Hello how are you""
Explanation:
The words in s are [""Hello"", ""how"" ""are"", ""you"", ""Contestant""].
The first 4 words are [""Hello"", ""how"", ""are"", ""you""].
Hence, you should return ""Hello how are you"".
Example 2:
Input: s = ""What is the solution to this problem"", k = 4
Output: ""What is the solution""
Explanation:
The words in s are [""What"", ""is"" ""the"", ""solution"", ""to"", ""this"", ""problem""].
The first 4 words are [""What"", ""is"", ""the"", ""solution""].
Hence, you should return ""What is the solution"".
Example 3:
Input: s = ""chopper is not a tanuki"", k = 5
Output: ""chopper is not a tanuki""
","class Solution:
    def truncateSentence(self, s: str, k: int) -> str:
        lst=s.split("" "")
        ans=[]
        for i in range(k):
            ans.append(lst[i])
        return "" "".join(ans)
        ",True
Sign of the Product of an Array,"There is a function signFunc(x) that returns:
1 if x is positive.
-1 if x is negative.
0 if x is equal to 0.
You are given an integer array nums. Let product be the product of all values in the array nums.
Return signFunc(product).
","Example 1:
Input: nums = [-1,-2,-3,-4,3,2,1]
Output: 1
Explanation: The product of all values in the array is 144, and signFunc(144) = 1
Example 2:
Input: nums = [1,5,0,2,-3]
Output: 0
Explanation: The product of all values in the array is 0, and signFunc(0) = 0
Example 3:
Input: nums = [-1,1,-1,1,-1]
Output: -1
Explanation: The product of all values in the array is -1, and signFunc(-1) = -1
","class Solution:
    def arraySign(self, nums: List[int]) -> int:
        ans = 1
        for x in nums: 
            if x == 0: return 0 
            if x < 0: ans *= -1
        return ans ",True
Maximum Element After Decreasing and Rearranging,"You are given an array of positive integers arr. Perform some operations (possibly none) on arr so that it satisfies these conditions:
The value of the first element in arr must be 1.
The absolute difference between any 2 adjacent elements must be less than or equal to 1. In other words, abs(arr[i] - arr[i - 1]) <= 1 for each i where 1 <= i < arr.length (0-indexed). abs(x) is the absolute value of x.
There are 2 types of operations that you can perform any number of times:
Decrease the value of any element of arr to a smaller positive integer.
Rearrange the elements of arr to be in any order.
Return the maximum possible value of an element in arr after performing the operations to satisfy the conditions.
","Example 1:
Input: arr = [2,2,1,2,1]
Output: 2
Explanation: 
We can satisfy the conditions by rearranging arr so it becomes [1,2,2,2,1].
The largest element in arr is 2.
Example 2:
Input: arr = [100,1,1000]
Output: 3
Explanation: 
One possible way to satisfy the conditions is by doing the following:
1. Rearrange arr so it becomes [1,100,1000].
2. Decrease the value of the second element to 2.
3. Decrease the value of the third element to 3.
Now arr = [1,2,3], which satisfies the conditions.
The largest element in arr is 3.
Example 3:
Input: arr = [1,2,3,4,5]
Output: 5
Explanation: The array already satisfies the conditions, and the largest element is 5.
","class Solution:
    def maximumElementAfterDecrementingAndRearranging(self, arr: List[int]) -> int:
        arr.sort()
        arr[0]=1
        for i in range(1,len(arr)):
            if arr[i]-arr[i-1]>1:arr[i]=arr[i-1]+1
        return arr[-1]",True
Maximum Ice Cream Bars,"It is a sweltering summer day, and a boy wants to buy some ice cream bars.
At the store, there are n ice cream bars. You are given an array costs of length n, where costs[i] is the price of the ith ice cream bar in coins. The boy initially has coins coins to spend, and he wants to buy as many ice cream bars as possible. 
Note: The boy can buy the ice cream bars in any order.
Return the maximum number of ice cream bars the boy can buy with coins coins.
You must solve the problem by counting sort.
","Example 1:
Input: costs = [1,3,2,4,1], coins = 7
Output: 4
Explanation: The boy can buy ice cream bars at indices 0,1,2,4 for a total price of 1 + 3 + 2 + 1 = 7.
Example 2:
Input: costs = [10,6,8,7,7,8], coins = 5
Output: 0
Explanation: The boy cannot afford any of the ice cream bars.
Example 3:
Input: costs = [1,6,3,1,2,5], coins = 20
Output: 6
Explanation: The boy can buy all the ice cream bars for a total price of 1 + 6 + 3 + 1 + 2 + 5 = 18.
",,False
Single-Threaded CPU,"You are given n tasks labeled from 0 to n - 1 represented by a 2D integer array tasks, where tasks[i] = [enqueueTimei, processingTimei] means that the ith task will be available to process at enqueueTimei and will take processingTimei to finish processing.
You have a single-threaded CPU that can process at most one task at a time and will act in the following way:
If the CPU is idle and there are no available tasks to process, the CPU remains idle.
If the CPU is idle and there are available tasks, the CPU will choose the one with the shortest processing time. If multiple tasks have the same shortest processing time, it will choose the task with the smallest index.
Once a task is started, the CPU will process the entire task without stopping.
The CPU can finish a task then start a new one instantly.
Return the order in which the CPU will process the tasks.
","Example 1:
Input: tasks = [[1,2],[2,4],[3,2],[4,1]]
Output: [0,2,3,1]
Explanation: The events go as follows: 
- At time = 1, task 0 is available to process. Available tasks = {0}.
- Also at time = 1, the idle CPU starts processing task 0. Available tasks = {}.
- At time = 2, task 1 is available to process. Available tasks = {1}.
- At time = 3, task 2 is available to process. Available tasks = {1, 2}.
- Also at time = 3, the CPU finishes task 0 and starts processing task 2 as it is the shortest. Available tasks = {1}.
- At time = 4, task 3 is available to process. Available tasks = {1, 3}.
- At time = 5, the CPU finishes task 2 and starts processing task 3 as it is the shortest. Available tasks = {1}.
- At time = 6, the CPU finishes task 3 and starts processing task 1. Available tasks = {}.
- At time = 10, the CPU finishes task 1 and becomes idle.
Example 2:
Input: tasks = [[7,10],[7,12],[7,5],[7,4],[7,2]]
Output: [4,3,2,0,1]
Explanation: The events go as follows:
- At time = 7, all the tasks become available. Available tasks = {0,1,2,3,4}.
- Also at time = 7, the idle CPU starts processing task 4. Available tasks = {0,1,2,3}.
- At time = 9, the CPU finishes task 4 and starts processing task 3. Available tasks = {0,1,2}.
- At time = 13, the CPU finishes task 3 and starts processing task 2. Available tasks = {0,1}.
- At time = 18, the CPU finishes task 2 and starts processing task 0. Available tasks = {1}.
- At time = 28, the CPU finishes task 0 and starts processing task 1. Available tasks = {}.
- At time = 40, the CPU finishes task 1 and becomes idle.
",,False
Frequency of the Most Frequent Element,"The frequency of an element is the number of times it occurs in an array.
You are given an integer array nums and an integer k. In one operation, you can choose an index of nums and increment the element at that index by 1.
Return the maximum possible frequency of an element after performing at most k operations.
","Example 1:
Input: nums = [1,2,4], k = 5
Output: 3
Explanation: Increment the first element three times and the second element two times to make nums = [4,4,4].
4 has a frequency of 3.
Example 2:
Input: nums = [1,4,8,13], k = 5
Output: 2
Explanation: There are multiple optimal solutions:
- Increment the first element three times to make nums = [4,4,8,13]. 4 has a frequency of 2.
- Increment the second element four times to make nums = [1,8,8,13]. 8 has a frequency of 2.
- Increment the third element five times to make nums = [1,4,13,13]. 13 has a frequency of 2.
Example 3:
Input: nums = [3,9,6], k = 2
Output: 1
","class Solution:
    def maxFrequency(self, nums: List[int], k: int) -> int:
        n=len(nums)
        nums.sort()
        left=0
        right=0
        dist=0
        ans=0
        while right<n:
            if right>0 and nums[right]!=nums[right-1]:
                dist+=(right-left)*(nums[right]-nums[right-1])
            right+=1
            while dist>k:
                dist-=nums[right-1]-nums[left]
                left+=1
            if right-left>ans:
                ans=right-left
        return ans                ",True
Rotating the Box,"You are given an m x n matrix of characters box representing a side-view of a box. Each cell of the box is one of the following:
A stone '#'
A stationary obstacle '*'
Empty '.'
The box is rotated 90 degrees clockwise, causing some of the stones to fall due to gravity. Each stone falls down until it lands on an obstacle, another stone, or the bottom of the box. Gravity does not affect the obstacles' positions, and the inertia from the box's rotation does not affect the stones' horizontal positions.
It is guaranteed that each stone in box rests on an obstacle, another stone, or the bottom of the box.
Return an n x m matrix representing the box after the rotation described above.
","Example 1:

Input: box = [[""#"",""."",""#""]]
Output: [["".""],
         [""#""],
         [""#""]]
Example 2:

Input: box = [[""#"",""."",""*"","".""],
              [""#"",""#"",""*"","".""]]
Output: [[""#"","".""],
         [""#"",""#""],
         [""*"",""*""],
         [""."","".""]]
Example 3:

Input: box = [[""#"",""#"",""*"",""."",""*"","".""],
              [""#"",""#"",""#"",""*"",""."","".""],
              [""#"",""#"",""#"",""."",""#"","".""]]
Output: [[""."",""#"",""#""],
         [""."",""#"",""#""],
         [""#"",""#"",""*""],
         [""#"",""*"","".""],
         [""#"",""."",""*""],
         [""#"",""."","".""]]
","class Solution:
    def rotateTheBox(self, box: List[List[str]]) -> List[List[str]]:
        lst=[]
        for i in box:
            v=[]
            val=""""
            st=""""
            for j in i:
                if j!=""*"":
                    st+=j
                else:
                    st=sorted(st)
                    val+="""".join(st[::-1])
                    val+=""*""
                    st=""""
            if st:
                st=sorted(st)
                val+="""".join(st[::-1])
            for k in val:
                v.append(k)
            lst.append(v)
        lst=lst[::-1]
        ans=[]
        for i in zip(*lst):
            ans.append(i)
        return ans
        

        ",True
Minimum Distance to the Target Element,"Given an integer array nums (0-indexed) and two integers target and start, find an index i such that nums[i] == target and abs(i - start) is minimized. Note that abs(x) is the absolute value of x.
Return abs(i - start).
It is guaranteed that target exists in nums.
","Example 1:
Input: nums = [1,2,3,4,5], target = 5, start = 3
Output: 1
Explanation: nums[4] = 5 is the only value equal to target, so the answer is abs(4 - 3) = 1.
Example 2:
Input: nums = [1], target = 1, start = 0
Output: 0
Explanation: nums[0] = 1 is the only value equal to target, so the answer is abs(0 - 0) = 0.
Example 3:
Input: nums = [1,1,1,1,1,1,1,1,1,1], target = 1, start = 0
Output: 0
Explanation: Every value of nums is 1, but nums[0] minimizes abs(i - start), which is abs(0 - 0) = 0.
","class Solution:
    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:
        ans = inf
        for i, x in enumerate(nums): 
            if x == target: 
                ans = min(ans, abs(i - start))
        return ans ",True
Maximum Population Year,"You are given a 2D integer array logs where each logs[i] = [birthi, deathi] indicates the birth and death years of the ith person.
The population of some year x is the number of people alive during that year. The ith person is counted in year x's population if x is in the inclusive range [birthi, deathi - 1]. Note that the person is not counted in the year that they die.
Return the earliest year with the maximum population.
","Example 1:
Input: logs = [[1993,1999],[2000,2010]]
Output: 1993
Explanation: The maximum population is 1, and 1993 is the earliest year with this population.
Example 2:
Input: logs = [[1950,1961],[1960,1971],[1970,1981]]
Output: 1960
Explanation: 
The maximum population is 2, and it had happened in years 1960 and 1970.
The earlier year between them is 1960.
",,False
Minimize Maximum Pair Sum in Array,"The pair sum of a pair (a,b) is equal to a + b. The maximum pair sum is the largest pair sum in a list of pairs.
For example, if we have pairs (1,5), (2,3), and (4,4), the maximum pair sum would be max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8.
Given an array nums of even length n, pair up the elements of nums into n / 2 pairs such that:
Each element of nums is in exactly one pair, and
The maximum pair sum is minimized.
Return the minimized maximum pair sum after optimally pairing up the elements.
","Example 1:
Input: nums = [3,5,2,3]
Output: 7
Explanation: The elements can be paired up into pairs (3,3) and (5,2).
The maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.
Example 2:
Input: nums = [3,5,4,2,4,6]
Output: 8
Explanation: The elements can be paired up into pairs (3,5), (4,4), and (6,2).
The maximum pair sum is max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8.
","class Solution:
    def minPairSum(self, nums: List[int]) -> int:
        nums.sort()
        return max(map(add, islice(nums, 0, len(nums)//2), reversed(nums)))
        ",True
Sum of All Subset XOR Totals,"The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.
For example, the XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1.
Given an array nums, return the sum of all XOR totals for every subset of nums. 
Note: Subsets with the same elements should be counted multiple times.
An array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b.
","Example 1:
Input: nums = [1,3]
Output: 6
Explanation: The 4 subsets of [1,3] are:
- The empty subset has an XOR total of 0.
- [1] has an XOR total of 1.
- [3] has an XOR total of 3.
- [1,3] has an XOR total of 1 XOR 3 = 2.
0 + 1 + 3 + 2 = 6
Example 2:
Input: nums = [5,1,6]
Output: 28
Explanation: The 8 subsets of [5,1,6] are:
- The empty subset has an XOR total of 0.
- [5] has an XOR total of 5.
- [1] has an XOR total of 1.
- [6] has an XOR total of 6.
- [5,1] has an XOR total of 5 XOR 1 = 4.
- [5,6] has an XOR total of 5 XOR 6 = 3.
- [1,6] has an XOR total of 1 XOR 6 = 7.
- [5,1,6] has an XOR total of 5 XOR 1 XOR 6 = 2.
0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28
Example 3:
Input: nums = [3,4,5,6,7,8]
Output: 480
Explanation: The sum of all XOR totals for every subset is 480.
","class Solution:
    def subsetXORSum(self, nums: List[int]) -> int:
        return (reduce(lambda x, y: x | y, nums)) << (len(nums) - 1)
        ",True
Minimum Speed to Arrive on Time,"You are given a floating-point number hour, representing the amount of time you have to reach the office. To commute to the office, you must take n trains in sequential order. You are also given an integer array dist of length n, where dist[i] describes the distance (in kilometers) of the ith train ride.
Each train can only depart at an integer hour, so you may need to wait in between each train ride.
For example, if the 1st train ride takes 1.5 hours, you must wait for an additional 0.5 hours before you can depart on the 2nd train ride at the 2 hour mark.
Return the minimum positive integer speed (in kilometers per hour) that all the trains must travel at for you to reach the office on time, or -1 if it is impossible to be on time.
Tests are generated such that the answer will not exceed 107 and hour will have at most two digits after the decimal point.
","Example 1:
Input: dist = [1,3,2], hour = 6
Output: 1
Explanation: At speed 1:
- The first train ride takes 1/1 = 1 hour.
- Since we are already at an integer hour, we depart immediately at the 1 hour mark. The second train takes 3/1 = 3 hours.
- Since we are already at an integer hour, we depart immediately at the 4 hour mark. The third train takes 2/1 = 2 hours.
- You will arrive at exactly the 6 hour mark.
Example 2:
Input: dist = [1,3,2], hour = 2.7
Output: 3
Explanation: At speed 3:
- The first train ride takes 1/3 = 0.33333 hours.
- Since we are not at an integer hour, we wait until the 1 hour mark to depart. The second train ride takes 3/3 = 1 hour.
- Since we are already at an integer hour, we depart immediately at the 2 hour mark. The third train takes 2/3 = 0.66667 hours.
- You will arrive at the 2.66667 hour mark.
Example 3:
Input: dist = [1,3,2], hour = 1.9
Output: -1
Explanation: It is impossible because the earliest the third train can depart is at the 2 hour mark.
",,False
Reduction Operations to Make the Array Elements Equal,"Given an integer array nums, your goal is to make all elements in nums equal. To complete one operation, follow these steps:
Find the largest value in nums. Let its index be i (0-indexed) and its value be largest. If there are multiple elements with the largest value, pick the smallest i.
Find the next largest value in nums strictly smaller than largest. Let its value be nextLargest.
Reduce nums[i] to nextLargest.
Return the number of operations to make all elements in nums equal.
","Example 1:
Input: nums = [5,1,3]
Output: 3
Explanation: It takes 3 operations to make all elements in nums equal:
1. largest = 5 at index 0. nextLargest = 3. Reduce nums[0] to 3. nums = [3,1,3].
2. largest = 3 at index 0. nextLargest = 1. Reduce nums[0] to 1. nums = [1,1,3].
3. largest = 3 at index 2. nextLargest = 1. Reduce nums[2] to 1. nums = [1,1,1].
Example 2:
Input: nums = [1,1,1]
Output: 0
Explanation: All elements in nums are already equal.
Example 3:
Input: nums = [1,1,2,2,3]
Output: 4
Explanation: It takes 4 operations to make all elements in nums equal:
1. largest = 3 at index 4. nextLargest = 2. Reduce nums[4] to 2. nums = [1,1,2,2,2].
2. largest = 2 at index 2. nextLargest = 1. Reduce nums[2] to 1. nums = [1,1,1,2,2].
3. largest = 2 at index 3. nextLargest = 1. Reduce nums[3] to 1. nums = [1,1,1,1,2].
4. largest = 2 at index 4. nextLargest = 1. Reduce nums[4] to 1. nums = [1,1,1,1,1].
","class Solution:
    def reductionOperations(self, nums: List[int]) -> int:
        nums.sort()
        ans = 0
        for i in range(len(nums) - 2, -1, -1):
            if nums[i] != nums[i + 1]:
                ans += len(nums) - (i + 1)

        return ans",True
Remove One Element to Make the Array Strictly Increasing,"Given a 0-indexed integer array nums, return true if it can be made strictly increasing after removing exactly one element, or false otherwise. If the array is already strictly increasing, return true.
The array nums is strictly increasing if nums[i - 1] < nums[i] for each index (1 <= i < nums.length).
","Example 1:
Input: nums = [1,2,10,5,7]
Output: true
Explanation: By removing 10 at index 2 from nums, it becomes [1,2,5,7].
[1,2,5,7] is strictly increasing, so return true.
Example 2:
Input: nums = [2,3,1,2]
Output: false
Explanation:
[3,1,2] is the result of removing the element at index 0.
[2,1,2] is the result of removing the element at index 1.
[2,3,2] is the result of removing the element at index 2.
[2,3,1] is the result of removing the element at index 3.
No resulting array is strictly increasing, so return false.
Example 3:
Input: nums = [1,1,1]
Output: false
Explanation: The result of removing any element is [1,1].
[1,1] is not strictly increasing, so return false.
","class Solution:
    def canBeIncreasing(self, nums: List[int]) -> bool:
        prev, seen = -inf, False
        for i, x in enumerate(nums): 
            if prev < x: prev = x
            else: 
                if seen: return False 
                seen = True 
                if i == 1 or nums[i-2] < x: prev = x
        return True ",True
Nearest Exit from Entrance in Maze,"You are given an m x n matrix maze (0-indexed) with empty cells (represented as '.') and walls (represented as '+'). You are also given the entrance of the maze, where entrance = [entrancerow, entrancecol] denotes the row and column of the cell you are initially standing at.
In one step, you can move one cell up, down, left, or right. You cannot step into a cell with a wall, and you cannot step outside the maze. Your goal is to find the nearest exit from the entrance. An exit is defined as an empty cell that is at the border of the maze. The entrance does not count as an exit.
Return the number of steps in the shortest path from the entrance to the nearest exit, or -1 if no such path exists.
","Example 1:

Input: maze = [[""+"",""+"",""."",""+""],[""."",""."",""."",""+""],[""+"",""+"",""+"","".""]], entrance = [1,2]
Output: 1
Explanation: There are 3 exits in this maze at [1,0], [0,2], and [2,3].
Initially, you are at the entrance cell [1,2].
- You can reach [1,0] by moving 2 steps left.
- You can reach [0,2] by moving 1 step up.
It is impossible to reach [2,3] from the entrance.
Thus, the nearest exit is [0,2], which is 1 step away.
Example 2:

Input: maze = [[""+"",""+"",""+""],[""."",""."","".""],[""+"",""+"",""+""]], entrance = [1,0]
Output: 2
Explanation: There is 1 exit in this maze at [1,2].
[1,0] does not count as an exit since it is the entrance cell.
Initially, you are at the entrance cell [1,0].
- You can reach [1,2] by moving 2 steps right.
Thus, the nearest exit is [1,2], which is 2 steps away.
Example 3:

Input: maze = [[""."",""+""]], entrance = [0,0]
Output: -1
Explanation: There are no exits in this maze.
","class Solution {
public:
    int nearestExit(vector<vector<char>>& maze, vector<int>& entrance) {
        int min_path = INT_MAX;
        deque<vector<int>> go_to_lab;
        go_to_lab.push_back({entrance[0], entrance[1], 0});
        maze[entrance[0]][entrance[1]] = '+';
        int size = maze.size() - 1, size1 = maze[0].size() - 1;
        while(!go_to_lab.empty())
        {
            auto el = go_to_lab.front();
            if(el[0] == 0 || el[0] == size || el[1] == 0 || el[1] == size1)
            {
                if(el[0] != entrance[0] || el[1] != entrance[1])
                    return min(min_path, el[2]);
            }
            
            if(el[0] + 1 <= size && maze[el[0] + 1][el[1]] == '.')
            {
                maze[el[0] + 1][el[1]] = '+';
                go_to_lab.push_back({el[0] + 1, el[1], el[2] + 1});
            }
            if(el[0] - 1 >= 0 && maze[el[0] - 1][el[1]] == '.')
            {
                maze[el[0] - 1][el[1]] = '+';
                go_to_lab.push_back({el[0] - 1, el[1], el[2] + 1});
            }
            if(el[1] + 1 <= size1 && maze[el[0]][el[1] + 1] == '.')
            {
                maze[el[0]][el[1] + 1] = '+';
                go_to_lab.push_back({el[0], el[1] + 1, el[2] + 1});
            }
            if(el[1] - 1 >= 0 && maze[el[0]][el[1] - 1] == '.')
            {
                maze[el[0]][el[1] - 1] = '+';
                go_to_lab.push_back({el[0], el[1] - 1, el[2] + 1});
            }
            go_to_lab.pop_front();
        }
        return min_path == INT_MAX ? -1 : min_path;
    }
};",False
Maximum Product Difference Between Two Pairs,"The product difference between two pairs (a, b) and (c, d) is defined as (a * b) - (c * d).
For example, the product difference between (5, 6) and (2, 7) is (5 * 6) - (2 * 7) = 16.
Given an integer array nums, choose four distinct indices w, x, y, and z such that the product difference between pairs (nums[w], nums[x]) and (nums[y], nums[z]) is maximized.
Return the maximum such product difference.
","Example 1:
Input: nums = [5,6,2,7,4]
Output: 34
Explanation: We can choose indices 1 and 3 for the first pair (6, 7) and indices 2 and 4 for the second pair (2, 4).
The product difference is (6 * 7) - (2 * 4) = 34.
Example 2:
Input: nums = [4,2,5,9,7,4,8]
Output: 64
Explanation: We can choose indices 3 and 6 for the first pair (9, 8) and indices 1 and 5 for the second pair (2, 4).
The product difference is (9 * 8) - (2 * 4) = 64.
","class Solution:
    def maxProductDifference(self, nums: List[int]) -> int:
      nums.sort()
      return (nums[-1] * nums[-2]) - (nums[0] * nums[1])",True
Find a Peak Element II,"A peak element in a 2D grid is an element that is strictly greater than all of its adjacent neighbors to the left, right, top, and bottom.
Given a 0-indexed m x n matrix mat where no two adjacent cells are equal, find any peak element mat[i][j] and return the length 2 array [i,j].
You may assume that the entire matrix is surrounded by an outer perimeter with the value -1 in each cell.
You must write an algorithm that runs in O(m log(n)) or O(n log(m)) time.
","Example 1:

Input: mat = [[1,4],[3,2]]
Output: [0,1]
Explanation: Both 3 and 4 are peak elements so [1,0] and [0,1] are both acceptable answers.
Example 2:

Input: mat = [[10,20,15],[21,30,14],[7,16,32]]
Output: [1,1]
Explanation: Both 30 and 32 are peak elements so [1,1] and [2,2] are both acceptable answers.
","class Solution {
public:
    int maxEl(vector<vector<int>>& mat, int n, int m, int col) {
        int maxi = -1;
        int ind = -1;  
        for(int i = 0; i<n; i++) {
            if(mat[i][col]>maxi) {
                maxi = mat[i][col];
                ind = i;
            }
        }
        return ind;
    }
    vector<int> findPeakGrid(vector<vector<int>>& mat) {
        int n = mat.size();
        int m = mat[0].size();
        int low = 0;
        int high = m - 1; 
        while(low<=high) {
            int mid = (low+high)/2;
            int row = maxEl(mat, n, m, mid);
            int left = mid-1>=0 ? mat[row][mid-1] : -1; 
            int right = mid+1<m ? mat[row][mid+1] : -1; 
            if(mat[row][mid]>left && mat[row][mid]>right) return {row, mid};
            else if(mat[row][mid]<left) high = mid-1;
            else low = mid+1;
        }
        return {-1,-1};
    }
};
",False
Build Array from Permutation,"Given a zero-based permutation nums (0-indexed), build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it.
A zero-based permutation nums is an array of distinct integers from 0 to nums.length - 1 (inclusive).
","Example 1:
Input: nums = [0,2,1,5,3,4]
Output: [0,1,2,4,5,3]
Explanation: The array ans is built as follows: 
ans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]
    = [nums[0], nums[2], nums[1], nums[5], nums[3], nums[4]]
    = [0,1,2,4,5,3]
Example 2:
Input: nums = [5,0,1,2,3,4]
Output: [4,5,0,1,2,3]
Explanation: The array ans is built as follows:
ans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]
    = [nums[5], nums[0], nums[1], nums[2], nums[3], nums[4]]
    = [4,5,0,1,2,3]
","class Solution:
    def buildArray(self, nums: List[int]) -> List[int]:
        answer = []
        for i in range(len(nums)):
            answer.append(nums[nums[i]])
        
        return answer",True
Eliminate Maximum Number of Monsters,"You are playing a video game where you are defending your city from a group of n monsters. You are given a 0-indexed integer array dist of size n, where dist[i] is the initial distance in kilometers of the ith monster from the city.
The monsters walk toward the city at a constant speed. The speed of each monster is given to you in an integer array speed of size n, where speed[i] is the speed of the ith monster in kilometers per minute.
You have a weapon that, once fully charged, can eliminate a single monster. However, the weapon takes one minute to charge. The weapon is fully charged at the very start.
You lose when any monster reaches your city. If a monster reaches the city at the exact moment the weapon is fully charged, it counts as a loss, and the game ends before you can use your weapon.
Return the maximum number of monsters that you can eliminate before you lose, or n if you can eliminate all the monsters before they reach the city.
","Example 1:
Input: dist = [1,3,4], speed = [1,1,1]
Output: 3
Explanation:
In the beginning, the distances of the monsters are [1,3,4]. You eliminate the first monster.
After a minute, the distances of the monsters are [X,2,3]. You eliminate the second monster.
After a minute, the distances of the monsters are [X,X,2]. You eliminate the third monster.
All 3 monsters can be eliminated.
Example 2:
Input: dist = [1,1,2,3], speed = [1,1,1,1]
Output: 1
Explanation:
In the beginning, the distances of the monsters are [1,1,2,3]. You eliminate the first monster.
After a minute, the distances of the monsters are [X,0,1,2], so you lose.
You can only eliminate 1 monster.
Example 3:
Input: dist = [3,2,4], speed = [5,3,2]
Output: 1
Explanation:
In the beginning, the distances of the monsters are [3,2,4]. You eliminate the first monster.
After a minute, the distances of the monsters are [X,0,2], so you lose.
You can only eliminate 1 monster.
","class Solution:
    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:
        for a in range(len(dist)) :
            dist[a] = dist[a]/speed[a]
        dist.sort()
        
        if (dist[0] == 0) :
            return 1

        for a in range(1,len(dist)) :
            if (dist[a] <= a) :
                return a

        return len(dist)",True
Concatenation of Array,"Given an integer array nums of length n, you want to create an array ans of length 2n where ans[i] == nums[i] and ans[i + n] == nums[i] for 0 <= i < n (0-indexed).
Specifically, ans is the concatenation of two nums arrays.
Return the array ans.
","Example 1:
Input: nums = [1,2,1]
Output: [1,2,1,1,2,1]
Explanation: The array ans is formed as follows:
- ans = [nums[0],nums[1],nums[2],nums[0],nums[1],nums[2]]
- ans = [1,2,1,1,2,1]
Example 2:
Input: nums = [1,3,2,1]
Output: [1,3,2,1,1,3,2,1]
Explanation: The array ans is formed as follows:
- ans = [nums[0],nums[1],nums[2],nums[3],nums[0],nums[1],nums[2],nums[3]]
- ans = [1,3,2,1,1,3,2,1]
","class Solution {
public:
    vector<int> getConcatenation(vector<int>& nums) {
        vector<int> output(nums);

        for(int i =0 ; i < nums.size(); i++)
        {
            output.push_back(nums[i]);
        }

        return output;
    }
};",False
Check If String Is a Prefix of Array,"Given a string s and an array of strings words, determine whether s is a prefix string of words.
A string s is a prefix string of words if s can be made by concatenating the first k strings in words for some positive k no larger than words.length.
Return true if s is a prefix string of words, or false otherwise.
","Example 1:
Input: s = ""iloveleetcode"", words = [""i"",""love"",""leetcode"",""apples""]
Output: true
Explanation:
s can be made by concatenating ""i"", ""love"", and ""leetcode"" together.
Example 2:
Input: s = ""iloveleetcode"", words = [""apples"",""i"",""love"",""leetcode""]
Output: false
Explanation:
It is impossible to make s using a prefix of arr.
","class Solution:
    def isPrefixString(self, s: str, words: List[str]) -> bool:
        ans = ''
        for i in words:
            ans += i
            if ans == s :
                return True
        return False",True
Remove Stones to Minimize the Total,"You are given a 0-indexed integer array piles, where piles[i] represents the number of stones in the ith pile, and an integer k. You should apply the following operation exactly k times:
Choose any piles[i] and remove floor(piles[i] / 2) stones from it.
Notice that you can apply the operation on the same pile more than once.
Return the minimum possible total number of stones remaining after applying the k operations.
floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down).
","Example 1:
Input: piles = [5,4,9], k = 2
Output: 12
Explanation: Steps of a possible scenario are:
- Apply the operation on pile 2. The resulting piles are [5,4,5].
- Apply the operation on pile 0. The resulting piles are [3,4,5].
The total number of stones in [3,4,5] is 12.
Example 2:
Input: piles = [4,3,6,7], k = 3
Output: 12
Explanation: Steps of a possible scenario are:
- Apply the operation on pile 2. The resulting piles are [4,3,3,7].
- Apply the operation on pile 3. The resulting piles are [4,3,3,4].
- Apply the operation on pile 0. The resulting piles are [2,3,3,4].
The total number of stones in [2,3,3,4] is 12.
",,False
Find the Middle Index in Array,"Given a 0-indexed integer array nums, find the leftmost middleIndex (i.e., the smallest amongst all the possible ones).
A middleIndex is an index where nums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1].
If middleIndex == 0, the left side sum is considered to be 0. Similarly, if middleIndex == nums.length - 1, the right side sum is considered to be 0.
Return the leftmost middleIndex that satisfies the condition, or -1 if there is no such index.
","Example 1:
Input: nums = [2,3,-1,8,4]
Output: 3
Explanation: The sum of the numbers before index 3 is: 2 + 3 + -1 = 4
The sum of the numbers after index 3 is: 4 = 4
Example 2:
Input: nums = [1,-1,4]
Output: 2
Explanation: The sum of the numbers before index 2 is: 1 + -1 = 0
The sum of the numbers after index 2 is: 0
Example 3:
Input: nums = [2,5]
Output: -1
Explanation: There is no valid middleIndex.
","class Solution:
    def findMiddleIndex(self, nums: List[int]) -> int:
        
        # find the sum
        right_sum = sum(nums)
        left_sum = 0
        
        for idx in range(len(nums)):
            
            # subtract current num from right sum
            right_sum -= nums[idx]
            
            # compare the sums
            if right_sum == left_sum:
                return idx
            
            # add current value to left sum
            left_sum += nums[idx]
        return -1",True
Find All Groups of Farmland,"You are given a 0-indexed m x n binary matrix land where a 0 represents a hectare of forested land and a 1 represents a hectare of farmland.
To keep the land organized, there are designated rectangular areas of hectares that consist entirely of farmland. These rectangular areas are called groups. No two groups are adjacent, meaning farmland in one group is not four-directionally adjacent to another farmland in a different group.
land can be represented by a coordinate system where the top left corner of land is (0, 0) and the bottom right corner of land is (m-1, n-1). Find the coordinates of the top left and bottom right corner of each group of farmland. A group of farmland with a top left corner at (r1, c1) and a bottom right corner at (r2, c2) is represented by the 4-length array [r1, c1, r2, c2].
Return a 2D array containing the 4-length arrays described above for each group of farmland in land. If there are no groups of farmland, return an empty array. You may return the answer in any order.
","Example 1:

Input: land = [[1,0,0],[0,1,1],[0,1,1]]
Output: [[0,0,0,0],[1,1,2,2]]
Explanation:
The first group has a top left corner at land[0][0] and a bottom right corner at land[0][0].
The second group has a top left corner at land[1][1] and a bottom right corner at land[2][2].
Example 2:

Input: land = [[1,1],[1,1]]
Output: [[0,0,1,1]]
Explanation:
The first group has a top left corner at land[0][0] and a bottom right corner at land[1][1].
Example 3:

Input: land = [[0]]
Output: []
Explanation:
There are no groups of farmland.
",,False
Find Greatest Common Divisor of Array,"Given an integer array nums, return the greatest common divisor of the smallest number and largest number in nums.
The greatest common divisor of two numbers is the largest positive integer that evenly divides both numbers.
","Example 1:
Input: nums = [2,5,6,9,10]
Output: 2
Explanation:
The smallest number in nums is 2.
The largest number in nums is 10.
The greatest common divisor of 2 and 10 is 2.
Example 2:
Input: nums = [7,5,6,8,3]
Output: 1
Explanation:
The smallest number in nums is 3.
The largest number in nums is 8.
The greatest common divisor of 3 and 8 is 1.
Example 3:
Input: nums = [3,3]
Output: 3
Explanation:
The smallest number in nums is 3.
The largest number in nums is 3.
The greatest common divisor of 3 and 3 is 3.
","class Solution {
    public int findGCD(int[] nums) {
        Arrays.sort(nums);
        int GCD = 1;
        for(int i = 1; i <= nums[0]; i++) {
            if(nums[0] % i == 0 && nums[nums.length - 1] % i == 0) {
                GCD = i;
            }
        }
        return GCD;
    }
}",False
Find Unique Binary String,"Given an array of strings nums containing n unique binary strings each of length n, return a binary string of length n that does not appear in nums. If there are multiple answers, you may return any of them.
","Example 1:
Input: nums = [""01"",""10""]
Output: ""11""
Explanation: ""11"" does not appear in nums. ""00"" would also be correct.
Example 2:
Input: nums = [""00"",""01""]
Output: ""11""
Explanation: ""11"" does not appear in nums. ""10"" would also be correct.
Example 3:
Input: nums = [""111"",""011"",""001""]
Output: ""101""
Explanation: ""101"" does not appear in nums. ""000"", ""010"", ""100"", and ""110"" would also be correct.
","class Solution:
    def findDifferentBinaryString(self, nums: List[str]) -> str:
        ans = []

        for i in range(len(nums)):
            ans.append(str(int(nums[i][i]) ^ 1))

        return ''.join(ans)",True
Minimum Difference Between Highest and Lowest of K Scores,"You are given a 0-indexed integer array nums, where nums[i] represents the score of the ith student. You are also given an integer k.
Pick the scores of any k students from the array so that the difference between the highest and the lowest of the k scores is minimized.
Return the minimum possible difference.
","Example 1:
Input: nums = [90], k = 1
Output: 0
Explanation: There is one way to pick score(s) of one student:
- [90]. The difference between the highest and lowest score is 90 - 90 = 0.
The minimum possible difference is 0.
Example 2:
Input: nums = [9,4,1,7], k = 2
Output: 2
Explanation: There are six ways to pick score(s) of two students:
- [9,4,1,7]. The difference between the highest and lowest score is 9 - 4 = 5.
- [9,4,1,7]. The difference between the highest and lowest score is 9 - 1 = 8.
- [9,4,1,7]. The difference between the highest and lowest score is 9 - 7 = 2.
- [9,4,1,7]. The difference between the highest and lowest score is 4 - 1 = 3.
- [9,4,1,7]. The difference between the highest and lowest score is 7 - 4 = 3.
- [9,4,1,7]. The difference between the highest and lowest score is 7 - 1 = 6.
The minimum possible difference is 2.
","class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        nums = sorted(nums)
        return_diff = float('inf')
        for num in range(len(nums)-k + 1):
            current_diff = nums[num+k-1] - nums[num]
            if current_diff < return_diff:
                return_diff = current_diff

        return return_diff

",True
Find the Kth Largest Integer in the Array,"You are given an array of strings nums and an integer k. Each string in nums represents an integer without leading zeros.
Return the string that represents the kth largest integer in nums.
Note: Duplicate numbers should be counted distinctly. For example, if nums is [""1"",""2"",""2""], ""2"" is the first largest integer, ""2"" is the second-largest integer, and ""1"" is the third-largest integer.
","Example 1:
Input: nums = [""3"",""6"",""7"",""10""], k = 4
Output: ""3""
Explanation:
The numbers in nums sorted in non-decreasing order are [""3"",""6"",""7"",""10""].
The 4th largest integer in nums is ""3"".
Example 2:
Input: nums = [""2"",""21"",""12"",""1""], k = 3
Output: ""2""
Explanation:
The numbers in nums sorted in non-decreasing order are [""1"",""2"",""12"",""21""].
The 3rd largest integer in nums is ""2"".
Example 3:
Input: nums = [""0"",""0""], k = 2
Output: ""0""
Explanation:
The numbers in nums sorted in non-decreasing order are [""0"",""0""].
The 2nd largest integer in nums is ""0"".
",,False
Count Number of Pairs With Absolute Difference K,"Given an integer array nums and an integer k, return the number of pairs (i, j) where i < j such that |nums[i] - nums[j]| == k.
The value of |x| is defined as:
x if x >= 0.
-x if x < 0.
","Example 1:
Input: nums = [1,2,2,1], k = 1
Output: 4
Explanation: The pairs with an absolute difference of 1 are:
- [1,2,2,1]
- [1,2,2,1]
- [1,2,2,1]
- [1,2,2,1]
Example 2:
Input: nums = [1,3], k = 3
Output: 0
Explanation: There are no pairs with an absolute difference of 3.
Example 3:
Input: nums = [3,2,1,5,4], k = 2
Output: 3
Explanation: The pairs with an absolute difference of 2 are:
- [3,2,1,5,4]
- [3,2,1,5,4]
- [3,2,1,5,4]
","class Solution {
public:
    int countKDifference(vector<int>& nums, int k) {
        int n=nums.size();
        int ans=0;
        for(int i=0; i<n-1; i++)
        {
            for(int j=i+1; j<n; j++)
            {
                if(abs(nums[i]-nums[j])==k)
                {
                    ans++;
                }
            }
        }
        return ans;
    }
};",False
Convert 1D Array Into 2D Array,"You are given a 0-indexed 1-dimensional (1D) integer array original, and two integers, m and n. You are tasked with creating a 2-dimensional (2D) array with  m rows and n columns using all the elements from original.
The elements from indices 0 to n - 1 (inclusive) of original should form the first row of the constructed 2D array, the elements from indices n to 2 * n - 1 (inclusive) should form the second row of the constructed 2D array, and so on.
Return an m x n 2D array constructed according to the above procedure, or an empty 2D array if it is impossible.
","Example 1:

Input: original = [1,2,3,4], m = 2, n = 2
Output: [[1,2],[3,4]]
Explanation: The constructed 2D array should contain 2 rows and 2 columns.
The first group of n=2 elements in original, [1,2], becomes the first row in the constructed 2D array.
The second group of n=2 elements in original, [3,4], becomes the second row in the constructed 2D array.
Example 2:
Input: original = [1,2,3], m = 1, n = 3
Output: [[1,2,3]]
Explanation: The constructed 2D array should contain 1 row and 3 columns.
Put all three elements in original into the first row of the constructed 2D array.
Example 3:
Input: original = [1,2], m = 1, n = 1
Output: []
Explanation: There are 2 elements in original.
It is impossible to fit 2 elements in a 1x1 2D array, so return an empty 2D array.
","class Solution:
    def construct2DArray(self, original: List[int], m: int, n: int) -> List[List[int]]:
        if m*n != len(original):
            return []
        
        q = []

        for i in range(0, len(original), n):
            q.append(original[i:i+n])
            
        return q
        ",True
Number of Pairs of Strings With Concatenation Equal to Target,"Given an array of digit strings nums and a digit string target, return the number of pairs of indices (i, j) (where i != j) such that the concatenation of nums[i] + nums[j] equals target.
","Example 1:
Input: nums = [""777"",""7"",""77"",""77""], target = ""7777""
Output: 4
Explanation: Valid pairs are:
- (0, 1): ""777"" + ""7""
- (1, 0): ""7"" + ""777""
- (2, 3): ""77"" + ""77""
- (3, 2): ""77"" + ""77""
Example 2:
Input: nums = [""123"",""4"",""12"",""34""], target = ""1234""
Output: 2
Explanation: Valid pairs are:
- (0, 1): ""123"" + ""4""
- (2, 3): ""12"" + ""34""
Example 3:
Input: nums = [""1"",""1"",""1""], target = ""11""
Output: 6
Explanation: Valid pairs are:
- (0, 1): ""1"" + ""1""
- (1, 0): ""1"" + ""1""
- (0, 2): ""1"" + ""1""
- (2, 0): ""1"" + ""1""
- (1, 2): ""1"" + ""1""
- (2, 1): ""1"" + ""1""
",,False
Final Value of Variable After Performing Operations,"There is a programming language with only four operations and one variable X:
++X and X++ increments the value of the variable X by 1.
--X and X-- decrements the value of the variable X by 1.
Initially, the value of X is 0.
Given an array of strings operations containing a list of operations, return the final value of X after performing all the operations.
","Example 1:
Input: operations = [""--X"",""X++"",""X++""]
Output: 1
Explanation: The operations are performed as follows:
Initially, X = 0.
--X: X is decremented by 1, X =  0 - 1 = -1.
X++: X is incremented by 1, X = -1 + 1 =  0.
X++: X is incremented by 1, X =  0 + 1 =  1.
Example 2:
Input: operations = [""++X"",""++X"",""X++""]
Output: 3
Explanation: The operations are performed as follows:
Initially, X = 0.
++X: X is incremented by 1, X = 0 + 1 = 1.
++X: X is incremented by 1, X = 1 + 1 = 2.
X++: X is incremented by 1, X = 2 + 1 = 3.
Example 3:
Input: operations = [""X++"",""++X"",""--X"",""X--""]
Output: 0
Explanation: The operations are performed as follows:
Initially, X = 0.
X++: X is incremented by 1, X = 0 + 1 = 1.
++X: X is incremented by 1, X = 1 + 1 = 2.
--X: X is decremented by 1, X = 2 - 1 = 1.
X--: X is decremented by 1, X = 1 - 1 = 0.
","class Solution:
    def finalValueAfterOperations(self, operations: List[str]) -> int:
        x=0
        for i in operations:
            if i==""--X"" or i==""X--"":
                x=x-1
            else:
                x=x+1
        return x
        ",True
Detect Squares,"You are given a stream of points on the X-Y plane. Design an algorithm that:
Adds new points from the stream into a data structure. Duplicate points are allowed and should be treated as different points.
Given a query point, counts the number of ways to choose three points from the data structure such that the three points and the query point form an axis-aligned square with positive area.
An axis-aligned square is a square whose edges are all the same length and are either parallel or perpendicular to the x-axis and y-axis.
Implement the DetectSquares class:
DetectSquares() Initializes the object with an empty data structure.
void add(int[] point) Adds a new point point = [x, y] to the data structure.
int count(int[] point) Counts the number of ways to form axis-aligned squares with point point = [x, y] as described above.
","Example 1:

Input
[""DetectSquares"", ""add"", ""add"", ""add"", ""count"", ""count"", ""add"", ""count""]
[[], [[3, 10]], [[11, 2]], [[3, 2]], [[11, 10]], [[14, 8]], [[11, 2]], [[11, 10]]]
Output
[null, null, null, null, 1, 0, null, 2]

Explanation
DetectSquares detectSquares = new DetectSquares();
detectSquares.add([3, 10]);
detectSquares.add([11, 2]);
detectSquares.add([3, 2]);
detectSquares.count([11, 10]); // return 1. You can choose:
                               //   - The first, second, and third points
detectSquares.count([14, 8]);  // return 0. The query point cannot form a square with any points in the data structure.
detectSquares.add([11, 2]);    // Adding duplicate points is allowed.
detectSquares.count([11, 10]); // return 2. You can choose:
                               //   - The first, second, and third points
                               //   - The first, third, and fourth points
",,False
Maximum Difference Between Increasing Elements,"Given a 0-indexed integer array nums of size n, find the maximum difference between nums[i] and nums[j] (i.e., nums[j] - nums[i]), such that 0 <= i < j < n and nums[i] < nums[j].
Return the maximum difference. If no such i and j exists, return -1.
","Example 1:
Input: nums = [7,1,5,4]
Output: 4
Explanation:
The maximum difference occurs with i = 1 and j = 2, nums[j] - nums[i] = 5 - 1 = 4.
Note that with i = 1 and j = 0, the difference nums[j] - nums[i] = 7 - 1 = 6, but i > j, so it is not valid.
Example 2:
Input: nums = [9,4,3,2]
Output: -1
Explanation:
There is no i and j such that i < j and nums[i] < nums[j].
Example 3:
Input: nums = [1,5,2,10]
Output: 9
Explanation:
The maximum difference occurs with i = 0 and j = 3, nums[j] - nums[i] = 10 - 1 = 9.
","class Solution:
    def maximumDifference(self, nums: List[int]) -> int:
        ans = -1 
        prefix = inf
        for i, x in enumerate(nums): 
            if i and x > prefix: ans = max(ans, x - prefix)
            prefix = min(prefix, x)
        return ans ",True
Minimum Number of Moves to Seat Everyone,"There are n seats and n students in a room. You are given an array seats of length n, where seats[i] is the position of the ith seat. You are also given the array students of length n, where students[j] is the position of the jth student.
You may perform the following move any number of times:
Increase or decrease the position of the ith student by 1 (i.e., moving the ith student from position x to x + 1 or x - 1)
Return the minimum number of moves required to move each student to a seat such that no two students are in the same seat.
Note that there may be multiple seats or students in the same position at the beginning.
","Example 1:
Input: seats = [3,1,5], students = [2,7,4]
Output: 4
Explanation: The students are moved as follows:
- The first student is moved from from position 2 to position 1 using 1 move.
- The second student is moved from from position 7 to position 5 using 2 moves.
- The third student is moved from from position 4 to position 3 using 1 move.
In total, 1 + 2 + 1 = 4 moves were used.
Example 2:
Input: seats = [4,1,5,9], students = [1,3,2,6]
Output: 7
Explanation: The students are moved as follows:
- The first student is not moved.
- The second student is moved from from position 3 to position 4 using 1 move.
- The third student is moved from from position 2 to position 5 using 3 moves.
- The fourth student is moved from from position 6 to position 9 using 3 moves.
In total, 0 + 1 + 3 + 3 = 7 moves were used.
Example 3:
Input: seats = [2,2,6,6], students = [1,3,2,6]
Output: 4
Explanation: Note that there are two seats at position 2 and two seats at position 6.
The students are moved as follows:
- The first student is moved from from position 1 to position 2 using 1 move.
- The second student is moved from from position 3 to position 6 using 3 moves.
- The third student is not moved.
- The fourth student is not moved.
In total, 1 + 3 + 0 + 0 = 4 moves were used.
","class Solution {
    public int minMovesToSeat(int[] seats, int[] students) {
        Arrays.sort(students);
        Arrays.sort(seats);
        int sum = 0;
        for(int i = 0; i < seats.length; i++) {
            sum += Math.abs(seats[i] - students[i]);
        }
        return sum;
    }
}",False
Two Out of Three,"nums1
nums2
nums3
a distinct array containing all the values that are present in at least two out of the three arrays. You may return the values in any order
","Example 1:
Input: nums1 = [1,1,3,2], nums2 = [2,3], nums3 = [3]
Output: [3,2]
Explanation: The values that are present in at least two arrays are:
- 3, in all three arrays.
- 2, in nums1 and nums2.
Example 2:
Input: nums1 = [3,1], nums2 = [2,3], nums3 = [1,2]
Output: [2,3,1]
Explanation: The values that are present in at least two arrays are:
- 2, in nums2 and nums3.
- 3, in nums1 and nums2.
- 1, in nums1 and nums3.
Example 3:
Input: nums1 = [1,2,2], nums2 = [4,3,3], nums3 = [5]
Output: []
Explanation: No value is present in at least two arrays.
","class Solution:
    def twoOutOfThree(self, nums1: List[int], nums2: List[int], nums3: List[int]) -> List[int]:
        ret = []

        ret += set(nums1).intersection(set(nums2))
        ret += set(nums1).intersection(set(nums3))
        ret += set(nums2).intersection(set(nums3))

        return set(ret)",True
Kth Distinct String in an Array,"A distinct string is a string that is present only once in an array.
Given an array of strings arr, and an integer k, return the kth distinct string present in arr. If there are fewer than k distinct strings, return an empty string """".
Note that the strings are considered in the order in which they appear in the array.
","Example 1:
Input: arr = [""d"",""b"",""c"",""b"",""c"",""a""], k = 2
Output: ""a""
Explanation:
The only distinct strings in arr are ""d"" and ""a"".
""d"" appears 1st, so it is the 1st distinct string.
""a"" appears 2nd, so it is the 2nd distinct string.
Since k == 2, ""a"" is returned. 
Example 2:
Input: arr = [""aaa"",""aa"",""a""], k = 1
Output: ""aaa""
Explanation:
All strings in arr are distinct, so the 1st string ""aaa"" is returned.
Example 3:
Input: arr = [""a"",""b"",""a""], k = 3
Output: """"
Explanation:
The only distinct string is ""b"". Since there are fewer than 3 distinct strings, we return an empty string """".
","class Solution:
    def kthDistinct(self, arr: List[str], k: int) -> str:
        freq = Counter(arr)
        for x in arr: 
            if freq[x] == 1: k -= 1
            if k == 0: return x
        return """"",True
Plates Between Candles,"There is a long table with a line of plates and candles arranged on top of it. You are given a 0-indexed string s consisting of characters '*' and '|' only, where a '*' represents a plate and a '|' represents a candle.
You are also given a 0-indexed 2D integer array queries where queries[i] = [lefti, righti] denotes the substring s[lefti...righti] (inclusive). For each query, you need to find the number of plates between candles that are in the substring. A plate is considered between candles if there is at least one candle to its left and at least one candle to its right in the substring.
For example, s = ""||**||**|*"", and a query [3, 8] denotes the substring ""*||**|"". The number of plates between candles in this substring is 2, as each of the two plates has at least one candle in the substring to its left and right.
Return an integer array answer where answer[i] is the answer to the ith query.
","Example 1:

Input: s = ""**|**|***|"", queries = [[2,5],[5,9]]
Output: [2,3]
Explanation:
- queries[0] has two plates between candles.
- queries[1] has three plates between candles.
Example 2:

Input: s = ""***|**|*****|**||**|*"", queries = [[1,17],[4,5],[14,17],[5,11],[15,16]]
Output: [9,0,0,0,0]
Explanation:
- queries[0] has nine plates between candles.
- The other queries have zero plates between candles.
",,False
Smallest Index With Equal Value,"Given a 0-indexed integer array nums, return the smallest index i of nums such that i mod 10 == nums[i], or -1 if such index does not exist.
x mod y denotes the remainder when x is divided by y.
","Example 1:
Input: nums = [0,1,2]
Output: 0
Explanation: 
i=0: 0 mod 10 = 0 == nums[0].
i=1: 1 mod 10 = 1 == nums[1].
i=2: 2 mod 10 = 2 == nums[2].
All indices have i mod 10 == nums[i], so we return the smallest index 0.
Example 2:
Input: nums = [4,3,2,1]
Output: 2
Explanation: 
i=0: 0 mod 10 = 0 != nums[0].
i=1: 1 mod 10 = 1 != nums[1].
i=2: 2 mod 10 = 2 == nums[2].
i=3: 3 mod 10 = 3 != nums[3].
2 is the only index which has i mod 10 == nums[i].
Example 3:
Input: nums = [1,2,3,4,5,6,7,8,9,0]
Output: -1
Explanation: No index satisfies i mod 10 == nums[i].
","class Solution:
    def smallestEqual(self, nums: List[int]) -> int:
        for i , num in enumerate(nums):
            if i % 10 == num:
                return i
        return -1
        
",True
Minimum Operations to Convert Number,"You are given a 0-indexed integer array nums containing distinct numbers, an integer start, and an integer goal. There is an integer x that is initially set to start, and you want to perform operations on x such that it is converted to goal. You can perform the following operation repeatedly on the number x:
If 0 <= x <= 1000, then for any index i in the array (0 <= i < nums.length), you can set x to any of the following:
x + nums[i]
x - nums[i]
x ^ nums[i] (bitwise-XOR)
Note that you can use each nums[i] any number of times in any order. Operations that set x to be out of the range 0 <= x <= 1000 are valid, but no more operations can be done afterward.
Return the minimum number of operations needed to convert x = start into goal, and -1 if it is not possible.
","Example 1:
Input: nums = [2,4,12], start = 2, goal = 12
Output: 2
Explanation: We can go from 2 → 14 → 12 with the following 2 operations.
- 2 + 12 = 14
- 14 - 2 = 12
Example 2:
Input: nums = [3,5,7], start = 0, goal = -4
Output: 2
Explanation: We can go from 0 → 3 → -4 with the following 2 operations. 
- 0 + 3 = 3
- 3 - 7 = -4
Note that the last operation sets x out of the range 0 <= x <= 1000, which is valid.
Example 3:
Input: nums = [2,8,16], start = 0, goal = 1
Output: -1
Explanation: There is no way to convert 0 into 1.
","class Solution:
    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:
        s1, s2, d, seen = {start}, {goal}, 0, set()
        while s1 and s2:
            if len(s1) < len(s2):
                s1, s2 = s2, s1
            
            new = set()
            for x in s1:
                for num in nums:
                    if x+num in s2:
                        return d+1
                    if x-num in s2:
                        return d+1
                    if x^num in s2:
                        return d+1
                    
                    if 0 <= x+num <= 1000:
                        if not x+num in seen:
                            seen.add(x+num)
                            new.add(x+num)
                    if 0 <= x-num <= 1000:
                        if not x-num in seen:
                            seen.add(x-num)
                            new.add(x-num)
                    if 0 <= x^num <= 1000:
                        if not x^num in seen:
                            seen.add(x^num)
                            new.add(x^num)
            d += 1
            s1 = new
        return -1",True
Count Common Words With One Occurrence,"Given two string arrays words1 and words2, return the number of strings that appear exactly once in each of the two arrays.
","Example 1:
Input: words1 = [""leetcode"",""is"",""amazing"",""as"",""is""], words2 = [""amazing"",""leetcode"",""is""]
Output: 2
Explanation:
- ""leetcode"" appears exactly once in each of the two arrays. We count this string.
- ""amazing"" appears exactly once in each of the two arrays. We count this string.
- ""is"" appears in each of the two arrays, but there are 2 occurrences of it in words1. We do not count this string.
- ""as"" appears once in words1, but does not appear in words2. We do not count this string.
Thus, there are 2 strings that appear exactly once in each of the two arrays.
Example 2:
Input: words1 = [""b"",""bb"",""bbb""], words2 = [""a"",""aa"",""aaa""]
Output: 0
Explanation: There are no strings that appear in each of the two arrays.
Example 3:
Input: words1 = [""a"",""ab""], words2 = [""a"",""a"",""a"",""ab""]
Output: 1
Explanation: The only string that appears exactly once in each of the two arrays is ""ab"".
","class Solution:
    def countWords(self, words1: List[str], words2: List[str]) -> int:
        count=0

        for i in words1:
            if words1.count(i)==1 and words2.count(i)==1:
                count=count+1

        return count",True
Time Needed to Buy Tickets,"There are n people in a line queuing to buy tickets, where the 0th person is at the front of the line and the (n - 1)th person is at the back of the line.
You are given a 0-indexed integer array tickets of length n where the number of tickets that the ith person would like to buy is tickets[i].
Each person takes exactly 1 second to buy a ticket. A person can only buy 1 ticket at a time and has to go back to the end of the line (which happens instantaneously) in order to buy more tickets. If a person does not have any tickets left to buy, the person will leave the line.
Return the time taken for the person at position k (0-indexed) to finish buying tickets.
","Example 1:
Input: tickets = [2,3,2], k = 2
Output: 6
Explanation: 
- In the first pass, everyone in the line buys a ticket and the line becomes [1, 2, 1].
- In the second pass, everyone in the line buys a ticket and the line becomes [0, 1, 0].
The person at position 2 has successfully bought 2 tickets and it took 3 + 3 = 6 seconds.
Example 2:
Input: tickets = [5,1,1,1], k = 0
Output: 8
Explanation:
- In the first pass, everyone in the line buys a ticket and the line becomes [4, 0, 0, 0].
- In the next 4 passes, only the person in position 0 is buying tickets.
The person at position 0 has successfully bought 5 tickets and it took 4 + 1 + 1 + 1 + 1 = 8 seconds.
","class Solution:
    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:
        total = 0

        for i, x in enumerate(tickets):
            if i <= k:
                total += min(tickets[i], tickets[k])
            else:
                total += min(tickets[i], tickets[k] - 1)

        return total",True
Find Subsequence of Length K With the Largest Sum,"You are given an integer array nums and an integer k. You want to find a subsequence of nums of length k that has the largest sum.
Return any such subsequence as an integer array of length k.
A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.
","Example 1:
Input: nums = [2,1,3,3], k = 2
Output: [3,3]
Explanation:
The subsequence has the largest sum of 3 + 3 = 6.
Example 2:
Input: nums = [-1,-2,3,4], k = 3
Output: [-1,3,4]
Explanation: 
The subsequence has the largest sum of -1 + 3 + 4 = 6.
Example 3:
Input: nums = [3,4,3,3], k = 2
Output: [3,4]
Explanation:
The subsequence has the largest sum of 3 + 4 = 7. 
Another possible subsequence is [4, 3].
","class Solution:
    def maxSubsequence(self, nums: List[int], k: int) -> List[int]:
        tuple_heap = [] # Stores (value, index) as min heap
        for i, val in enumerate(nums):
            if len(tuple_heap) == k:
                heappushpop(tuple_heap, (val, i)) # To prevent size of heap growing larger than k
            else:
                heappush(tuple_heap, (val, i))
		# heap now contains only the k largest elements with their indices as well.
        tuple_heap.sort(key=lambda x: x[1]) # To get the original order of values. That is why we sort it by index(x[1]) & not value(x[0])
        ans = []
        for i in tuple_heap:
            ans.append(i[0])
        return ans",True
Detonate the Maximum Bombs,"You are given a list of bombs. The range of a bomb is defined as the area where its effect can be felt. This area is in the shape of a circle with the center as the location of the bomb.
The bombs are represented by a 0-indexed 2D integer array bombs where bombs[i] = [xi, yi, ri]. xi and yi denote the X-coordinate and Y-coordinate of the location of the ith bomb, whereas ri denotes the radius of its range.
You may choose to detonate a single bomb. When a bomb is detonated, it will detonate all bombs that lie in its range. These bombs will further detonate the bombs that lie in their ranges.
Given the list of bombs, return the maximum number of bombs that can be detonated if you are allowed to detonate only one bomb.
","Example 1:

Input: bombs = [[2,1,3],[6,1,4]]
Output: 2
Explanation:
The above figure shows the positions and ranges of the 2 bombs.
If we detonate the left bomb, the right bomb will not be affected.
But if we detonate the right bomb, both bombs will be detonated.
So the maximum bombs that can be detonated is max(1, 2) = 2.
Example 2:

Input: bombs = [[1,1,5],[10,10,5]]
Output: 1
Explanation:
Detonating either bomb will not detonate the other bomb, so the maximum number of bombs that can be detonated is 1.
Example 3:

Input: bombs = [[1,2,3],[2,3,1],[3,4,2],[4,5,3],[5,6,4]]
Output: 5
Explanation:
The best bomb to detonate is bomb 0 because:
- Bomb 0 detonates bombs 1 and 2. The red circle denotes the range of bomb 0.
- Bomb 2 detonates bomb 3. The blue circle denotes the range of bomb 2.
- Bomb 3 detonates bomb 4. The green circle denotes the range of bomb 3.
Thus all 5 bombs are detonated.
","class Solution:
    def maximumDetonation(self, bombs: List[List[int]]) -> int:
        n=len(bombs)
        connected=[ [] for i in range(n)]

        for i in range(n):
            sm=[]
            for j in range(n):
                if j!=i:
                    xi, yi, ri = bombs[i]
                    xj, yj, _ = bombs[j]
                    if ri ** 2 >= (xi - xj) ** 2 + (yi - yj) ** 2:
                        sm.append(j)
            connected[i]=sm
        
        res=[]

        visited=[]
        def dfs(i:int):

            if i not in visited:
                visited.append(i)
                for j in connected[i]:
                    dfs(j)
                

        for i in range(n):
            visited.append(i)
            for j in connected[i]:
                dfs(j)
            res.append(len(visited))
            visited.clear()

        return max(res)
        
 ",True
Find Target Indices After Sorting Array,"You are given a 0-indexed integer array nums and a target element target.
A target index is an index i such that nums[i] == target.
Return a list of the target indices of nums after sorting nums in non-decreasing order. If there are no target indices, return an empty list. The returned list must be sorted in increasing order.
","Example 1:
Input: nums = [1,2,5,2,3], target = 2
Output: [1,2]
Explanation: After sorting, nums is [1,2,2,3,5].
The indices where nums[i] == 2 are 1 and 2.
Example 2:
Input: nums = [1,2,5,2,3], target = 3
Output: [3]
Explanation: After sorting, nums is [1,2,2,3,5].
The index where nums[i] == 3 is 3.
Example 3:
Input: nums = [1,2,5,2,3], target = 5
Output: [4]
Explanation: After sorting, nums is [1,2,2,3,5].
The index where nums[i] == 5 is 4.
","class Solution:
    def targetIndices(self, nums, target):
        idx = sum(num < target  for num in nums)
        cnt = sum(num == target for num in nums)
        return list(range(idx, idx+cnt))",True
K Radius Subarray Averages,"You are given a 0-indexed array nums of n integers, and an integer k.
The k-radius average for a subarray of nums centered at some index i with the radius k is the average of all elements in nums between the indices i - k and i + k (inclusive). If there are less than k elements before or after the index i, then the k-radius average is -1.
Build and return an array avgs of length n where avgs[i] is the k-radius average for the subarray centered at index i.
The average of x elements is the sum of the x elements divided by x, using integer division. The integer division truncates toward zero, which means losing its fractional part.
For example, the average of four elements 2, 3, 1, and 5 is (2 + 3 + 1 + 5) / 4 = 11 / 4 = 2.75, which truncates to 2.
","Example 1:

Input: nums = [7,4,3,9,1,8,5,2,6], k = 3
Output: [-1,-1,-1,5,4,4,-1,-1,-1]
Explanation:
- avg[0], avg[1], and avg[2] are -1 because there are less than k elements before each index.
- The sum of the subarray centered at index 3 with radius 3 is: 7 + 4 + 3 + 9 + 1 + 8 + 5 = 37.
  Using integer division, avg[3] = 37 / 7 = 5.
- For the subarray centered at index 4, avg[4] = (4 + 3 + 9 + 1 + 8 + 5 + 2) / 7 = 4.
- For the subarray centered at index 5, avg[5] = (3 + 9 + 1 + 8 + 5 + 2 + 6) / 7 = 4.
- avg[6], avg[7], and avg[8] are -1 because there are less than k elements after each index.
Example 2:
Input: nums = [100000], k = 0
Output: [100000]
Explanation:
- The sum of the subarray centered at index 0 with radius 0 is: 100000.
  avg[0] = 100000 / 1 = 100000.
Example 3:
Input: nums = [8], k = 100000
Output: [-1]
Explanation: 
- avg[0] is -1 because there are less than k elements before and after index 0.
","class Solution {
public:
    vector<int> getAverages(vector<int>& nums, int k) {
        int n = nums.size(),i;
        long long int s=0;
        vector<int> ans(n,-1);
        for(i=0;i<n;i++){
            if(i<2*k){
                s+= nums[i];
            }else{
                s+=nums[i];
                ans[i-k] = s/(2*k+1);
                s -= nums[i-(2*k)];
            }
        }
        return ans;
    }
};",False
Maximum Number of Words Found in Sentences,"A sentence is a list of words that are separated by a single space with no leading or trailing spaces.
You are given an array of strings sentences, where each sentences[i] represents a single sentence.
Return the maximum number of words that appear in a single sentence.
","Example 1:
Input: sentences = [""alice and bob love leetcode"", ""i think so too"", ""this is great thanks very much""]
Output: 6
Explanation: 
- The first sentence, ""alice and bob love leetcode"", has 5 words in total.
- The second sentence, ""i think so too"", has 4 words in total.
- The third sentence, ""this is great thanks very much"", has 6 words in total.
Thus, the maximum number of words in a single sentence comes from the third sentence, which has 6 words.
Example 2:
Input: sentences = [""please wait"", ""continue to fight"", ""continue to win""]
Output: 3
Explanation: It is possible that multiple sentences contain the same number of words. 
In this example, the second and third sentences (underlined) have the same number of words.
","class Solution:
    def mostWordsFound(self, sentences: List[str]) -> int:
        a=[]
        for i in sentences:
            count=0
            for j in i:
                if(j=="" ""):
                    count+=1
            count+=1
            a.append(count)
        return (max(a))
            ",True
Find All Possible Recipes from Given Supplies,"You have information about n different recipes. You are given a string array recipes and a 2D string array ingredients. The ith recipe has the name recipes[i], and you can create it if you have all the needed ingredients from ingredients[i]. Ingredients to a recipe may need to be created from other recipes, i.e., ingredients[i] may contain a string that is in recipes.
You are also given a string array supplies containing all the ingredients that you initially have, and you have an infinite supply of all of them.
Return a list of all the recipes that you can create. You may return the answer in any order.
Note that two recipes may contain each other in their ingredients.
","Example 1:
Input: recipes = [""bread""], ingredients = [[""yeast"",""flour""]], supplies = [""yeast"",""flour"",""corn""]
Output: [""bread""]
Explanation:
We can create ""bread"" since we have the ingredients ""yeast"" and ""flour"".
Example 2:
Input: recipes = [""bread"",""sandwich""], ingredients = [[""yeast"",""flour""],[""bread"",""meat""]], supplies = [""yeast"",""flour"",""meat""]
Output: [""bread"",""sandwich""]
Explanation:
We can create ""bread"" since we have the ingredients ""yeast"" and ""flour"".
We can create ""sandwich"" since we have the ingredient ""meat"" and can create the ingredient ""bread"".
Example 3:
Input: recipes = [""bread"",""sandwich"",""burger""], ingredients = [[""yeast"",""flour""],[""bread"",""meat""],[""sandwich"",""meat"",""bread""]], supplies = [""yeast"",""flour"",""meat""]
Output: [""bread"",""sandwich"",""burger""]
Explanation:
We can create ""bread"" since we have the ingredients ""yeast"" and ""flour"".
We can create ""sandwich"" since we have the ingredient ""meat"" and can create the ingredient ""bread"".
We can create ""burger"" since we have the ingredient ""meat"" and can create the ingredients ""bread"" and ""sandwich"".
","class Solution:
    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:
        # indegree = {""bread"" : 2}
        indegree = defaultdict(int)
        # graph = {""flour"" : [""bread"", "" "", """"]}
        graph = defaultdict(list)
        for recipe, ing in zip(recipes, ingredients):
            for i in ing:
                indegree[recipe] += 1
                graph[i].append(recipe)
        
        answer = []
        queue = deque(supplies)
        recipes = set(recipes)
        while queue:
            x = queue.popleft()
            if x in recipes:
                answer.append(x)
            for i in graph[x]:
                indegree[i] -= 1
                if indegree[i] == 0:
                    queue.append(i)
        return answer",True
Find First Palindromic String in the Array,"Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string """".
A string is palindromic if it reads the same forward and backward.
","Example 1:
Input: words = [""abc"",""car"",""ada"",""racecar"",""cool""]
Output: ""ada""
Explanation: The first string that is palindromic is ""ada"".
Note that ""racecar"" is also palindromic, but it is not the first.
Example 2:
Input: words = [""notapalindrome"",""racecar""]
Output: ""racecar""
Explanation: The first and only string that is palindromic is ""racecar"".
Example 3:
Input: words = [""def"",""ghi""]
Output: """"
Explanation: There are no palindromic strings, so the empty string is returned.
",,False
Adding Spaces to a String,"You are given a 0-indexed string s and a 0-indexed integer array spaces that describes the indices in the original string where spaces will be added. Each space should be inserted before the character at the given index.
For example, given s = ""EnjoyYourCoffee"" and spaces = [5, 9], we place spaces before 'Y' and 'C', which are at indices 5 and 9 respectively. Thus, we obtain ""Enjoy Your Coffee"".
Return the modified string after the spaces have been added.
","Example 1:
Input: s = ""LeetcodeHelpsMeLearn"", spaces = [8,13,15]
Output: ""Leetcode Helps Me Learn""
Explanation: 
The indices 8, 13, and 15 correspond to the underlined characters in ""LeetcodeHelpsMeLearn"".
We then place spaces before those characters.
Example 2:
Input: s = ""icodeinpython"", spaces = [1,5,7,9]
Output: ""i code in py thon""
Explanation:
The indices 1, 5, 7, and 9 correspond to the underlined characters in ""icodeinpython"".
We then place spaces before those characters.
Example 3:
Input: s = ""spacing"", spaces = [0,1,2,3,4,5,6]
Output: "" s p a c i n g""
Explanation:
We are also able to place spaces before the first character of the string.
","class Solution:
    def addSpaces(self, s: str, spaces: List[int]) -> str:
        
        arr = []
        prev = 0
        for space in spaces:
            arr.append(s[prev:space])
            prev = space
        arr.append(s[space:])
       
        return "" "".join(arr)",True
Number of Laser Beams in a Bank,"Anti-theft security devices are activated inside a bank. You are given a 0-indexed binary string array bank representing the floor plan of the bank, which is an m x n 2D matrix. bank[i] represents the ith row, consisting of '0's and '1's. '0' means the cell is empty, while'1' means the cell has a security device.
There is one laser beam between any two security devices if both conditions are met:
The two devices are located on two different rows: r1 and r2, where r1 < r2.
For each row i where r1 < i < r2, there are no security devices in the ith row.
Laser beams are independent, i.e., one beam does not interfere nor join with another.
Return the total number of laser beams in the bank.
","Example 1:

Input: bank = [""011001"",""000000"",""010100"",""001000""]
Output: 8
Explanation: Between each of the following device pairs, there is one beam. In total, there are 8 beams:
 * bank[0][1] -- bank[2][1]
 * bank[0][1] -- bank[2][3]
 * bank[0][2] -- bank[2][1]
 * bank[0][2] -- bank[2][3]
 * bank[0][5] -- bank[2][1]
 * bank[0][5] -- bank[2][3]
 * bank[2][1] -- bank[3][2]
 * bank[2][3] -- bank[3][2]
Note that there is no beam between any device on the 0th row with any on the 3rd row.
This is because the 2nd row contains security devices, which breaks the second condition.
Example 2:

Input: bank = [""000"",""111"",""000""]
Output: 0
Explanation: There does not exist two devices located on two different rows.
","class Solution {
public:
    int numberOfBeams(vector<string>& bank) {
        vector<int>beams;
        for(auto i:bank){
            int sum=0;
            for(auto j:i)
                sum+=j-'0';
            if(sum)
                beams.push_back(sum);
        }    
        int n=beams.size();
        if(n<2) 
            return 0;
        int prev=beams[0];
        int ans=0;
        for(int i=1;i<n;i++){
            ans+=prev*beams[i];
            prev=beams[i];
        }
        return ans;
    }
};",False
Check if Every Row and Column Contains All Numbers,"An n x n matrix is valid if every row and every column contains all the integers from 1 to n (inclusive).
Given an n x n integer matrix matrix, return true if the matrix is valid. Otherwise, return false.
","Example 1:

Input: matrix = [[1,2,3],[3,1,2],[2,3,1]]
Output: true
Explanation: In this case, n = 3, and every row and column contains the numbers 1, 2, and 3.
Hence, we return true.
Example 2:

Input: matrix = [[1,1,1],[1,2,3],[1,2,3]]
Output: false
Explanation: In this case, n = 3, but the first row and the first column do not contain the numbers 2 or 3.
Hence, we return false.
","class Solution:
    def checkValid(self, matrix: List[List[int]]) -> bool:
        for r in range(len(matrix)):
            colSet = set()
            rowSet = set()
            for c in range(len(matrix)):
                if matrix[r][c] in colSet or matrix[c][r] in rowSet:
                    return False
                colSet.add(matrix[r][c])
                rowSet.add(matrix[c][r])
            
        return True",True
Solving Questions With Brainpower,"You are given a 0-indexed 2D integer array questions where questions[i] = [pointsi, brainpoweri].
The array describes the questions of an exam, where you have to process the questions in order (i.e., starting from question 0) and make a decision whether to solve or skip each question. Solving question i will earn you pointsi points but you will be unable to solve each of the next brainpoweri questions. If you skip question i, you get to make the decision on the next question.
For example, given questions = [[3, 2], [4, 3], [4, 4], [2, 5]]:
If question 0 is solved, you will earn 3 points but you will be unable to solve questions 1 and 2.
If instead, question 0 is skipped and question 1 is solved, you will earn 4 points but you will be unable to solve questions 2 and 3.
Return the maximum points you can earn for the exam.
","Example 1:
Input: questions = [[3,2],[4,3],[4,4],[2,5]]
Output: 5
Explanation: The maximum points can be earned by solving questions 0 and 3.
- Solve question 0: Earn 3 points, will be unable to solve the next 2 questions
- Unable to solve questions 1 and 2
- Solve question 3: Earn 2 points
Total points earned: 3 + 2 = 5. There is no other way to earn 5 or more points.
Example 2:
Input: questions = [[1,1],[2,2],[3,3],[4,4],[5,5]]
Output: 7
Explanation: The maximum points can be earned by solving questions 1 and 4.
- Skip question 0
- Solve question 1: Earn 2 points, will be unable to solve the next 2 questions
- Unable to solve questions 2 and 3
- Solve question 4: Earn 5 points
Total points earned: 2 + 5 = 7. There is no other way to earn 7 or more points.
","class Solution:
    def mostPoints(self, q: List[List[int]]) -> int:
        @cache
        def dfs(i: int) -> int:
            return 0 if i >= len(q) else max(dfs(i + 1), q[i][0] + dfs(i + 1 + q[i][1]))
        return dfs(0)",True
Partition Array According to Given Pivot,"You are given a 0-indexed integer array nums and an integer pivot. Rearrange nums such that the following conditions are satisfied:
Every element less than pivot appears before every element greater than pivot.
Every element equal to pivot appears in between the elements less than and greater than pivot.
The relative order of the elements less than pivot and the elements greater than pivot is maintained.
More formally, consider every pi, pj where pi is the new position of the ith element and pj is the new position of the jth element. For elements less than pivot, if i < j and nums[i] < pivot and nums[j] < pivot, then pi < pj. Similarly for elements greater than pivot, if i < j and nums[i] > pivot and nums[j] > pivot, then pi < pj.
Return nums after the rearrangement.
","Example 1:
Input: nums = [9,12,5,10,14,3,10], pivot = 10
Output: [9,5,3,10,10,12,14]
Explanation: 
The elements 9, 5, and 3 are less than the pivot so they are on the left side of the array.
The elements 12 and 14 are greater than the pivot so they are on the right side of the array.
The relative ordering of the elements less than and greater than pivot is also maintained. [9, 5, 3] and [12, 14] are the respective orderings.
Example 2:
Input: nums = [-3,4,3,2], pivot = 2
Output: [-3,2,4,3]
Explanation: 
The element -3 is less than the pivot so it is on the left side of the array.
The elements 4 and 3 are greater than the pivot so they are on the right side of the array.
The relative ordering of the elements less than and greater than pivot is also maintained. [-3] and [4, 3] are the respective orderings.
","class Solution:
    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:
        lst,val,tmp=[],[],[]
        for i in nums:
            if i==pivot:val.append(i)
            elif i<pivot:lst.append(i)
            else:tmp.append(i)
        return lst+val+tmp",True
Count Elements With Strictly Smaller and Greater Elements ,"Given an integer array nums, return the number of elements that have both a strictly smaller and a strictly greater element appear in nums.
","Example 1:
Input: nums = [11,7,2,15]
Output: 2
Explanation: The element 7 has the element 2 strictly smaller than it and the element 11 strictly greater than it.
Element 11 has element 7 strictly smaller than it and element 15 strictly greater than it.
In total there are 2 elements having both a strictly smaller and a strictly greater element appear in nums.
Example 2:
Input: nums = [-3,3,3,90]
Output: 2
Explanation: The element 3 has the element -3 strictly smaller than it and the element 90 strictly greater than it.
Since there are two elements with the value 3, in total there are 2 elements having both a strictly smaller and a strictly greater element appear in nums.
","class Solution:
    def countElements(self, nums: List[int]) -> int:
        maxval=max(nums)
        minval=min(nums)
        while maxval in nums:
            nums.remove(maxval)
        while minval in nums:
            nums.remove(minval)
        return len(nums)
        #please do upvote it would be encouraging to post more solutions.
",True
Rearrange Array Elements by Sign,"You are given a 0-indexed integer array nums of even length consisting of an equal number of positive and negative integers.
You should return the array of nums such that the the array follows the given conditions:
Every consecutive pair of integers have opposite signs.
For all integers with the same sign, the order in which they were present in nums is preserved.
The rearranged array begins with a positive integer.
Return the modified array after rearranging the elements to satisfy the aforementioned conditions.
","Example 1:
Input: nums = [3,1,-2,-5,2,-4]
Output: [3,-2,1,-5,2,-4]
Explanation:
The positive integers in nums are [3,1,2]. The negative integers are [-2,-5,-4].
The only possible way to rearrange them such that they satisfy all conditions is [3,-2,1,-5,2,-4].
Other ways such as [1,-2,2,-5,3,-4], [3,1,2,-2,-5,-4], [-2,3,-5,1,-4,2] are incorrect because they do not satisfy one or more conditions.  
Example 2:
Input: nums = [-1,1]
Output: [1,-1]
Explanation:
1 is the only positive integer and -1 the only negative integer in nums.
So nums is rearranged to [1,-1].
","class Solution:
    def rearrangeArray(self, nums: List[int]) -> List[int]:
        pos, neg = [], []

        for n in nums:
            if n > 0:
                pos.append(n)
            else:
                neg.append(n)
        
        res = [0] * len(nums)
        res[0 : len(pos) * 2 : 2] = pos
        res[1 : len(neg) * 2 : 2] = neg

        return res",True
Keep Multiplying Found Values by Two,"You are given an array of integers nums. You are also given an integer original which is the first number that needs to be searched for in nums.
You then do the following steps:
If original is found in nums, multiply it by two (i.e., set original = 2 * original).
Otherwise, stop the process.
Repeat this process with the new number as long as you keep finding the number.
Return the final value of original.
","Example 1:
Input: nums = [5,3,6,1,12], original = 3
Output: 24
Explanation: 
- 3 is found in nums. 3 is multiplied by 2 to obtain 6.
- 6 is found in nums. 6 is multiplied by 2 to obtain 12.
- 12 is found in nums. 12 is multiplied by 2 to obtain 24.
- 24 is not found in nums. Thus, 24 is returned.
Example 2:
Input: nums = [2,7,9], original = 4
Output: 4
Explanation:
- 4 is not found in nums. Thus, 4 is returned.
",,False
Count Equal and Divisible Pairs in an Array,"0-indexed
nums
n
k
the number of pairs
(i, j)
where
0 <= i < j < n
such that
nums[i] == nums[j]
and
(i * j)
is divisible by
k
","Example 1:
Input: nums = [3,1,2,2,2,1,3], k = 2
Output: 4
Explanation:
There are 4 pairs that meet all the requirements:
- nums[0] == nums[6], and 0 * 6 == 0, which is divisible by 2.
- nums[2] == nums[3], and 2 * 3 == 6, which is divisible by 2.
- nums[2] == nums[4], and 2 * 4 == 8, which is divisible by 2.
- nums[3] == nums[4], and 3 * 4 == 12, which is divisible by 2.
Example 2:
Input: nums = [1,2,3,4], k = 1
Output: 0
Explanation: Since no value in nums is repeated, there are no pairs (i,j) that meet all the requirements.
","class Solution:
    def countPairs(self, nums: List[int], k: int) -> int:
        c=0
        for i in range(len(nums)):
            for j in range(i+1,len(nums)):
                if nums[i]==nums[j] and (i*j)%k==0:
                    c+=1
        return c",True
Sort Even and Odd Indices Independently,"You are given a 0-indexed integer array nums. Rearrange the values of nums according to the following rules:
Sort the values at odd indices of nums in non-increasing order.
For example, if nums = [4,1,2,3] before this step, it becomes [4,3,2,1] after. The values at odd indices 1 and 3 are sorted in non-increasing order.
Sort the values at even indices of nums in non-decreasing order.
For example, if nums = [4,1,2,3] before this step, it becomes [2,1,4,3] after. The values at even indices 0 and 2 are sorted in non-decreasing order.
Return the array formed after rearranging the values of nums.
","Example 1:
Input: nums = [4,1,2,3]
Output: [2,3,4,1]
Explanation: 
First, we sort the values present at odd indices (1 and 3) in non-increasing order.
So, nums changes from [4,1,2,3] to [4,3,2,1].
Next, we sort the values present at even indices (0 and 2) in non-decreasing order.
So, nums changes from [4,1,2,3] to [2,3,4,1].
Thus, the array formed after rearranging the values is [2,3,4,1].
Example 2:
Input: nums = [2,1]
Output: [2,1]
Explanation: 
Since there is exactly one odd index and one even index, no rearrangement of values takes place.
The resultant array formed is [2,1], which is the same as the initial array. 
",,False
Counting Words With a Given Prefix,"You are given an array of strings words and a string pref.
Return the number of strings in words that contain pref as a prefix.
A prefix of a string s is any leading contiguous substring of s.
","Example 1:
Input: words = [""pay"",""attention"",""practice"",""attend""], pref = ""at""
Output: 2
Explanation: The 2 strings that contain ""at"" as a prefix are: ""attention"" and ""attend"".
Example 2:
Input: words = [""leetcode"",""win"",""loops"",""success""], pref = ""code""
Output: 0
Explanation: There are no strings that contain ""code"" as a prefix.
",,False
Minimum Time to Complete Trips,"You are given an array time where time[i] denotes the time taken by the ith bus to complete one trip.
Each bus can make multiple trips successively; that is, the next trip can start immediately after completing the current trip. Also, each bus operates independently; that is, the trips of one bus do not influence the trips of any other bus.
You are also given an integer totalTrips, which denotes the number of trips all buses should make in total. Return the minimum time required for all buses to complete at least totalTrips trips.
","Example 1:
Input: time = [1,2,3], totalTrips = 5
Output: 3
Explanation:
- At time t = 1, the number of trips completed by each bus are [1,0,0]. 
  The total number of trips completed is 1 + 0 + 0 = 1.
- At time t = 2, the number of trips completed by each bus are [2,1,0]. 
  The total number of trips completed is 2 + 1 + 0 = 3.
- At time t = 3, the number of trips completed by each bus are [3,1,1]. 
  The total number of trips completed is 3 + 1 + 1 = 5.
So the minimum time needed for all buses to complete at least 5 trips is 3.
Example 2:
Input: time = [2], totalTrips = 1
Output: 2
Explanation:
There is only one bus, and it will complete its first trip at t = 2.
So the minimum time needed to complete 1 trip is 2.
","class Solution:
    def minimumTime(self, time: List[int], totalTrips: int) -> int:
        #binary search
        def checkIfTotalTripsCanHappen(timee):
            trips=0
            for i in time:
                trips+=(timee//i)
            return trips>=totalTrips
        #print(checkIfTotalTripsCanHappen(3))
        #print(checkIfTotalTripsCanHappen(2))
        #print(checkIfTotalTripsCanHappen(4))

        left=1
        right=max(time)*totalTrips
        while(left<right):
            mid=left+(right-left)//2
            if(checkIfTotalTripsCanHappen(mid)):
                right=mid
            else:
                left=mid+1
        return left",True
Divide Array Into Equal Pairs,"You are given an integer array nums consisting of 2 * n integers.
You need to divide nums into n pairs such that:
Each element belongs to exactly one pair.
The elements present in a pair are equal.
Return true if nums can be divided into n pairs, otherwise return false.
","Example 1:
Input: nums = [3,2,3,2,2,2]
Output: true
Explanation: 
There are 6 elements in nums, so they should be divided into 6 / 2 = 3 pairs.
If nums is divided into the pairs (2, 2), (3, 3), and (2, 2), it will satisfy all the conditions.
Example 2:
Input: nums = [1,2,3,4]
Output: false
Explanation: 
There is no way to divide nums into 4 / 2 = 2 pairs such that the pairs satisfy every condition.
",,False
Most Frequent Number Following Key In an Array,"You are given a 0-indexed integer array nums. You are also given an integer key, which is present in nums.
For every unique integer target in nums, count the number of times target immediately follows an occurrence of key in nums. In other words, count the number of indices i such that:
0 <= i <= nums.length - 2,
nums[i] == key and,
nums[i + 1] == target.
Return the target with the maximum count. The test cases will be generated such that the target with maximum count is unique.
","Example 1:
Input: nums = [1,100,200,1,100], key = 1
Output: 100
Explanation: For target = 100, there are 2 occurrences at indices 1 and 4 which follow an occurrence of key.
No other integers follow an occurrence of key, so we return 100.
Example 2:
Input: nums = [2,2,2,2,3], key = 2
Output: 2
Explanation: For target = 2, there are 3 occurrences at indices 1, 2, and 3 which follow an occurrence of key.
For target = 3, there is only one occurrence at index 4 which follows an occurrence of key.
target = 2 has the maximum number of occurrences following an occurrence of key, so we return 2.
","class Solution:
    def mostFrequent(self, nums: list[int], key: int) -> int:
        hash = { }
        l = len(nums)
        res = [float('-inf'), float('-inf')]
        for n in range(l - 1):
            if nums[n] == key:
                if nums[n + 1] in hash:
                    hash[nums[n + 1]] += 1
                else:
                    hash[nums[n + 1]] = 1
        for n in hash:
            if hash[n] > res[1]:
                res[1] = hash[n]
                res[0] = n

        return res[0]
        ",True
Count Hills and Valleys in an Array,"You are given a 0-indexed integer array nums. An index i is part of a hill in nums if the closest non-equal neighbors of i are smaller than nums[i]. Similarly, an index i is part of a valley in nums if the closest non-equal neighbors of i are larger than nums[i]. Adjacent indices i and j are part of the same hill or valley if nums[i] == nums[j].
Note that for an index to be part of a hill or valley, it must have a non-equal neighbor on both the left and right of the index.
Return the number of hills and valleys in nums.
","Example 1:
Input: nums = [2,4,1,1,6,5]
Output: 3
Explanation:
At index 0: There is no non-equal neighbor of 2 on the left, so index 0 is neither a hill nor a valley.
At index 1: The closest non-equal neighbors of 4 are 2 and 1. Since 4 > 2 and 4 > 1, index 1 is a hill. 
At index 2: The closest non-equal neighbors of 1 are 4 and 6. Since 1 < 4 and 1 < 6, index 2 is a valley.
At index 3: The closest non-equal neighbors of 1 are 4 and 6. Since 1 < 4 and 1 < 6, index 3 is a valley, but note that it is part of the same valley as index 2.
At index 4: The closest non-equal neighbors of 6 are 1 and 5. Since 6 > 1 and 6 > 5, index 4 is a hill.
At index 5: There is no non-equal neighbor of 5 on the right, so index 5 is neither a hill nor a valley. 
There are 3 hills and valleys so we return 3.
Example 2:
Input: nums = [6,6,5,5,4,1]
Output: 0
Explanation:
At index 0: There is no non-equal neighbor of 6 on the left, so index 0 is neither a hill nor a valley.
At index 1: There is no non-equal neighbor of 6 on the left, so index 1 is neither a hill nor a valley.
At index 2: The closest non-equal neighbors of 5 are 6 and 4. Since 5 < 6 and 5 > 4, index 2 is neither a hill nor a valley.
At index 3: The closest non-equal neighbors of 5 are 6 and 4. Since 5 < 6 and 5 > 4, index 3 is neither a hill nor a valley.
At index 4: The closest non-equal neighbors of 4 are 5 and 1. Since 4 < 5 and 4 > 1, index 4 is neither a hill nor a valley.
At index 5: There is no non-equal neighbor of 1 on the right, so index 5 is neither a hill nor a valley.
There are 0 hills and valleys so we return 0.
","class Solution:
    def countHillValley(self, nums: List[int]) -> int:
        hill_or_valleys = 0
        last_dir = ''
        for i in range(1, len(nums)):
            diff = nums[i] - nums[i-1]
            if diff == 0:
                continue
            elif diff > 0: # increasing
                if not last_dir or last_dir != 'UP':
                    hill_or_valleys += 1
                    last_dir = 'UP'
            else: # descreasing
                if not last_dir or last_dir != 'DOWN':
                    hill_or_valleys += 1
                    last_dir = 'DOWN'
        return max(0, hill_or_valleys - 1)",True
Find All K-Distant Indices in an Array,"You are given a 0-indexed integer array nums and two integers key and k. A k-distant index is an index i of nums for which there exists at least one index j such that |i - j| <= k and nums[j] == key.
Return a list of all k-distant indices sorted in increasing order.
","Example 1:
Input: nums = [3,4,9,1,3,9,5], key = 9, k = 1
Output: [1,2,3,4,5,6]
Explanation: Here, nums[2] == key and nums[5] == key.
- For index 0, |0 - 2| > k and |0 - 5| > k, so there is no j where |0 - j| <= k and nums[j] == key. Thus, 0 is not a k-distant index.
- For index 1, |1 - 2| <= k and nums[2] == key, so 1 is a k-distant index.
- For index 2, |2 - 2| <= k and nums[2] == key, so 2 is a k-distant index.
- For index 3, |3 - 2| <= k and nums[2] == key, so 3 is a k-distant index.
- For index 4, |4 - 5| <= k and nums[5] == key, so 4 is a k-distant index.
- For index 5, |5 - 5| <= k and nums[5] == key, so 5 is a k-distant index.
- For index 6, |6 - 5| <= k and nums[5] == key, so 6 is a k-distant index.
Thus, we return [1,2,3,4,5,6] which is sorted in increasing order. 
Example 2:
Input: nums = [2,2,2,2,2], key = 2, k = 2
Output: [0,1,2,3,4]
Explanation: For all indices i in nums, there exists some index j such that |i - j| <= k and nums[j] == key, so every index is a k-distant index. 
Hence, we return [0,1,2,3,4].
","class Solution:
    def findKDistantIndices(self, nums: List[int], key: int, k: int) -> List[int]:
        ans = set()
        for i, num in enumerate(nums):
            if num == key:
                ans.update(range(max(0, i-k), min(i+k+1, len(nums))))
        return sorted(list(res))",True
Intersection of Multiple Arrays,"nums
nums[i]
distinct
the list of integers that are present in each array of
nums
sorted in ascending order
","Example 1:
Input: nums = [[3,1,2,4,5],[1,2,3,4],[3,4,5,6]]
Output: [3,4]
Explanation: 
The only integers present in each of nums[0] = [3,1,2,4,5], nums[1] = [1,2,3,4], and nums[2] = [3,4,5,6] are 3 and 4, so we return [3,4].
Example 2:
Input: nums = [[1,2,3],[4,5,6]]
Output: []
Explanation: 
There does not exist any integer present both in nums[0] and nums[1], so we return an empty list [].
","class Solution {
public:
    vector<int> intersection(vector<vector<int>>& nums) {
      unordered_map<int,int>mp;
      for(auto it:nums)
      {
        for(auto i:it)
        {
            mp[i]++;
        }
      }
      int n= nums.size();
      vector<int>ans;
      for(auto it:mp)
      {
        if(it.second==n)
        {
            ans.push_back(it.first);
        }
      }
      sort(ans.begin(),ans.end());
      return ans;
    }
};",False
Count Prefixes of a Given String,"You are given a string array words and a string s, where words[i] and s comprise only of lowercase English letters.
Return the number of strings in words that are a prefix of s.
A prefix of a string is a substring that occurs at the beginning of the string. A substring is a contiguous sequence of characters within a string.
","Example 1:
Input: words = [""a"",""b"",""c"",""ab"",""bc"",""abc""], s = ""abc""
Output: 3
Explanation:
The strings in words which are a prefix of s = ""abc"" are:
""a"", ""ab"", and ""abc"".
Thus the number of strings in words which are a prefix of s is 3.
Example 2:
Input: words = [""a"",""a""], s = ""aa""
Output: 2
Explanation:
Both of the strings are a prefix of s. 
Note that the same string can occur multiple times in words, and it should be counted each time.
","class Solution:
    def countPrefixes(self, words: List[str], s: str) -> int:
        count = 0
        for i in words:
            if s.startswith(i):
                count += 1
        return count

        #One Liner

        return sum(1 for i in words if s.startswith(i))",True
Minimum Rounds to Complete All Tasks,"You are given a 0-indexed integer array tasks, where tasks[i] represents the difficulty level of a task. In each round, you can complete either 2 or 3 tasks of the same difficulty level.
Return the minimum rounds required to complete all the tasks, or -1 if it is not possible to complete all the tasks.
","Example 1:
Input: tasks = [2,2,3,3,2,4,4,4,4,4]
Output: 4
Explanation: To complete all the tasks, a possible plan is:
- In the first round, you complete 3 tasks of difficulty level 2. 
- In the second round, you complete 2 tasks of difficulty level 3. 
- In the third round, you complete 3 tasks of difficulty level 4. 
- In the fourth round, you complete 2 tasks of difficulty level 4.  
It can be shown that all the tasks cannot be completed in fewer than 4 rounds, so the answer is 4.
Example 2:
Input: tasks = [2,3,3]
Output: -1
Explanation: There is only 1 task of difficulty level 2, but in each round, you can only complete either 2 or 3 tasks of the same difficulty level. Hence, you cannot complete all the tasks, and the answer is -1.
","class Solution {
public:
    int minimumRounds(vector<int>& tasks) {
        unordered_map<int, int> mp;
        for(auto x: tasks) mp[x]++;
        int ans = 0;
        for(auto x: mp) {
            if(x.second < 2) return -1;
            ans += ceil(1.0 * x.second / 3);
        }
        return ans;
    }
};",False
Maximum Bags With Full Capacity of Rocks,"You have n bags numbered from 0 to n - 1. You are given two 0-indexed integer arrays capacity and rocks. The ith bag can hold a maximum of capacity[i] rocks and currently contains rocks[i] rocks. You are also given an integer additionalRocks, the number of additional rocks you can place in any of the bags.
Return the maximum number of bags that could have full capacity after placing the additional rocks in some bags.
","Example 1:
Input: capacity = [2,3,4,5], rocks = [1,2,4,4], additionalRocks = 2
Output: 3
Explanation:
Place 1 rock in bag 0 and 1 rock in bag 1.
The number of rocks in each bag are now [2,3,4,4].
Bags 0, 1, and 2 have full capacity.
There are 3 bags at full capacity, so we return 3.
It can be shown that it is not possible to have more than 3 bags at full capacity.
Note that there may be other ways of placing the rocks that result in an answer of 3.
Example 2:
Input: capacity = [10,2,2], rocks = [2,2,0], additionalRocks = 100
Output: 3
Explanation:
Place 8 rocks in bag 0 and 2 rocks in bag 2.
The number of rocks in each bag are now [10,2,2].
Bags 0, 1, and 2 have full capacity.
There are 3 bags at full capacity, so we return 3.
It can be shown that it is not possible to have more than 3 bags at full capacity.
Note that we did not use all of the additional rocks.
","class Solution {
public:
    int maximumBags(vector<int>& capacity, vector<int>& rocks, int additionalRocks) {
        vector<int>ans;
        int cnt=0;
        for(int i=0;i<capacity.size();i++){
            ans.push_back(capacity[i]-rocks[i]);
        }
        sort(ans.begin(),ans.end());
        for(auto it:ans){
            if(it==0) cnt++;
            else if(it<=additionalRocks){
                cnt++;
                additionalRocks-=it;
            }
        }
        return cnt;
    }
};",False
Successful Pairs of Spells and Potions,"You are given two positive integer arrays spells and potions, of length n and m respectively, where spells[i] represents the strength of the ith spell and potions[j] represents the strength of the jth potion.
You are also given an integer success. A spell and potion pair is considered successful if the product of their strengths is at least success.
Return an integer array pairs of length n where pairs[i] is the number of potions that will form a successful pair with the ith spell.
","Example 1:
Input: spells = [5,1,3], potions = [1,2,3,4,5], success = 7
Output: [4,0,3]
Explanation:
- 0th spell: 5 * [1,2,3,4,5] = [5,10,15,20,25]. 4 pairs are successful.
- 1st spell: 1 * [1,2,3,4,5] = [1,2,3,4,5]. 0 pairs are successful.
- 2nd spell: 3 * [1,2,3,4,5] = [3,6,9,12,15]. 3 pairs are successful.
Thus, [4,0,3] is returned.
Example 2:
Input: spells = [3,1,2], potions = [8,5,8], success = 16
Output: [2,0,2]
Explanation:
- 0th spell: 3 * [8,5,8] = [24,15,24]. 2 pairs are successful.
- 1st spell: 1 * [8,5,8] = [8,5,8]. 0 pairs are successful. 
- 2nd spell: 2 * [8,5,8] = [16,10,16]. 2 pairs are successful. 
Thus, [2,0,2] is returned.
",,False
Equal Row and Column Pairs,"Given a 0-indexed n x n integer matrix grid, return the number of pairs (ri, cj) such that row ri and column cj are equal.
A row and column pair is considered equal if they contain the same elements in the same order (i.e., an equal array).
","Example 1:

Input: grid = [[3,2,1],[1,7,6],[2,7,7]]
Output: 1
Explanation: There is 1 equal row and column pair:
- (Row 2, Column 1): [2,7,7]
Example 2:

Input: grid = [[3,1,2,2],[1,4,4,5],[2,4,2,2],[2,4,2,2]]
Output: 3
Explanation: There are 3 equal row and column pairs:
- (Row 0, Column 0): [3,1,2,2]
- (Row 2, Column 2): [2,4,2,2]
- (Row 3, Column 2): [2,4,2,2]
","class Solution:
    def equalPairs(self, grid: List[List[int]]) -> int:
        gridset = defaultdict(int)
        rotatedgrid = list(zip(*grid))
        ans = 0
        for row in grid :
            gridset[tuple(row)] += 1
        for column in rotatedgrid :
            if column in gridset :
                ans += gridset[tuple(column)]
        return ans",True
Number of Zero-Filled Subarrays,"Given an integer array nums, return the number of subarrays filled with 0.
A subarray is a contiguous non-empty sequence of elements within an array.
","Example 1:
Input: nums = [1,3,0,0,2,0,0,4]
Output: 6
Explanation: 
There are 4 occurrences of [0] as a subarray.
There are 2 occurrences of [0,0] as a subarray.
There is no occurrence of a subarray with a size more than 2 filled with 0. Therefore, we return 6.
Example 2:
Input: nums = [0,0,0,2,0,0]
Output: 9
Explanation:
There are 5 occurrences of [0] as a subarray.
There are 3 occurrences of [0,0] as a subarray.
There is 1 occurrence of [0,0,0] as a subarray.
There is no occurrence of a subarray with a size more than 3 filled with 0. Therefore, we return 9.
Example 3:
Input: nums = [2,10,2019]
Output: 0
Explanation: There is no subarray filled with 0. Therefore, we return 0.
","class Solution:
    def zeroFilledSubarray(self, nums: List[int]) -> int:       
        number_of_zerosubs = 0
        counter = 0
        for i in nums:
            if not i:
                counter += 1
            elif counter:
                number_of_zerosubs += sum(range(1, counter+1))
                counter = 0
        if not nums[-1]:
            number_of_zerosubs += sum(range(1, counter+1))
        return number_of_zerosubs",True
Make Array Zero by Subtracting Equal Amounts,"You are given a non-negative integer array nums. In one operation, you must:
Choose a positive integer x such that x is less than or equal to the smallest non-zero element in nums.
Subtract x from every positive element in nums.
Return the minimum number of operations to make every element in nums equal to 0.
","Example 1:
Input: nums = [1,5,0,3,5]
Output: 3
Explanation:
In the first operation, choose x = 1. Now, nums = [0,4,0,2,4].
In the second operation, choose x = 2. Now, nums = [0,2,0,0,2].
In the third operation, choose x = 2. Now, nums = [0,0,0,0,0].
Example 2:
Input: nums = [0]
Output: 0
Explanation: Each element in nums is already 0 so no operations are needed.
",,False
Number of Arithmetic Triplets,"You are given a 0-indexed, strictly increasing integer array nums and a positive integer diff. A triplet (i, j, k) is an arithmetic triplet if the following conditions are met:
i < j < k,
nums[j] - nums[i] == diff, and
nums[k] - nums[j] == diff.
Return the number of unique arithmetic triplets.
","Example 1:
Input: nums = [0,1,4,6,7,10], diff = 3
Output: 2
Explanation:
(1, 2, 4) is an arithmetic triplet because both 7 - 4 == 3 and 4 - 1 == 3.
(2, 4, 5) is an arithmetic triplet because both 10 - 7 == 3 and 7 - 4 == 3. 
Example 2:
Input: nums = [4,5,6,7,8,9], diff = 2
Output: 2
Explanation:
(0, 2, 4) is an arithmetic triplet because both 8 - 6 == 2 and 6 - 4 == 2.
(1, 3, 5) is an arithmetic triplet because both 9 - 7 == 2 and 7 - 5 == 2.
","class Solution:
    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:
        dict_ = {}
        for num in nums:
            dict_[num] = dict_.get(num,0) + 1 ##To keep the count of each num's occurence
        
        count = 0
        for num in nums:
            if dict_.get(num+diff) and dict_.get(num+diff*2): #Check if any number with 3 and 6 more than present in dictionary
                count += 1
        return count",True
Check if There is a Valid Partition For The Array,"You are given a 0-indexed integer array nums. You have to partition the array into one or more contiguous subarrays.
We call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions:
The subarray consists of exactly 2, equal elements. For example, the subarray [2,2] is good.
The subarray consists of exactly 3, equal elements. For example, the subarray [4,4,4] is good.
The subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1. For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not.
Return true if the array has at least one valid partition. Otherwise, return false.
","Example 1:
Input: nums = [4,4,4,5,6]
Output: true
Explanation: The array can be partitioned into the subarrays [4,4] and [4,5,6].
This partition is valid, so we return true.
Example 2:
Input: nums = [1,1,1,2]
Output: false
Explanation: There is no valid partition for this array.
","class Solution {
public:
    bool chk(int i, int j, vector<int> &a) {
        if (j - i == 1) {
            return a[i] == a[j];
        }
        else {
            if (a[i] == a[i + 1] && a[i + 1] == a[i + 2]) return 1;
            return a[i + 1] - a[i] == 1 && a[i + 2] - a[i + 1] == 1;
        }
        return 0;
    }

    bool f(int i, vector<int> &a, vector<int> &dp) {
        if (i > a.size()) return 0;
        if (i == a.size()) return 1;

        if (dp[i] != -1) return dp[idx];
        bool two = 0, three = 0;
        if(i < a.size() - 1 && chk(i, i + 1, a)) two = f(i + 2, a, dp);
        if(i < a.size() - 2 && chk(i, i + 2, a)) three = f(i + 3, a, dp);

        return dp[i] = aa || b;
    }
    
    bool validPartition(vector<int>& nums) {
        vector<int> dp(nums.size(), -1);
        return f(0, nums, dp);
    }
};",False
Merge Similar Items,"You are given two 2D integer arrays, items1 and items2, representing two sets of items. Each array items has the following properties:
items[i] = [valuei, weighti] where valuei represents the value and weighti represents the weight of the ith item.
The value of each item in items is unique.
Return a 2D integer array ret where ret[i] = [valuei, weighti], with weighti being the sum of weights of all items with value valuei.
Note: ret should be returned in ascending order by value.
","Example 1:
Input: items1 = [[1,1],[4,5],[3,8]], items2 = [[3,1],[1,5]]
Output: [[1,6],[3,9],[4,5]]
Explanation: 
The item with value = 1 occurs in items1 with weight = 1 and in items2 with weight = 5, total weight = 1 + 5 = 6.
The item with value = 3 occurs in items1 with weight = 8 and in items2 with weight = 1, total weight = 8 + 1 = 9.
The item with value = 4 occurs in items1 with weight = 5, total weight = 5.  
Therefore, we return [[1,6],[3,9],[4,5]].
Example 2:
Input: items1 = [[1,1],[3,2],[2,3]], items2 = [[2,1],[3,2],[1,3]]
Output: [[1,4],[2,4],[3,4]]
Explanation: 
The item with value = 1 occurs in items1 with weight = 1 and in items2 with weight = 3, total weight = 1 + 3 = 4.
The item with value = 2 occurs in items1 with weight = 3 and in items2 with weight = 1, total weight = 3 + 1 = 4.
The item with value = 3 occurs in items1 with weight = 2 and in items2 with weight = 2, total weight = 2 + 2 = 4.
Therefore, we return [[1,4],[2,4],[3,4]].
Example 3:
Input: items1 = [[1,3],[2,2]], items2 = [[7,1],[2,2],[1,4]]
Output: [[1,7],[2,4],[7,1]]
Explanation:
The item with value = 1 occurs in items1 with weight = 3 and in items2 with weight = 4, total weight = 3 + 4 = 7. 
The item with value = 2 occurs in items1 with weight = 2 and in items2 with weight = 2, total weight = 2 + 2 = 4. 
The item with value = 7 occurs in items2 with weight = 1, total weight = 1.
Therefore, we return [[1,7],[2,4],[7,1]].
","class Solution:
    def mergeSimilarItems(self, i1: List[List[int]], i2: List[List[int]]) -> List[List[int]]:
        return sorted((Counter({i[0] : i[1] for i in i1}) + Counter({i[0] : i[1] for i in i2})).items())",True
Largest Local Values in a Matrix,"You are given an n x n integer matrix grid.
Generate an integer matrix maxLocal of size (n - 2) x (n - 2) such that:
maxLocal[i][j] is equal to the largest value of the 3 x 3 matrix in grid centered around row i + 1 and column j + 1.
In other words, we want to find the largest value in every contiguous 3 x 3 matrix in grid.
Return the generated matrix.
","Example 1:

Input: grid = [[9,9,8,1],[5,6,2,6],[8,2,6,4],[6,2,2,2]]
Output: [[9,9],[8,6]]
Explanation: The diagram above shows the original matrix and the generated matrix.
Notice that each value in the generated matrix corresponds to the largest value of a contiguous 3 x 3 matrix in grid.
Example 2:

Input: grid = [[1,1,1,1,1],[1,1,1,1,1],[1,1,2,1,1],[1,1,1,1,1],[1,1,1,1,1]]
Output: [[2,2,2],[2,2,2],[2,2,2]]
Explanation: Notice that the 2 is contained within every contiguous 3 x 3 matrix in grid.
","class Solution:
    def largestLocal(self, g: List[List[int]]) -> List[List[int]]:
        return [[max(g[i+p][j+q] for p,q in product(*[(0,1,2)]*2)) for j in range(len(g)-2)] for i in range(len(g)-2)]",True
Shifting Letters II,"You are given a string s of lowercase English letters and a 2D integer array shifts where shifts[i] = [starti, endi, directioni]. For every i, shift the characters in s from the index starti to the index endi (inclusive) forward if directioni = 1, or shift the characters backward if directioni = 0.
Shifting a character forward means replacing it with the next letter in the alphabet (wrapping around so that 'z' becomes 'a'). Similarly, shifting a character backward means replacing it with the previous letter in the alphabet (wrapping around so that 'a' becomes 'z').
Return the final string after all such shifts to s are applied.
","Example 1:
Input: s = ""abc"", shifts = [[0,1,0],[1,2,1],[0,2,1]]
Output: ""ace""
Explanation: Firstly, shift the characters from index 0 to index 1 backward. Now s = ""zac"".
Secondly, shift the characters from index 1 to index 2 forward. Now s = ""zbd"".
Finally, shift the characters from index 0 to index 2 forward. Now s = ""ace"".
Example 2:
Input: s = ""dztz"", shifts = [[0,0,0],[1,1,1]]
Output: ""catz""
Explanation: Firstly, shift the characters from index 0 to index 0 backward. Now s = ""cztz"".
Finally, shift the characters from index 1 to index 1 forward. Now s = ""catz"".
","class Solution:
    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:
        def update(a, x, y, p, v, l, r):
            """"""
            update at position p
            """"""
            if x>=r or l>=y:
                return             
            if x<=l and r<=y:
                tree[v][""full""] += p
                tree[v][""value""] += p * (r - l)
                return
      
            v1, v2 = (v<<1), (v<<1) +1
            m = (l + r)//2
            update(a, x, y, p, v1, l, m)
            update(a, x, y, p, v2, m, r)
            tree[v][""value""] = tree[v1][""value""] + tree[v2][""value""]
            pass # update      

        def query(a, x, y, p, v, l, r):
            """"""
            query on [x, y) in [0,n) of arr
            """"""
            if x>=r or l>=y:  # [x, y) intersection [l,r) = empty
                return 0
            if x<=l and r <= y: # // [l,r) is a subset of [x,y)
                return a[v][""value""] + p * (r - l)
            
            v1, v2 = (v<<1), (v<<1) +1
            p += a[v][""full""]
            m = (l + r) // 2
            q1 = query(a, x, y, p, v1, l, m)
            q2 = query(a, x, y, p, v2, m, r)
            return q1 + q2
            pass # query        
        
        n = len(s)
        tree = [{""value"": 0, ""full"": 0} for _ in range(4*n)]  # 
        shifts = sorted(shifts)
        s0, e0, d0 = shifts[0]
        p0 = 1 if d0==1 else -1
        for si, ei, di in shifts[1:]:
            pi = 1 if di==1 else -1
            if s0==si and e0==ei:
                p0 += pi
            elif e0+1==si and p0==pi:
                e0 = ei
            else:
                update(tree, s0, e0+1, p0, 1, 0, n)
                s0, e0, p0 = si, ei, pi
        update(tree, s0, e0+1, p0, 1, 0, n)

        ans = []
        for i in range(0, n):
            di = query(tree, i, i+1, 0, 1, 0, n)
            pi = (ord(s[i]) - ord('a') + di)%26 # (ord('z') - ord('a') + 1)
            ans.append(chr(ord('a') + pi))
        
        ans = """".join(ans)
        # print(ans)
        # print(""=""*20)
        return ans

print = lambda *a, **aa: ()",True
Longest Subsequence With Limited Sum,"You are given an integer array nums of length n, and an integer array queries of length m.
Return an array answer of length m where answer[i] is the maximum size of a subsequence that you can take from nums such that the sum of its elements is less than or equal to queries[i].
A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.
","Example 1:
Input: nums = [4,5,2,1], queries = [3,10,21]
Output: [2,3,4]
Explanation: We answer the queries as follows:
- The subsequence [2,1] has a sum less than or equal to 3. It can be proven that 2 is the maximum size of such a subsequence, so answer[0] = 2.
- The subsequence [4,5,1] has a sum less than or equal to 10. It can be proven that 3 is the maximum size of such a subsequence, so answer[1] = 3.
- The subsequence [4,5,2,1] has a sum less than or equal to 21. It can be proven that 4 is the maximum size of such a subsequence, so answer[2] = 4.
Example 2:
Input: nums = [2,3,4,5], queries = [1]
Output: [0]
Explanation: The empty subsequence is the only subsequence that has a sum less than or equal to 1, so answer[0] = 0.
",,False
Minimum Amount of Time to Collect Garbage,"You are given a 0-indexed array of strings garbage where garbage[i] represents the assortment of garbage at the ith house. garbage[i] consists only of the characters 'M', 'P' and 'G' representing one unit of metal, paper and glass garbage respectively. Picking up one unit of any type of garbage takes 1 minute.
You are also given a 0-indexed integer array travel where travel[i] is the number of minutes needed to go from house i to house i + 1.
There are three garbage trucks in the city, each responsible for picking up one type of garbage. Each garbage truck starts at house 0 and must visit each house in order; however, they do not need to visit every house.
Only one garbage truck may be used at any given moment. While one truck is driving or picking up garbage, the other two trucks cannot do anything.
Return the minimum number of minutes needed to pick up all the garbage.
","Example 1:
Input: garbage = [""G"",""P"",""GP"",""GG""], travel = [2,4,3]
Output: 21
Explanation:
The paper garbage truck:
1. Travels from house 0 to house 1
2. Collects the paper garbage at house 1
3. Travels from house 1 to house 2
4. Collects the paper garbage at house 2
Altogether, it takes 8 minutes to pick up all the paper garbage.
The glass garbage truck:
1. Collects the glass garbage at house 0
2. Travels from house 0 to house 1
3. Travels from house 1 to house 2
4. Collects the glass garbage at house 2
5. Travels from house 2 to house 3
6. Collects the glass garbage at house 3
Altogether, it takes 13 minutes to pick up all the glass garbage.
Since there is no metal garbage, we do not need to consider the metal garbage truck.
Therefore, it takes a total of 8 + 13 = 21 minutes to collect all the garbage.
Example 2:
Input: garbage = [""MMM"",""PGM"",""GP""], travel = [3,10]
Output: 37
Explanation:
The metal garbage truck takes 7 minutes to pick up all the metal garbage.
The paper garbage truck takes 15 minutes to pick up all the paper garbage.
The glass garbage truck takes 15 minutes to pick up all the glass garbage.
It takes a total of 7 + 15 + 15 = 37 minutes to collect all the garbage.
","class Solution:
    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:
        G = P = M = 0
        n = len(garbage)
        for i in range(n-1,0,-1):
            if ""G"" in garbage[i]:
                G = i
                break
        for i in range(n-1,0,-1):
            if ""P"" in garbage[i]:
                P = i
                break
        for i in range(n-1,0,-1):
            if ""M"" in garbage[i]:
                M = i
                break

        sum = 0
        #calculate distance:
        for i in travel[0:G]:
            sum+=i
        for i in travel[0:P]:
            sum+=i
        for i in travel[0:M]:
            sum+=i
        for i in garbage:
            sum+=len(i)
        return sum",True
Check Distances Between Same Letters,"You are given a 0-indexed string s consisting of only lowercase English letters, where each letter in s appears exactly twice. You are also given a 0-indexed integer array distance of length 26.
Each letter in the alphabet is numbered from 0 to 25 (i.e. 'a' -> 0, 'b' -> 1, 'c' -> 2, ... , 'z' -> 25).
In a well-spaced string, the number of letters between the two occurrences of the ith letter is distance[i]. If the ith letter does not appear in s, then distance[i] can be ignored.
Return true if s is a well-spaced string, otherwise return false.
","Example 1:
Input: s = ""abaccb"", distance = [1,3,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Output: true
Explanation:
- 'a' appears at indices 0 and 2 so it satisfies distance[0] = 1.
- 'b' appears at indices 1 and 5 so it satisfies distance[1] = 3.
- 'c' appears at indices 3 and 4 so it satisfies distance[2] = 0.
Note that distance[3] = 5, but since 'd' does not appear in s, it can be ignored.
Return true because s is a well-spaced string.
Example 2:
Input: s = ""aa"", distance = [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
Output: false
Explanation:
- 'a' appears at indices 0 and 1 so there are zero letters between them.
Because distance[0] = 1, s is not a well-spaced string.
","class Solution:
    def checkDistances(self, s: str, distance: List[int]) -> bool:        
        hashmap = {}
        for i in range(len(s)):
            if s[i] in hashmap and i - hashmap[s[i]] - 1 != distance[ord(s[i]) - ord('a')]:
                return False
            hashmap[s[i]] = i                           
        return True",True
Most Frequent Even Element,"Given an integer array nums, return the most frequent even element.
If there is a tie, return the smallest one. If there is no such element, return -1.
","Example 1:
Input: nums = [0,1,2,2,4,4,1]
Output: 2
Explanation:
The even elements are 0, 2, and 4. Of these, 2 and 4 appear the most.
We return the smallest one, which is 2.
Example 2:
Input: nums = [4,4,4,9,2,4]
Output: 4
Explanation: 4 is the even element appears the most.
Example 3:
Input: nums = [29,47,21,41,13,37,25,7]
Output: -1
Explanation: There is no even element.
","class Solution:
    def mostFrequentEven(self, nums: List[int]) -> int:
        d = {}
        for ele in nums:
            if ele%2 == 0:
                d[ele] = d.get(ele,0) + 1

        if not d:
            return -1

        maxv = max(d.values())

        return min([ele for ele in d if d[ele] == maxv])
        # Or
        maxe = [ele for ele in d if d[ele] == maxv]
        return min(maxe)

",True
Sort the People,"You are given an array of strings names, and an array heights that consists of distinct positive integers. Both arrays are of length n.
For each index i, names[i] and heights[i] denote the name and height of the ith person.
Return names sorted in descending order by the people's heights.
","Example 1:
Input: names = [""Mary"",""John"",""Emma""], heights = [180,165,170]
Output: [""Mary"",""Emma"",""John""]
Explanation: Mary is the tallest, followed by Emma and John.
Example 2:
Input: names = [""Alice"",""Bob"",""Bob""], heights = [155,185,150]
Output: [""Bob"",""Alice"",""Bob""]
Explanation: The first Bob is the tallest, followed by Alice and the second Bob.
","class Solution:
    def sortPeople(self, n: List[str], h: List[int]) -> List[str]:
        d=dict(zip(h,n))
        c=[]
        h.sort(reverse=True)
        for i in h:
            c.append(d[i])
        return c",True
Find The Original Array of Prefix Xor,"You are given an integer array pref of size n. Find and return the array arr of size n that satisfies:
pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i].
Note that ^ denotes the bitwise-xor operation.
It can be proven that the answer is unique.
","Example 1:
Input: pref = [5,2,0,3,1]
Output: [5,7,2,3,2]
Explanation: From the array [5,7,2,3,2] we have the following:
- pref[0] = 5.
- pref[1] = 5 ^ 7 = 2.
- pref[2] = 5 ^ 7 ^ 2 = 0.
- pref[3] = 5 ^ 7 ^ 2 ^ 3 = 3.
- pref[4] = 5 ^ 7 ^ 2 ^ 3 ^ 2 = 1.
Example 2:
Input: pref = [13]
Output: [13]
Explanation: We have pref[0] = arr[0] = 13.
","class Solution:
    def findArray(self, pref: List[int]) -> List[int]:
        arr = [pref[0]]
        for i in range(1, len(pref)):
            arr.append(pref[i] ^ pref[i - 1])
        return arr",True
Largest Positive Integer That Exists With Its Negative,"Given an integer array nums that does not contain any zeros, find the largest positive integer k such that -k also exists in the array.
Return the positive integer k. If there is no such integer, return -1.
","Example 1:
Input: nums = [-1,2,-3,3]
Output: 3
Explanation: 3 is the only valid k we can find in the array.
Example 2:
Input: nums = [-1,10,6,7,-7,1]
Output: 7
Explanation: Both 1 and 7 have their corresponding negative values in the array. 7 has a larger value.
Example 3:
Input: nums = [-10,8,6,7,-2,-3]
Output: -1
Explanation: There is no a single valid k, we return -1.
","class Solution:
    def findMaxK(self, nums: List[int]) -> int:
        nums.sort()
        l, r = 0, len(nums)-1
        
        while(nums[l]<0 and l<r):
            if nums[l]*(-1) == nums[r]:
                return nums[r]
            if nums[l]*(-1) > nums[r]:
                l += 1
            else:
                r -= 1
        
        return -1",True
Count Number of Distinct Integers After Reverse Operations,"You are given an array nums consisting of positive integers.
You have to take each integer in the array, reverse its digits, and add it to the end of the array. You should apply this operation to the original integers in nums.
Return the number of distinct integers in the final array.
","Example 1:
Input: nums = [1,13,10,12,31]
Output: 6
Explanation: After including the reverse of each number, the resulting array is [1,13,10,12,31,1,31,1,21,13].
The reversed integers that were added to the end of the array are underlined. Note that for the integer 10, after reversing it, it becomes 01 which is just 1.
The number of distinct integers in this array is 6 (The numbers 1, 10, 12, 13, 21, and 31).
Example 2:
Input: nums = [2,2,2]
Output: 1
Explanation: After including the reverse of each number, the resulting array is [2,2,2,2,2,2].
The number of distinct integers in this array is 1 (The number 2).
","class Solution:
    def countDistinctIntegers(self, nums: List[int]) -> int:
        D=nums[:]
        for i in range(len(nums)):
            T=str(nums[i])
            T=T[::-1]
            D.append(int(T))
        return len(set(D))
        ",True
Minimize Maximum of Array,"You are given a 0-indexed array nums comprising of n non-negative integers.
In one operation, you must:
Choose an integer i such that 1 <= i < n and nums[i] > 0.
Decrease nums[i] by 1.
Increase nums[i - 1] by 1.
Return the minimum possible value of the maximum integer of nums after performing any number of operations.
","Example 1:
Input: nums = [3,7,1,6]
Output: 5
Explanation:
One set of optimal operations is as follows:
1. Choose i = 1, and nums becomes [4,6,1,6].
2. Choose i = 3, and nums becomes [4,6,2,5].
3. Choose i = 1, and nums becomes [5,5,2,5].
The maximum integer of nums is 5. It can be shown that the maximum number cannot be less than 5.
Therefore, we return 5.
Example 2:
Input: nums = [10,1]
Output: 10
Explanation:
It is optimal to leave nums as is, and since 10 is the maximum value, we return 10.
","class Solution:
    def minimizeArrayValue(self, nums: List[int]) -> int:
        start, end = 0, max(nums)
        while start + 1 < end:
            mid = (start + end) // 2
            if self.check(nums, mid):
                end = mid
            else:
                start = mid
        if self.check(nums, start):
            return start
        else:
            return end
        
    def check(self, nums, k):
        n = len(nums)
        temp = 0
        for i in range(n - 1, 0, -1):
            if temp + nums[i] > k:
                temp += nums[i] - k
            else:
                temp = 0
        return False if temp + nums[0] > k else True",True
Determine if Two Events Have Conflict,"You are given two arrays of strings that represent two inclusive events that happened on the same day, event1 and event2, where:
event1 = [startTime1, endTime1] and
event2 = [startTime2, endTime2].
Event times are valid 24 hours format in the form of HH:MM.
A conflict happens when two events have some non-empty intersection (i.e., some moment is common to both events).
Return true if there is a conflict between two events. Otherwise, return false.
","Example 1:
Input: event1 = [""01:15"",""02:00""], event2 = [""02:00"",""03:00""]
Output: true
Explanation: The two events intersect at time 2:00.
Example 2:
Input: event1 = [""01:00"",""02:00""], event2 = [""01:20"",""03:00""]
Output: true
Explanation: The two events intersect starting from 01:20 to 02:00.
Example 3:
Input: event1 = [""10:00"",""11:00""], event2 = [""14:00"",""15:00""]
Output: false
Explanation: The two events do not intersect.
","class Solution:
    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:
        e1s=int(event1[0][:2])*60 + int(event1[0][3:])
        e1e=int(event1[1][:2])*60 + int(event1[1][3:])
        e2s=int(event2[0][:2])*60 + int(event2[0][3:])
        e2e=int(event2[1][:2])*60 + int(event2[1][3:])
        if e1s<=e2s<=e1e: return True
        if e2s<=e1s<=e2e: return True
        if e1s<=e2e<=e1e: return True
        if e2s<=e1e<=e2e: return True
        else: return False",True
Average Value of Even Numbers That Are Divisible by Three,"Given an integer array nums of positive integers, return the average value of all even integers that are divisible by 3.
Note that the average of n elements is the sum of the n elements divided by n and rounded down to the nearest integer.
","Example 1:
Input: nums = [1,3,6,10,12,15]
Output: 9
Explanation: 6 and 12 are even numbers that are divisible by 3. (6 + 12) / 2 = 9.
Example 2:
Input: nums = [1,2,4,7,10]
Output: 0
Explanation: There is no single number that satisfies the requirement, so return 0.
","class Solution {
    public int averageValue(int[] nums) {
        int sum = 0;
        int count = 0;
        for(int num:nums)
            if (num%6==0) {
                sum += num;
                count++;
            }
       return count == 0 ? 0 : sum/count;
    }
}",False
Odd String Difference,"You are given an array of equal-length strings words. Assume that the length of each string is n.
Each string words[i] can be converted into a difference integer array difference[i] of length n - 1 where difference[i][j] = words[i][j+1] - words[i][j] where 0 <= j <= n - 2. Note that the difference between two letters is the difference between their positions in the alphabet i.e. the position of 'a' is 0, 'b' is 1, and 'z' is 25.
For example, for the string ""acb"", the difference integer array is [2 - 0, 1 - 2] = [2, -1].
All the strings in words have the same difference integer array, except one. You should find that string.
Return the string in words that has different difference integer array.
","Example 1:
Input: words = [""adc"",""wzy"",""abc""]
Output: ""abc""
Explanation: 
- The difference integer array of ""adc"" is [3 - 0, 2 - 3] = [3, -1].
- The difference integer array of ""wzy"" is [25 - 22, 24 - 25]= [3, -1].
- The difference integer array of ""abc"" is [1 - 0, 2 - 1] = [1, 1]. 
The odd array out is [1, 1], so we return the corresponding string, ""abc"".
Example 2:
Input: words = [""aaa"",""bob"",""ccc"",""ddd""]
Output: ""bob""
Explanation: All the integer arrays are [0, 0] except for ""bob"", which corresponds to [13, -13].
","class Solution:
    def oddString(self, words: List[str]) -> str:
        n = len(words[0])
        temp = []
        for i in range(len(words)):
            print(self.diff(words[i]))
            temp.append(self.diff(words[i]))

        print((temp))
        for i in range(len(temp)):
            if temp.count(temp[i]) == 1:
                return words[i]
        return ''
        
    def diff(self, word: str) -> str:
        return [ord(word[i]) - ord(word[i-1]) for i in range(1, len(word))]",True
Apply Operations to an Array,"You are given a 0-indexed array nums of size n consisting of non-negative integers.
You need to apply n - 1 operations to this array where, in the ith operation (0-indexed), you will apply the following on the ith element of nums:
If nums[i] == nums[i + 1], then multiply nums[i] by 2 and set nums[i + 1] to 0. Otherwise, you skip this operation.
After performing all the operations, shift all the 0's to the end of the array.
For example, the array [1,0,2,0,0,1] after shifting all its 0's to the end, is [1,2,1,0,0,0].
Return the resulting array.
Note that the operations are applied sequentially, not all at once.
","Example 1:
Input: nums = [1,2,2,1,1,0]
Output: [1,4,2,0,0,0]
Explanation: We do the following operations:
- i = 0: nums[0] and nums[1] are not equal, so we skip this operation.
- i = 1: nums[1] and nums[2] are equal, we multiply nums[1] by 2 and change nums[2] to 0. The array becomes [1,4,0,1,1,0].
- i = 2: nums[2] and nums[3] are not equal, so we skip this operation.
- i = 3: nums[3] and nums[4] are equal, we multiply nums[3] by 2 and change nums[4] to 0. The array becomes [1,4,0,2,0,0].
- i = 4: nums[4] and nums[5] are equal, we multiply nums[4] by 2 and change nums[5] to 0. The array becomes [1,4,0,2,0,0].
After that, we shift the 0's to the end, which gives the array [1,4,2,0,0,0].
Example 2:
Input: nums = [0,1]
Output: [1,0]
Explanation: No operation can be applied, we just shift the 0 to the end.
","class Solution:
    def applyOperations(self, nums: List[int]) -> List[int]:

        for i in range(len(nums)-1):
            if nums[i] == nums[i+1]:
                nums[i]*= 2
                nums[i + 1] = 0   # <-- performing the ""operation.""  
      
        return sorted(nums, key=lambda x: x == 0)   # Sorting on a boolean key: False, then True. O(N*logN) worst case, but likely much better because of the key.",True
Maximum Sum of Distinct Subarrays With Length K,"You are given an integer array nums and an integer k. Find the maximum subarray sum of all the subarrays of nums that meet the following conditions:
The length of the subarray is k, and
All the elements of the subarray are distinct.
Return the maximum subarray sum of all the subarrays that meet the conditions. If no subarray meets the conditions, return 0.
A subarray is a contiguous non-empty sequence of elements within an array.
","Example 1:
Input: nums = [1,5,4,2,9,9,9], k = 3
Output: 15
Explanation: The subarrays of nums with length 3 are:
- [1,5,4] which meets the requirements and has a sum of 10.
- [5,4,2] which meets the requirements and has a sum of 11.
- [4,2,9] which meets the requirements and has a sum of 15.
- [2,9,9] which does not meet the requirements because the element 9 is repeated.
- [9,9,9] which does not meet the requirements because the element 9 is repeated.
We return 15 because it is the maximum subarray sum of all the subarrays that meet the conditions
Example 2:
Input: nums = [4,4,4], k = 3
Output: 0
Explanation: The subarrays of nums with length 3 are:
- [4,4,4] which does not meet the requirements because the element 4 is repeated.
We return 0 because no subarrays meet the conditions.
","class Solution:
    def maximumSubarraySum(self, nums: List[int], k: int) -> int:
        
        subarray = {}
        queue = []
        temp_sum = 0
        max_sum = 0
    
        for i in range(len(nums)):

            # if not in subarray, we have two conditions to pay attention to
            if nums[i] not in subarray:
                # FIRST SCENARIO
                if len(subarray) < k:
                    # subarray size is less than K
                    # we can just simply add new element to subarray
                    subarray[nums[i]] = i
                    temp_sum += nums[i]
                    queue.append(nums[i])

                # SECOND SCENARIO
                else:
                    # remove first element in subarray
                    # add new element we encounter
                    temp = queue.pop(0)
                    temp_sum -= nums[subarray[temp]]
                    del subarray[temp]

                    subarray[nums[i]] = i
                    temp_sum += nums[i]   
                    queue.append(nums[i])                 

            else:
                # keep removing first element in the subarray
                # until the duplicated element we encounter no longer
                # exist in the subarray
                while nums[i] in subarray:
                    temp = queue.pop(0)
                    temp_sum -= nums[subarray[temp]]
                    del subarray[temp]
                # then add the new duplicated value to subarray (now it will be distinct)
                subarray[nums[i]] = i
                temp_sum += nums[i]
                queue.append(nums[i])
                
            # at the end of each for loop operation
            # we ensure that subarray are all distinct
            # if size of it satisfied constraint, we look to see
            # it it's a possible new max sum
            if len(subarray) == k:
                max_sum = max(temp_sum, max_sum)


        return max_sum
                  ",True
Total Cost to Hire K Workers,"You are given a 0-indexed integer array costs where costs[i] is the cost of hiring the ith worker.
You are also given two integers k and candidates. We want to hire exactly k workers according to the following rules:
You will run k sessions and hire exactly one worker in each session.
In each hiring session, choose the worker with the lowest cost from either the first candidates workers or the last candidates workers. Break the tie by the smallest index.
For example, if costs = [3,2,7,7,1,2] and candidates = 2, then in the first hiring session, we will choose the 4th worker because they have the lowest cost [3,2,7,7,1,2].
In the second hiring session, we will choose 1st worker because they have the same lowest cost as 4th worker but they have the smallest index [3,2,7,7,2]. Please note that the indexing may be changed in the process.
If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them. Break the tie by the smallest index.
A worker can only be chosen once.
Return the total cost to hire exactly k workers.
","Example 1:
Input: costs = [17,12,10,2,7,2,11,20,8], k = 3, candidates = 4
Output: 11
Explanation: We hire 3 workers in total. The total cost is initially 0.
- In the first hiring round we choose the worker from [17,12,10,2,7,2,11,20,8]. The lowest cost is 2, and we break the tie by the smallest index, which is 3. The total cost = 0 + 2 = 2.
- In the second hiring round we choose the worker from [17,12,10,7,2,11,20,8]. The lowest cost is 2 (index 4). The total cost = 2 + 2 = 4.
- In the third hiring round we choose the worker from [17,12,10,7,11,20,8]. The lowest cost is 7 (index 3). The total cost = 4 + 7 = 11. Notice that the worker with index 3 was common in the first and last four workers.
The total hiring cost is 11.
Example 2:
Input: costs = [1,2,4,1], k = 3, candidates = 3
Output: 4
Explanation: We hire 3 workers in total. The total cost is initially 0.
- In the first hiring round we choose the worker from [1,2,4,1]. The lowest cost is 1, and we break the tie by the smallest index, which is 0. The total cost = 0 + 1 = 1. Notice that workers with index 1 and 2 are common in the first and last 3 workers.
- In the second hiring round we choose the worker from [2,4,1]. The lowest cost is 1 (index 2). The total cost = 1 + 1 = 2.
- In the third hiring round there are less than three candidates. We choose the worker from the remaining workers [2,4]. The lowest cost is 2 (index 0). The total cost = 2 + 2 = 4.
The total hiring cost is 4.
",,False
Number of Distinct Averages,"You are given a 0-indexed integer array nums of even length.
As long as nums is not empty, you must repetitively:
Find the minimum number in nums and remove it.
Find the maximum number in nums and remove it.
Calculate the average of the two removed numbers.
The average of two numbers a and b is (a + b) / 2.
For example, the average of 2 and 3 is (2 + 3) / 2 = 2.5.
Return the number of distinct averages calculated using the above process.
Note that when there is a tie for a minimum or maximum number, any can be removed.
","Example 1:
Input: nums = [4,1,4,0,3,5]
Output: 2
Explanation:
1. Remove 0 and 5, and the average is (0 + 5) / 2 = 2.5. Now, nums = [4,1,4,3].
2. Remove 1 and 4. The average is (1 + 4) / 2 = 2.5, and nums = [4,3].
3. Remove 3 and 4, and the average is (3 + 4) / 2 = 3.5.
Since there are 2 distinct numbers among 2.5, 2.5, and 3.5, we return 2.
Example 2:
Input: nums = [1,100]
Output: 1
Explanation:
There is only one average to be calculated after removing 1 and 100, so we return 1.
","class Solution:
    def distinctAverages(self, nums: List[int]) -> int:
        av=[]
        nums.sort()
        while nums:
            av.append((nums[-1]+nums[0])/2)
            nums.pop(-1)
            nums.pop(0)
        return len(set(av))",True
Most Profitable Path in a Tree,"There is an undirected tree with n nodes labeled from 0 to n - 1, rooted at node 0. You are given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.
At every node i, there is a gate. You are also given an array of even integers amount, where amount[i] represents:
the price needed to open the gate at node i, if amount[i] is negative, or,
the cash reward obtained on opening the gate at node i, otherwise.
The game goes on as follows:
Initially, Alice is at node 0 and Bob is at node bob.
At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node 0.
For every node along their path, Alice and Bob either spend money to open the gate at that node, or accept the reward. Note that:
If the gate is already open, no price will be required, nor will there be any cash reward.
If Alice and Bob reach the node simultaneously, they share the price/reward for opening the gate there. In other words, if the price to open the gate is c, then both Alice and Bob pay c / 2 each. Similarly, if the reward at the gate is c, both of them receive c / 2 each.
If Alice reaches a leaf node, she stops moving. Similarly, if Bob reaches node 0, he stops moving. Note that these events are independent of each other.
Return the maximum net income Alice can have if she travels towards the optimal leaf node.
","Example 1:

Input: edges = [[0,1],[1,2],[1,3],[3,4]], bob = 3, amount = [-2,4,2,-4,6]
Output: 6
Explanation: 
The above diagram represents the given tree. The game goes as follows:
- Alice is initially on node 0, Bob on node 3. They open the gates of their respective nodes.
  Alice's net income is now -2.
- Both Alice and Bob move to node 1. 
  Since they reach here simultaneously, they open the gate together and share the reward.
  Alice's net income becomes -2 + (4 / 2) = 0.
- Alice moves on to node 3. Since Bob already opened its gate, Alice's income remains unchanged.
  Bob moves on to node 0, and stops moving.
- Alice moves on to node 4 and opens the gate there. Her net income becomes 0 + 6 = 6.
Now, neither Alice nor Bob can make any further moves, and the game ends.
It is not possible for Alice to get a higher net income.
Example 2:

Input: edges = [[0,1]], bob = 1, amount = [-7280,2350]
Output: -7280
Explanation: 
Alice follows the path 0->1 whereas Bob follows the path 1->0.
Thus, Alice opens the gate at node 0 only. Hence, her net income is -7280. 
",,False
Number of Unequal Triplets in Array,"You are given a 0-indexed array of positive integers nums. Find the number of triplets (i, j, k) that meet the following conditions:
0 <= i < j < k < nums.length
nums[i], nums[j], and nums[k] are pairwise distinct.
In other words, nums[i] != nums[j], nums[i] != nums[k], and nums[j] != nums[k].
Return the number of triplets that meet the conditions.
","Example 1:
Input: nums = [4,4,2,4,3]
Output: 3
Explanation: The following triplets meet the conditions:
- (0, 2, 4) because 4 != 2 != 3
- (1, 2, 4) because 4 != 2 != 3
- (2, 3, 4) because 2 != 4 != 3
Since there are 3 triplets, we return 3.
Note that (2, 0, 4) is not a valid triplet because 2 > 0.
Example 2:
Input: nums = [1,1,1,1,1]
Output: 0
Explanation: No triplets meet the conditions so we return 0.
","class Solution(object):
    def unequalTriplets(self, nums):
        """"""
        :type nums: List[int]
        :rtype: int
        """"""
        ans = 0

        for i in range(len(nums) - 2):
            set_n = set()
            set_n.add(nums[i])
            for j in range(i + 1, len(nums) - 1):
                if nums[j] in set_n:
                    continue
                set_n.add(nums[j])
                for k in range(j + 1, len(nums)):
                    if nums[k] not in set_n:
                        ans += 1
                set_n.remove(nums[j])
        return ans
",True
Divide Players Into Teams of Equal Skill,"You are given a positive integer array skill of even length n where skill[i] denotes the skill of the ith player. Divide the players into n / 2 teams of size 2 such that the total skill of each team is equal.
The chemistry of a team is equal to the product of the skills of the players on that team.
Return the sum of the chemistry of all the teams, or return -1 if there is no way to divide the players into teams such that the total skill of each team is equal.
","Example 1:
Input: skill = [3,2,5,1,3,4]
Output: 22
Explanation: 
Divide the players into the following teams: (1, 5), (2, 4), (3, 3), where each team has a total skill of 6.
The sum of the chemistry of all the teams is: 1 * 5 + 2 * 4 + 3 * 3 = 5 + 8 + 9 = 22.
Example 2:
Input: skill = [3,4]
Output: 12
Explanation: 
The two players form a team with a total skill of 7.
The chemistry of the team is 3 * 4 = 12.
Example 3:
Input: skill = [1,1,2,3]
Output: -1
Explanation: 
There is no way to divide the players into teams such that the total skill of each team is equal.
","class Solution:
    def dividePlayers(self, skill: List[int]) -> int:
        n = len(skill)
        skill.sort()
        res = 0
        for i in range(0, n//2):
            if skill[i] + skill[n-i-1] != skill[0] + skill[-1]:
                return -1
            res += (skill[i] * skill[n-i-1])
        return res
        ",True
Delete Greatest Value in Each Row,"You are given an m x n matrix grid consisting of positive integers.
Perform the following operation until grid becomes empty:
Delete the element with the greatest value from each row. If multiple such elements exist, delete any of them.
Add the maximum of deleted elements to the answer.
Note that the number of columns decreases by one after each operation.
Return the answer after performing the operations described above.
","Example 1:

Input: grid = [[1,2,4],[3,3,1]]
Output: 8
Explanation: The diagram above shows the removed values in each step.
- In the first operation, we remove 4 from the first row and 3 from the second row (notice that, there are two cells with value 3 and we can remove any of them). We add 4 to the answer.
- In the second operation, we remove 2 from the first row and 3 from the second row. We add 3 to the answer.
- In the third operation, we remove 1 from the first row and 1 from the second row. We add 1 to the answer.
The final answer = 4 + 3 + 1 = 8.
Example 2:

Input: grid = [[10]]
Output: 10
Explanation: The diagram above shows the removed values in each step.
- In the first operation, we remove 10 from the first row. We add 10 to the answer.
The final answer = 10.
","class Solution {
public:
    static bool cmp(int a , int b){
        return a>b;
    }
    int deleteGreatestValue(vector<vector<int>>& grid) {
        int ans = 0;
        
        vector<vector<int>> mat = grid;
        
        
        for(int i=0 ; i<grid.size() ; i++){
            sort(mat[i].begin() , mat[i].end() , cmp);
        }
        
        for(int j=0 ; j<mat[0].size() ; j++){
            vector<int> tmp(mat.size());
            for(int i=0 ; i<mat.size() ; i++){
               
                tmp.push_back(mat[i][j]);
            }
           
            sort(tmp.begin() , tmp.end() , cmp);
            
            ans = ans + tmp[0];
        }
        return ans;
    }
};",False
Longest Square Streak in an Array,"You are given an integer array nums. A subsequence of nums is called a square streak if:
The length of the subsequence is at least 2, and
after sorting the subsequence, each element (except the first element) is the square of the previous number.
Return the length of the longest square streak in nums, or return -1 if there is no square streak.
A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.
","Example 1:
Input: nums = [4,3,6,16,8,2]
Output: 3
Explanation: Choose the subsequence [4,16,2]. After sorting it, it becomes [2,4,16].
- 4 = 2 * 2.
- 16 = 4 * 4.
Therefore, [4,16,2] is a square streak.
It can be shown that every subsequence of length 4 is not a square streak.
Example 2:
Input: nums = [2,3,5,6,7]
Output: -1
Explanation: There is no square streak in nums so return -1.
","class Solution:
    def longestSquareStreak(self, nums: List[int]) -> int:
        dp = defaultdict(int)
        for x in sorted(nums): 
            dp[x] = max(dp[x], 1)
            v = isqrt(x)
            if v**2 == x: dp[x] = 1 + dp[v]
        ans = max(dp.values())
        return ans if ans > 1 else -1",True
Design Memory Allocator,"You are given an integer n representing the size of a 0-indexed memory array. All memory units are initially free.
You have a memory allocator with the following functionalities:
Allocate a block of size consecutive free memory units and assign it the id mID.
Free all memory units with the given id mID.
Note that:
Multiple blocks can be allocated to the same mID.
You should free all the memory units with mID, even if they were allocated in different blocks.
Implement the Allocator class:
Allocator(int n) Initializes an Allocator object with a memory array of size n.
int allocate(int size, int mID) Find the leftmost block of size consecutive free memory units and allocate it with the id mID. Return the block's first index. If such a block does not exist, return -1.
int free(int mID) Free all memory units with the id mID. Return the number of memory units you have freed.
","Example 1:
Input
[""Allocator"", ""allocate"", ""allocate"", ""allocate"", ""free"", ""allocate"", ""allocate"", ""allocate"", ""free"", ""allocate"", ""free""]
[[10], [1, 1], [1, 2], [1, 3], [2], [3, 4], [1, 1], [1, 1], [1], [10, 2], [7]]
Output
[null, 0, 1, 2, 1, 3, 1, 6, 3, -1, 0]

Explanation
Allocator loc = new Allocator(10); // Initialize a memory array of size 10. All memory units are initially free.
loc.allocate(1, 1); // The leftmost block's first index is 0. The memory array becomes [1,_,_,_,_,_,_,_,_,_]. We return 0.
loc.allocate(1, 2); // The leftmost block's first index is 1. The memory array becomes [1,2,_,_,_,_,_,_,_,_]. We return 1.
loc.allocate(1, 3); // The leftmost block's first index is 2. The memory array becomes [1,2,3,_,_,_,_,_,_,_]. We return 2.
loc.free(2); // Free all memory units with mID 2. The memory array becomes [1,_, 3,_,_,_,_,_,_,_]. We return 1 since there is only 1 unit with mID 2.
loc.allocate(3, 4); // The leftmost block's first index is 3. The memory array becomes [1,_,3,4,4,4,_,_,_,_]. We return 3.
loc.allocate(1, 1); // The leftmost block's first index is 1. The memory array becomes [1,1,3,4,4,4,_,_,_,_]. We return 1.
loc.allocate(1, 1); // The leftmost block's first index is 6. The memory array becomes [1,1,3,4,4,4,1,_,_,_]. We return 6.
loc.free(1); // Free all memory units with mID 1. The memory array becomes [_,_,3,4,4,4,_,_,_,_]. We return 3 since there are 3 units with mID 1.
loc.allocate(10, 2); // We can not find any free block with 10 consecutive free memory units, so we return -1.
loc.free(7); // Free all memory units with mID 7. The memory array remains the same since there is no memory unit with mID 7. We return 0.
",,False
Maximum Value of a String in an Array,"The value of an alphanumeric string can be defined as:
The numeric representation of the string in base 10, if it comprises of digits only.
The length of the string, otherwise.
Given an array strs of alphanumeric strings, return the maximum value of any string in strs.
","Example 1:
Input: strs = [""alic3"",""bob"",""3"",""4"",""00000""]
Output: 5
Explanation: 
- ""alic3"" consists of both letters and digits, so its value is its length, i.e. 5.
- ""bob"" consists only of letters, so its value is also its length, i.e. 3.
- ""3"" consists only of digits, so its value is its numeric equivalent, i.e. 3.
- ""4"" also consists only of digits, so its value is 4.
- ""00000"" consists only of digits, so its value is 0.
Hence, the maximum value is 5, of ""alic3"".
Example 2:
Input: strs = [""1"",""01"",""001"",""0001""]
Output: 1
Explanation: 
Each string in the array has value 1. Hence, we return 1.
","class Solution:
    def maximumValue(self, s: List[str]) -> int:
        n=len(s)
        for i in range(n):
            if s[i].isnumeric():
                s[i]=int(s[i])
            else:
                s[i]=len(s[i])
        return max(s)",True
Maximum Star Sum of a Graph,"There is an undirected graph consisting of n nodes numbered from 0 to n - 1. You are given a 0-indexed integer array vals of length n where vals[i] denotes the value of the ith node.
You are also given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting nodes ai and bi.
A star graph is a subgraph of the given graph having a center node containing 0 or more neighbors. In other words, it is a subset of edges of the given graph such that there exists a common node for all edges.
The image below shows star graphs with 3 and 4 neighbors respectively, centered at the blue node.

The star sum is the sum of the values of all the nodes present in the star graph.
Given an integer k, return the maximum star sum of a star graph containing at most k edges.
","Example 1:

Input: vals = [1,2,3,4,10,-10,-20], edges = [[0,1],[1,2],[1,3],[3,4],[3,5],[3,6]], k = 2
Output: 16
Explanation: The above diagram represents the input graph.
The star graph with the maximum star sum is denoted by blue. It is centered at 3 and includes its neighbors 1 and 4.
It can be shown it is not possible to get a star graph with a sum greater than 16.
Example 2:
Input: vals = [-5], edges = [], k = 0
Output: -5
Explanation: There is only one possible star graph, which is node 0 itself.
Hence, we return -5.
","class Solution:
    def maxStarSum(self, v: List[int], edges: List[List[int]], k: int) -> int:
        n = len(v)
        g = defaultdict(list)
        for s,d in edges:
            g[s].append([v[d],d])
            g[d].append([v[s],s])
        
        ms = -inf
        
        for z in range(n):
            if g[z]:
                g[z].sort(reverse=True)

                cs = v[z]
                c = k
                for j in range(len(g[z])):

                    if g[z][j][0] > 0:
                        cs += g[z][j][0]
                        c = c-1

                        if c == 0: break

                    else: break
                    
                ms = max(ms,cs)
                
        
        if ms == -inf:
            return max(v)
        else:
            return ms",True
Frog Jump II,"You are given a 0-indexed integer array stones sorted in strictly increasing order representing the positions of stones in a river.
A frog, initially on the first stone, wants to travel to the last stone and then return to the first stone. However, it can jump to any stone at most once.
The length of a jump is the absolute difference between the position of the stone the frog is currently on and the position of the stone to which the frog jumps.
More formally, if the frog is at stones[i] and is jumping to stones[j], the length of the jump is |stones[i] - stones[j]|.
The cost of a path is the maximum length of a jump among all jumps in the path.
Return the minimum cost of a path for the frog.
","Example 1:

Input: stones = [0,2,5,6,7]
Output: 5
Explanation: The above figure represents one of the optimal paths the frog can take.
The cost of this path is 5, which is the maximum length of a jump.
Since it is not possible to achieve a cost of less than 5, we return it.
Example 2:

Input: stones = [0,3,9]
Output: 9
Explanation: 
The frog can jump directly to the last stone and come back to the first stone. 
In this case, the length of each jump will be 9. The cost for the path will be max(9, 9) = 9.
It can be shown that this is the minimum achievable cost.
","class Solution:
    def maxJump(self, stones: List[int]) -> int:
        if len(stones) == 2:
            return (stones[-1] - stones[0])
        maxjump = 0
        i, j = 0, 2
        while j < len(stones):
            maxjump = max(maxjump, (stones[j] - stones[i]))
            i+= 1; j+= 1
        return maxjump
        ",True
Maximum Tastiness of Candy Basket,"You are given an array of positive integers price where price[i] denotes the price of the ith candy and a positive integer k.
The store sells baskets of k distinct candies. The tastiness of a candy basket is the smallest absolute difference of the prices of any two candies in the basket.
Return the maximum tastiness of a candy basket.
","Example 1:
Input: price = [13,5,1,8,21,2], k = 3
Output: 8
Explanation: Choose the candies with the prices [13,5,21].
The tastiness of the candy basket is: min(|13 - 5|, |13 - 21|, |5 - 21|) = min(8, 8, 16) = 8.
It can be proven that 8 is the maximum tastiness that can be achieved.
Example 2:
Input: price = [1,3,1], k = 2
Output: 2
Explanation: Choose the candies with the prices [1,3].
The tastiness of the candy basket is: min(|1 - 3|) = min(2) = 2.
It can be proven that 2 is the maximum tastiness that can be achieved.
Example 3:
Input: price = [7,7,7,7], k = 2
Output: 0
Explanation: Choosing any two distinct candies from the candies we have will result in a tastiness of 0.
","class Solution:
    def maximumTastiness(self, price: List[int], k: int) -> int:
        # Trivial case of 2 candies
        # is is also the maximal possible distance for later binary search right bound
        rightDistanceBound = max(price) - min(price)
        if k == 2:
            return rightDistanceBound

        # sort the candies to ""spread"" them
        price.sort()

        # trivial case when all candies need to be taken
        if k == len(price):
            minimalCandyDistance = rightDistanceBound
            it = iter(price)
            previousPrice = next(it)
            for currentPrice in it:
                distance = currentPrice - previousPrice
                previousPrice = currentPrice
                if distance < minimalCandyDistance:
                    minimalCandyDistance = distance
            return minimalCandyDistance

        # left bound of the binary search
        leftDistanceBound = 0

        # if keep track of the maximal result once k candies are found
        maxResult = 0
        # binary sarch
        while leftDistanceBound < rightDistanceBound:
            # take the middle
            midDistance = (leftDistanceBound + rightDistanceBound) >> 1
            # track the minimal distance as we pick the candies
            minimalCandyDistance = rightDistanceBound
            # pick the first candy
            pickedCandies = 1  # picked so far
            it = iter(price)
            previousPrice = next(it)  # previously picked candy
            for currentPrice in it:
                # make sure the next candy is at least m steps away from the previous
                distance = currentPrice - previousPrice
                if distance >= midDistance:
                    # update the minimalDistance observed in this search
                    if distance < minimalCandyDistance:
                        minimalCandyDistance = distance
                    # update counts and the previous candy
                    pickedCandies += 1
                    previousPrice = currentPrice
                    # if k candies are picked
                    if pickedCandies == k:
                        # update the result if larger
                        if minimalCandyDistance > maxResult:
                            maxResult = minimalCandyDistance
                        # try to increase the distance in the next round
                        leftDistanceBound = midDistance + 1
                        break
            else:
                # No break from the loop, less than k candies, decrease the distance for the next round
                rightDistanceBound = midDistance
        return maxResult",True
Maximum Enemy Forts That Can Be Captured,"You are given a 0-indexed integer array forts of length n representing the positions of several forts. forts[i] can be -1, 0, or 1 where:
-1 represents there is no fort at the ith position.
0 indicates there is an enemy fort at the ith position.
1 indicates the fort at the ith the position is under your command.
Now you have decided to move your army from one of your forts at position i to an empty position j such that:
0 <= i, j <= n - 1
The army travels over enemy forts only. Formally, for all k where min(i,j) < k < max(i,j), forts[k] == 0.
While moving the army, all the enemy forts that come in the way are captured.
Return the maximum number of enemy forts that can be captured. In case it is impossible to move your army, or you do not have any fort under your command, return 0.
","Example 1:
Input: forts = [1,0,0,-1,0,0,0,0,1]
Output: 4
Explanation:
- Moving the army from position 0 to position 3 captures 2 enemy forts, at 1 and 2.
- Moving the army from position 8 to position 3 captures 4 enemy forts.
Since 4 is the maximum number of enemy forts that can be captured, we return 4.
Example 2:
Input: forts = [0,0,1,-1]
Output: 0
Explanation: Since no enemy fort can be captured, 0 is returned.
","class Solution:
    def captureForts(self, forts: List[int]) -> int:
        indx = 0
        count = 0
        prev = 0
        ans = 0
        for i in range(len(forts)):
            if forts[i]!=0:
                prev = forts[i]
                indx = i
                break
                
        for i in range(indx+1, len(forts)):
            if forts[i] == 0:
                count += 1
            else:
                if (forts[i] == 1 and prev == -1) or (forts[i] == -1 and prev == 1):
                    ans = max(ans, count)
                    count = 0
                    prev = forts[i]
                else:
                    count = 0
        
        return ans
            ",True
Reward Top K Students,"You are given two string arrays positive_feedback and negative_feedback, containing the words denoting positive and negative feedback, respectively. Note that no word is both positive and negative.
Initially every student has 0 points. Each positive word in a feedback report increases the points of a student by 3, whereas each negative word decreases the points by 1.
You are given n feedback reports, represented by a 0-indexed string array report and a 0-indexed integer array student_id, where student_id[i] represents the ID of the student who has received the feedback report report[i]. The ID of each student is unique.
Given an integer k, return the top k students after ranking them in non-increasing order by their points. In case more than one student has the same points, the one with the lower ID ranks higher.
","Example 1:
Input: positive_feedback = [""smart"",""brilliant"",""studious""], negative_feedback = [""not""], report = [""this student is studious"",""the student is smart""], student_id = [1,2], k = 2
Output: [1,2]
Explanation: 
Both the students have 1 positive feedback and 3 points but since student 1 has a lower ID he ranks higher.
Example 2:
Input: positive_feedback = [""smart"",""brilliant"",""studious""], negative_feedback = [""not""], report = [""this student is not studious"",""the student is smart""], student_id = [1,2], k = 2
Output: [2,1]
Explanation: 
- The student with ID 1 has 1 positive feedback and 1 negative feedback, so he has 3-1=2 points. 
- The student with ID 2 has 1 positive feedback, so he has 3 points. 
Since student 2 has more points, [2,1] is returned.
","class Solution: 
    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:
        positive_feedback = set(positive_feedback)
        negative_feedback = set(negative_feedback)
        mp = {}
        for sentence, id in zip(report, student_id): 
            point = 0 
            for word in sentence.split(): 
                if word in positive_feedback: point += 3
                elif word in negative_feedback: point -= 1
            mp[id] = point 
        return sorted(mp, key=lambda x: (-mp[x], x))[:k]",True
Minimum Operations to Make Array Equal II,"You are given two integer arrays nums1 and nums2 of equal length n and an integer k. You can perform the following operation on nums1:
Choose two indexes i and j and increment nums1[i] by k and decrement nums1[j] by k. In other words, nums1[i] = nums1[i] + k and nums1[j] = nums1[j] - k.
nums1 is said to be equal to nums2 if for all indices i such that 0 <= i < n, nums1[i] == nums2[i].
Return the minimum number of operations required to make nums1 equal to nums2. If it is impossible to make them equal, return -1.
","Example 1:
Input: nums1 = [4,3,1,4], nums2 = [1,3,7,1], k = 3
Output: 2
Explanation: In 2 operations, we can transform nums1 to nums2.
1st operation: i = 2, j = 0. After applying the operation, nums1 = [1,3,4,4].
2nd operation: i = 2, j = 3. After applying the operation, nums1 = [1,3,7,1].
One can prove that it is impossible to make arrays equal in fewer operations.
Example 2:
Input: nums1 = [3,8,5,2], nums2 = [2,4,1,6], k = 1
Output: -1
Explanation: It can be proved that it is impossible to make the two arrays equal.
","class Solution {
    public long minOperations(int[] nums1, int[] nums2, int k) {
        long diff = 0;
        long sum = 0;
        long ans = -1;
        for(int i = 0; i<nums1.length; i++)
        {
            if((Math.abs(nums1[i]-nums2[i])!=0 && Math.abs(nums1[i]-nums2[i]) < k ) ||((k!=0)&&(Math.abs(nums1[i]-nums2[i])%k) !=0))
            {
            return -1;
            }
            diff += (nums1[i] - nums2[i]);
            sum+= Math.abs(nums1[i] - nums2[i]);
        }
        if( diff == 0 && k!=0)
        {
            if(sum % (k*2) == 0 && sum >=(k*2))
            {
                sum = sum/2;
                ans = sum/k;
            }
            else if (sum == 0 && diff == 0)
            {
                ans = 0;
            }
            else
            {
                ans = -1;
            }
        }
        else
        {
            if(sum == 0 && diff == 0)
            {
                ans = 0;
            }
            else if(diff != 0 && k !=0)
            {
                ans = -1;
            }
            else if(diff == 0 && (k == 0&&sum!=0))
            {
                ans = -1;
            }
        }
        return ans;
    }
}",False
Difference Between Ones and Zeros in Row and Column,"You are given a 0-indexed m x n binary matrix grid.
A 0-indexed m x n difference matrix diff is created with the following procedure:
Let the number of ones in the ith row be onesRowi.
Let the number of ones in the jth column be onesColj.
Let the number of zeros in the ith row be zerosRowi.
Let the number of zeros in the jth column be zerosColj.
diff[i][j] = onesRowi + onesColj - zerosRowi - zerosColj
Return the difference matrix diff.
","Example 1:

Input: grid = [[0,1,1],[1,0,1],[0,0,1]]
Output: [[0,0,4],[0,0,4],[-2,-2,2]]
Explanation:
- diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0 = 2 + 1 - 1 - 2 = 0 
- diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1 = 2 + 1 - 1 - 2 = 0 
- diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2 = 2 + 3 - 1 - 0 = 4 
- diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0 = 2 + 1 - 1 - 2 = 0 
- diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1 = 2 + 1 - 1 - 2 = 0 
- diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2 = 2 + 3 - 1 - 0 = 4 
- diff[2][0] = onesRow2 + onesCol0 - zerosRow2 - zerosCol0 = 1 + 1 - 2 - 2 = -2
- diff[2][1] = onesRow2 + onesCol1 - zerosRow2 - zerosCol1 = 1 + 1 - 2 - 2 = -2
- diff[2][2] = onesRow2 + onesCol2 - zerosRow2 - zerosCol2 = 1 + 3 - 2 - 0 = 2
Example 2:

Input: grid = [[1,1,1],[1,1,1]]
Output: [[5,5,5],[5,5,5]]
Explanation:
- diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0 = 3 + 2 - 0 - 0 = 5
- diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1 = 3 + 2 - 0 - 0 = 5
- diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2 = 3 + 2 - 0 - 0 = 5
- diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0 = 3 + 2 - 0 - 0 = 5
- diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1 = 3 + 2 - 0 - 0 = 5
- diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2 = 3 + 2 - 0 - 0 = 5
","class Solution:
    def onesMinusZeros(self, grid: List[List[int]]) -> List[List[int]]:
        lis = [ [0]*len(grid[0]) for i in range(len(grid))]
        # grid1 = [ [0]*len(grid[0]) for i in range(len(grid))]
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 0:
                    grid[i][j] =-1
        
                
        
        
        rows = {}
        cols = {}
        ele = 0
        for i in range(len(grid)):
            rows[i] = sum(grid[i])
        
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if j not in cols:
                    cols[j] = grid[i][j] 
                else:
                    cols[j] += grid[i][j] 
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                ele = rows[i]+cols[j]
                lis[i][j] = ele
            
        return lis
        ",True
Distinct Prime Factors of Product of Array,"Given an array of positive integers nums, return the number of distinct prime factors in the product of the elements of nums.
Note that:
A number greater than 1 is called prime if it is divisible by only 1 and itself.
An integer val1 is a factor of another integer val2 if val2 / val1 is an integer.
","Example 1:
Input: nums = [2,4,3,7,10,6]
Output: 4
Explanation:
The product of all the elements in nums is: 2 * 4 * 3 * 7 * 10 * 6 = 10080 = 25 * 32 * 5 * 7.
There are 4 distinct prime factors so we return 4.
Example 2:
Input: nums = [2,4,8,16]
Output: 1
Explanation:
The product of all the elements in nums is: 2 * 4 * 8 * 16 = 1024 = 210.
There is 1 distinct prime factor so we return 1.
","class Solution:
    def distinctPrimeFactors(self, nums: List[int]) -> int:

        seen, primes = set(), {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31} 
         
        for num in nums:
            for p in primes:

                r = num%p
                if p not in seen and not r: seen.add(p)

                while not r:
                    num//= p
                    r = num%p

            if num > 1: seen.add(num) 

        return len(seen)
",True
Maximum Count of Positive Integer and Negative Integer,"Given an array nums sorted in non-decreasing order, return the maximum between the number of positive integers and the number of negative integers.
In other words, if the number of positive integers in nums is pos and the number of negative integers is neg, then return the maximum of pos and neg.
Note that 0 is neither positive nor negative.
","Example 1:
Input: nums = [-2,-1,-1,1,2,3]
Output: 3
Explanation: There are 3 positive integers and 3 negative integers. The maximum count among them is 3.
Example 2:
Input: nums = [-3,-2,-1,0,0,1,2]
Output: 3
Explanation: There are 2 positive integers and 3 negative integers. The maximum count among them is 3.
Example 3:
Input: nums = [5,20,66,1314]
Output: 4
Explanation: There are 4 positive integers and 0 negative integers. The maximum count among them is 4.
","class Solution:
    def maximumCount(self, nums: List[int]) -> int:
        l1 = list(filter(lambda x: x>0, nums))
        l2 = list(filter(lambda x: x<0, nums))
        return max(len(l1),len(l2))",True
Maximal Score After Applying K Operations,"You are given a 0-indexed integer array nums and an integer k. You have a starting score of 0.
In one operation:
choose an index i such that 0 <= i < nums.length,
increase your score by nums[i], and
replace nums[i] with ceil(nums[i] / 3).
Return the maximum possible score you can attain after applying exactly k operations.
The ceiling function ceil(val) is the least integer greater than or equal to val.
","Example 1:
Input: nums = [10,10,10,10,10], k = 5
Output: 50
Explanation: Apply the operation to each array element exactly once. The final score is 10 + 10 + 10 + 10 + 10 = 50.
Example 2:
Input: nums = [1,10,3,3,3], k = 3
Output: 17
Explanation: You can do the following operations:
Operation 1: Select i = 1, so nums becomes [1,4,3,3,3]. Your score increases by 10.
Operation 2: Select i = 1, so nums becomes [1,2,3,3,3]. Your score increases by 4.
Operation 3: Select i = 2, so nums becomes [1,1,1,3,3]. Your score increases by 3.
The final score is 10 + 4 + 3 = 17.
","class Solution:
    def maxKelements(self, nums: List[int], k: int) -> int:
        heapq._heapify_max(nums)
        ans=0
        for _ in range(k):
            ans += nums[0]
            heapq._heapreplace_max(nums, (nums[0]+2)//3)
        return ans",True
Find Xor-Beauty of Array,"You are given a 0-indexed integer array nums.
The effective value of three indices i, j, and k is defined as ((nums[i] | nums[j]) & nums[k]).
The xor-beauty of the array is the XORing of the effective values of all the possible triplets of indices (i, j, k) where 0 <= i, j, k < n.
Return the xor-beauty of nums.
Note that:
val1 | val2 is bitwise OR of val1 and val2.
val1 & val2 is bitwise AND of val1 and val2.
","Example 1:
Input: nums = [1,4]
Output: 5
Explanation: 
The triplets and their corresponding effective values are listed below:
- (0,0,0) with effective value ((1 | 1) & 1) = 1
- (0,0,1) with effective value ((1 | 1) & 4) = 0
- (0,1,0) with effective value ((1 | 4) & 1) = 1
- (0,1,1) with effective value ((1 | 4) & 4) = 4
- (1,0,0) with effective value ((4 | 1) & 1) = 1
- (1,0,1) with effective value ((4 | 1) & 4) = 4
- (1,1,0) with effective value ((4 | 4) & 1) = 0
- (1,1,1) with effective value ((4 | 4) & 4) = 4 
Xor-beauty of array will be bitwise XOR of all beauties = 1 ^ 0 ^ 1 ^ 4 ^ 1 ^ 4 ^ 0 ^ 4 = 5.
Example 2:
Input: nums = [15,45,20,2,34,35,5,44,32,30]
Output: 34
Explanation: The xor-beauty of the given array is 34.
",,False
Difference Between Element Sum and Digit Sum of an Array,"You are given a positive integer array nums.
The element sum is the sum of all the elements in nums.
The digit sum is the sum of all the digits (not necessarily distinct) that appear in nums.
Return the absolute difference between the element sum and digit sum of nums.
Note that the absolute difference between two integers x and y is defined as |x - y|.
","Example 1:
Input: nums = [1,15,6,3]
Output: 9
Explanation: 
The element sum of nums is 1 + 15 + 6 + 3 = 25.
The digit sum of nums is 1 + 1 + 5 + 6 + 3 = 16.
The absolute difference between the element sum and digit sum is |25 - 16| = 9.
Example 2:
Input: nums = [1,2,3,4]
Output: 0
Explanation:
The element sum of nums is 1 + 2 + 3 + 4 = 10.
The digit sum of nums is 1 + 2 + 3 + 4 = 10.
The absolute difference between the element sum and digit sum is |10 - 10| = 0.
","class Solution {
public:
    int differenceOfSum(vector<int>& nums) {
        int tsum = accumulate(nums.begin(),nums.end(),0);

        int digitSum = 0;

        for(auto x : nums){
            while(x){
                int rem = x % 10;
                digitSum+= rem;
                x = x/10;
            }
        }

        return abs(tsum - digitSum);
    }
};",False
Increment Submatrices by One,"You are given a positive integer n, indicating that we initially have an n x n 0-indexed integer matrix mat filled with zeroes.
You are also given a 2D integer array query. For each query[i] = [row1i, col1i, row2i, col2i], you should do the following operation:
Add 1 to every element in the submatrix with the top left corner (row1i, col1i) and the bottom right corner (row2i, col2i). That is, add 1 to mat[x][y] for all row1i <= x <= row2i and col1i <= y <= col2i.
Return the matrix mat after performing every query.
","Example 1:

Input: n = 3, queries = [[1,1,2,2],[0,0,1,1]]
Output: [[1,1,0],[1,2,1],[0,1,1]]
Explanation: The diagram above shows the initial matrix, the matrix after the first query, and the matrix after the second query.
- In the first query, we add 1 to every element in the submatrix with the top left corner (1, 1) and bottom right corner (2, 2).
- In the second query, we add 1 to every element in the submatrix with the top left corner (0, 0) and bottom right corner (1, 1).
Example 2:

Input: n = 2, queries = [[0,0,1,1]]
Output: [[1,1],[1,1]]
Explanation: The diagram above shows the initial matrix and the matrix after the first query.
- In the first query we add 1 to every element in the matrix.
","class Solution:
    def rangeAddQueries(self, n: int, queries: List[List[int]]) -> List[List[int]]:
        ans = [[0] * n for _ in range(n)]
        for r1, c1, r2, c2 in queries:
            ans[r1][c1] += 1
            if r2 + 1 < n: ans[r2 + 1][c1] -= 1
            if c2 + 1 < n: ans[r1][c2 + 1] -= 1
            if r2 + 1 < n and c2 + 1 < n: ans[r2 + 1][c2 + 1] += 1
        for r in range(1, n):
            for c in range(n):
                ans[r][c] += ans[r - 1][c]
        for r in range(n):
            for c in range(1, n):
                ans[r][c] += ans[r][c - 1]
        return ans",True
Count the Number of Good Subarrays,"Given an integer array nums and an integer k, return the number of good subarrays of nums.
A subarray arr is good if it there are at least k pairs of indices (i, j) such that i < j and arr[i] == arr[j].
A subarray is a contiguous non-empty sequence of elements within an array.
","Example 1:
Input: nums = [1,1,1,1,1], k = 10
Output: 1
Explanation: The only good subarray is the array nums itself.
Example 2:
Input: nums = [3,1,4,3,2,2,4], k = 2
Output: 4
Explanation: There are 4 different good subarrays:
- [3,1,4,3,2,2] that has 2 pairs.
- [3,1,4,3,2,2,4] that has 3 pairs.
- [1,4,3,2,2,4] that has 2 pairs.
- [4,3,2,2,4] that has 2 pairs.
","class Solution(object):
    def countGood(self, nums, k):
        """"""
        :type nums: List[int]
        :type k: int
        :rtype: int
        """"""
        elements_in_current_window=dict()
        pair_count=0
        start=0
        end=0
        ans=0
        while(end<len(nums)):
            if(elements_in_current_window.has_key(nums[end])):
                elements_in_current_window[nums[end]]+=1 #incrementing 
            else:
                elements_in_current_window[nums[end]]=1 #initializing entry in the dictionary
            pair_count+=elements_in_current_window[nums[end]]-1 #counting number of pairs
            while pair_count>=k: #The shrinking phase
                ans+=1+len(nums)-end-1 #the number of new sequences
                elements_in_current_window[nums[start]]-=1 #remove the element at the starting of the window
                pair_count-=elements_in_current_window[nums[start]]
                start+=1
            end+=1    
        return ans            
            
        ",True
Sort the Students by Their Kth Score,"There is a class with m students and n exams. You are given a 0-indexed m x n integer matrix score, where each row represents one student and score[i][j] denotes the score the ith student got in the jth exam. The matrix score contains distinct integers only.
You are also given an integer k. Sort the students (i.e., the rows of the matrix) by their scores in the kth (0-indexed) exam from the highest to the lowest.
Return the matrix after sorting it.
","Example 1:

Input: score = [[10,6,9,1],[7,5,11,2],[4,8,3,15]], k = 2
Output: [[7,5,11,2],[10,6,9,1],[4,8,3,15]]
Explanation: In the above diagram, S denotes the student, while E denotes the exam.
- The student with index 1 scored 11 in exam 2, which is the highest score, so they got first place.
- The student with index 0 scored 9 in exam 2, which is the second highest score, so they got second place.
- The student with index 2 scored 3 in exam 2, which is the lowest score, so they got third place.
Example 2:

Input: score = [[3,4],[5,6]], k = 0
Output: [[5,6],[3,4]]
Explanation: In the above diagram, S denotes the student, while E denotes the exam.
- The student with index 1 scored 5 in exam 0, which is the highest score, so they got first place.
- The student with index 0 scored 3 in exam 0, which is the lowest score, so they got second place.
","class Solution:
    def sortTheStudents(self, score: List[List[int]], k: int) -> List[List[int]]:
        col={j[k]:i for i,j in enumerate(score)}
        x=sorted(col.items(),key=lambda col:col[0])
        a=[]
        while x:
            c=(score[x.pop()[1]])
            a.append(c)
        return a",True
Minimum Common Value,"Given two integer arrays nums1 and nums2, sorted in non-decreasing order, return the minimum integer common to both arrays. If there is no common integer amongst nums1 and nums2, return -1.
Note that an integer is said to be common to nums1 and nums2 if both arrays have at least one occurrence of that integer.
","Example 1:
Input: nums1 = [1,2,3], nums2 = [2,4]
Output: 2
Explanation: The smallest element common to both arrays is 2, so we return 2.
Example 2:
Input: nums1 = [1,2,3,6], nums2 = [2,3,4,5]
Output: 2
Explanation: There are two common elements in the array 2 and 3 out of which 2 is the smallest, so 2 is returned.
","class Solution {
public:
    int getCommon(vector<int>& nums1, vector<int>& nums2) {
        int l1 = 0, l2 = 0, r1 = nums1.size()-1, r2 = nums2.size()-1;
        
        while(l1 <= r1 && l2 <= r2) {
            if(nums1[l1] == nums2[l2]) {
                return nums1[l1];
            }
            
            if(nums1[l1] < nums2[l2]) {
                l1++;
            } else {
                l2++;
            }
            
            if(nums1[r1] < nums2[r2]) {
                r2--;
            } else if(nums1[r1] == nums2[r2]) {
                // do nothing
            } else {
                r1--;
            }
        }
        
        return -1;
    }
};",False
Separate the Digits in an Array,"Given an array of positive integers nums, return an array answer that consists of the digits of each integer in nums after separating them in the same order they appear in nums.
To separate the digits of an integer is to get all the digits it has in the same order.
For example, for the integer 10921, the separation of its digits is [1,0,9,2,1].
","Example 1:
Input: nums = [13,25,83,77]
Output: [1,3,2,5,8,3,7,7]
Explanation: 
- The separation of 13 is [1,3].
- The separation of 25 is [2,5].
- The separation of 83 is [8,3].
- The separation of 77 is [7,7].
answer = [1,3,2,5,8,3,7,7]. Note that answer contains the separations in the same order.
Example 2:
Input: nums = [7,1,3,9]
Output: [7,1,3,9]
Explanation: The separation of each integer in nums is itself.
answer = [7,1,3,9].
","class Solution:
    def separateDigits(self, nums: List[int]) -> List[int]:
        lst=[]
        for i in nums:
            t=[]
            while(i>0):
                d=i%10
                t.append(d)
                i=i//10
            t.reverse()
            lst.extend(t)
        return lst",True
Maximum Number of Integers to Choose From a Range I,"You are given an integer array banned and two integers n and maxSum. You are choosing some number of integers following the below rules:
The chosen integers have to be in the range [1, n].
Each integer can be chosen at most once.
The chosen integers should not be in the array banned.
The sum of the chosen integers should not exceed maxSum.
Return the maximum number of integers you can choose following the mentioned rules.
","Example 1:
Input: banned = [1,6,5], n = 5, maxSum = 6
Output: 2
Explanation: You can choose the integers 2 and 4.
2 and 4 are from the range [1, 5], both did not appear in banned, and their sum is 6, which did not exceed maxSum.
Example 2:
Input: banned = [1,2,3,4,5,6,7], n = 8, maxSum = 1
Output: 0
Explanation: You cannot choose any integer while following the mentioned conditions.
Example 3:
Input: banned = [11], n = 7, maxSum = 50
Output: 7
Explanation: You can choose the integers 1, 2, 3, 4, 5, 6, and 7.
They are from the range [1, 7], all did not appear in banned, and their sum is 28, which did not exceed maxSum.
","class Solution:
    def maxCount(self, banned: List[int], n: int, maxSum: int) -> int:
        arr = set(i for i in range(1, n + 1))
        x = arr - set(banned)
        x = sorted(list(x))
        cnt = 0
        cntt = 0
        i = 0
        while cnt <= maxSum and i != len(x):
            cnt += x[i]
            i += 1
        if cnt > maxSum:
            return i - 1
        return i",True
Count the Number of Vowel Strings in Range,"You are given a 0-indexed array of string words and two integers left and right.
A string is called a vowel string if it starts with a vowel character and ends with a vowel character where vowel characters are 'a', 'e', 'i', 'o', and 'u'.
Return the number of vowel strings words[i] where i belongs to the inclusive range [left, right].
","Example 1:
Input: words = [""are"",""amy"",""u""], left = 0, right = 2
Output: 2
Explanation: 
- ""are"" is a vowel string because it starts with 'a' and ends with 'e'.
- ""amy"" is not a vowel string because it does not end with a vowel.
- ""u"" is a vowel string because it starts with 'u' and ends with 'u'.
The number of vowel strings in the mentioned range is 2.
Example 2:
Input: words = [""hey"",""aeo"",""mu"",""ooo"",""artro""], left = 1, right = 4
Output: 3
Explanation: 
- ""aeo"" is a vowel string because it starts with 'a' and ends with 'o'.
- ""mu"" is not a vowel string because it does not start with a vowel.
- ""ooo"" is a vowel string because it starts with 'o' and ends with 'o'.
- ""artro"" is a vowel string because it starts with 'a' and ends with 'o'.
The number of vowel strings in the mentioned range is 3.
","class Solution:
    def vowelStrings(self, words: List[str], left: int, right: int) -> int:
        vowels='aeiouAEIOU'
        count=0
        for i in range(left,right+1):
            if words[i][0] in vowels and words[i][-1] in vowels:
                count+=1

        return count        ",True
Rearrange Array to Maximize Prefix Score,"You are given a 0-indexed integer array nums. You can rearrange the elements of nums to any order (including the given order).
Let prefix be the array containing the prefix sums of nums after rearranging it. In other words, prefix[i] is the sum of the elements from 0 to i in nums after rearranging it. The score of nums is the number of positive integers in the array prefix.
Return the maximum score you can achieve.
","Example 1:
Input: nums = [2,-1,0,1,-3,3,-3]
Output: 6
Explanation: We can rearrange the array into nums = [2,3,1,-1,-3,0,-3].
prefix = [2,5,6,5,2,2,-1], so the score is 6.
It can be shown that 6 is the maximum score we can obtain.
Example 2:
Input: nums = [-2,-3,0]
Output: 0
Explanation: Any rearrangement of the array will result in a score of 0.
",,False
Check Knight Tour Configuration,"There is a knight on an n x n chessboard. In a valid configuration, the knight starts at the top-left cell of the board and visits every cell on the board exactly once.
You are given an n x n integer matrix grid consisting of distinct integers from the range [0, n * n - 1] where grid[row][col] indicates that the cell (row, col) is the grid[row][col]th cell that the knight visited. The moves are 0-indexed.
Return true if grid represents a valid configuration of the knight's movements or false otherwise.
Note that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.

","Example 1:

Input: grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]
Output: true
Explanation: The above diagram represents the grid. It can be shown that it is a valid configuration.
Example 2:

Input: grid = [[0,3,6],[5,8,1],[2,7,4]]
Output: false
Explanation: The above diagram represents the grid. The 8th move of the knight is not valid considering its position after the 7th move.
","class Solution:
    def checkValidGrid(self, grid: List[List[int]]) -> bool:

        n, d = len(grid), defaultdict(tuple)
        if n < 5: return n == 1

        notLegal = lambda x, y : {abs(x[0]-y[0]),
                                  abs(x[1]-y[1])} != {1,2}

        for row, col in product(range(n),range(n)):
            d[grid[row][col]] = (row,col)
        
        prev, cnt = (0,0), 1

        while cnt < n*n:
            curr = d[cnt]

            if notLegal(prev,curr):  return False

            cnt+=1
            prev = curr

        return True",True
Maximize Greatness of an Array,"You are given a 0-indexed integer array nums. You are allowed to permute nums into a new array perm of your choosing.
We define the greatness of nums be the number of indices 0 <= i < nums.length for which perm[i] > nums[i].
Return the maximum possible greatness you can achieve after permuting nums.
","Example 1:
Input: nums = [1,3,5,2,1,3,1]
Output: 4
Explanation: One of the optimal rearrangements is perm = [2,5,1,3,3,1,1].
At indices = 0, 1, 3, and 4, perm[i] > nums[i]. Hence, we return 4.
Example 2:
Input: nums = [1,2,3,4]
Output: 3
Explanation: We can prove the optimal perm is [2,3,4,1].
At indices = 0, 1, and 2, perm[i] > nums[i]. Hence, we return 3.
","class Solution {
public:
    int maximizeGreatness(vector<int>& nums) {
    sort(nums.begin(), nums.end()); // Sort nums in non-decreasing order
    int greatness = 0;
    for (auto &it : nums) { // Loop over the elements of nums
        if (it > nums[greatness]) { // If the current element is greater than the greatest element seen so far
            greatness++; // Increment the number of indices i for which perm[i] > nums[i]
        }
    }
    return greatness; // Return the maximum possible greatness
}
};
static bool     _foo = ios::sync_with_stdio(false);
static ostream* _bar = cin.tie(NULL);",False
Minimum Time to Repair Cars,"You are given an integer array ranks representing the ranks of some mechanics. ranksi is the rank of the ith mechanic. A mechanic with a rank r can repair n cars in r * n2 minutes.
You are also given an integer cars representing the total number of cars waiting in the garage to be repaired.
Return the minimum time taken to repair all the cars.
Note: All the mechanics can repair the cars simultaneously.
","Example 1:
Input: ranks = [4,2,3,1], cars = 10
Output: 16
Explanation: 
- The first mechanic will repair two cars. The time required is 4 * 2 * 2 = 16 minutes.
- The second mechanic will repair two cars. The time required is 2 * 2 * 2 = 8 minutes.
- The third mechanic will repair two cars. The time required is 3 * 2 * 2 = 12 minutes.
- The fourth mechanic will repair four cars. The time required is 1 * 4 * 4 = 16 minutes.
It can be proved that the cars cannot be repaired in less than 16 minutes.
Example 2:
Input: ranks = [5,1,8], cars = 6
Output: 16
Explanation: 
- The first mechanic will repair one car. The time required is 5 * 1 * 1 = 5 minutes.
- The second mechanic will repair four cars. The time required is 1 * 4 * 4 = 16 minutes.
- The third mechanic will repair one car. The time required is 8 * 1 * 1 = 8 minutes.
It can be proved that the cars cannot be repaired in less than 16 minutes.
",,False
Form Smallest Number From Two Digit Arrays,"unique
nums1
nums2
the smallest number that contains at least one digit from each array
","Example 1:
Input: nums1 = [4,1,3], nums2 = [5,7]
Output: 15
Explanation: The number 15 contains the digit 1 from nums1 and the digit 5 from nums2. It can be proven that 15 is the smallest number we can have.
Example 2:
Input: nums1 = [3,5,2,6], nums2 = [3,1,7]
Output: 3
Explanation: The number 3 contains the digit 3 which exists in both arrays.
","class Solution:
    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:
        nums1.sort()
        nums2.sort()
        for i in nums1:
            if i in nums2:
                return i
        ans = (str(nums1[0]) + str(nums2[0])) if nums1[0] < nums2[0] else str(nums2[0]) + str(nums1[0]) 
        ans = int(ans)
        return ans",True
Find the Substring With Maximum Cost,"You are given a string s, a string chars of distinct characters and an integer array vals of the same length as chars.
The cost of the substring is the sum of the values of each character in the substring. The cost of an empty string is considered 0.
The value of the character is defined in the following way:
If the character is not in the string chars, then its value is its corresponding position (1-indexed) in the alphabet.
For example, the value of 'a' is 1, the value of 'b' is 2, and so on. The value of 'z' is 26.
Otherwise, assuming i is the index where the character occurs in the string chars, then its value is vals[i].
Return the maximum cost among all substrings of the string s.
","Example 1:
Input: s = ""adaa"", chars = ""d"", vals = [-1000]
Output: 2
Explanation: The value of the characters ""a"" and ""d"" is 1 and -1000 respectively.
The substring with the maximum cost is ""aa"" and its cost is 1 + 1 = 2.
It can be proven that 2 is the maximum cost.
Example 2:
Input: s = ""abc"", chars = ""abc"", vals = [-1,-1,-1]
Output: 0
Explanation: The value of the characters ""a"", ""b"" and ""c"" is -1, -1, and -1 respectively.
The substring with the maximum cost is the empty substring """" and its cost is 0.
It can be proven that 0 is the maximum cost.
",,False
Find the Width of Columns of a Grid,"You are given a 0-indexed m x n integer matrix grid. The width of a column is the maximum length of its integers.
For example, if grid = [[-10], [3], [12]], the width of the only column is 3 since -10 is of length 3.
Return an integer array ans of size n where ans[i] is the width of the ith column.
The length of an integer x with len digits is equal to len if x is non-negative, and len + 1 otherwise.
","Example 1:
Input: grid = [[1],[22],[333]]
Output: [3]
Explanation: In the 0th column, 333 is of length 3.
Example 2:
Input: grid = [[-15,1,3],[15,7,12],[5,6,-2]]
Output: [3,1,2]
Explanation: 
In the 0th column, only -15 is of length 3.
In the 1st column, all integers are of length 1. 
In the 2nd column, both 12 and -2 are of length 2.
","class Solution:
    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:
        l=[0]*len(grid[0])
        for i in grid:
            for j in range(len(i)):
                x=len(str(i[j]))
                l[j]=max(x,l[j])
        return l",True
Find the Score of All Prefixes of an Array,"We define the conversion array conver of an array arr as follows:
conver[i] = arr[i] + max(arr[0..i]) where max(arr[0..i]) is the maximum value of arr[j] over 0 <= j <= i.
We also define the score of an array arr as the sum of the values of the conversion array of arr.
Given a 0-indexed integer array nums of length n, return an array ans of length n where ans[i] is the score of the prefix nums[0..i].
","Example 1:
Input: nums = [2,3,7,5,10]
Output: [4,10,24,36,56]
Explanation: 
For the prefix [2], the conversion array is [4] hence the score is 4
For the prefix [2, 3], the conversion array is [4, 6] hence the score is 10
For the prefix [2, 3, 7], the conversion array is [4, 6, 14] hence the score is 24
For the prefix [2, 3, 7, 5], the conversion array is [4, 6, 14, 12] hence the score is 36
For the prefix [2, 3, 7, 5, 10], the conversion array is [4, 6, 14, 12, 20] hence the score is 56
Example 2:
Input: nums = [1,1,2,4,8,16]
Output: [2,4,8,16,32,64]
Explanation: 
For the prefix [1], the conversion array is [2] hence the score is 2
For the prefix [1, 1], the conversion array is [2, 2] hence the score is 4
For the prefix [1, 1, 2], the conversion array is [2, 2, 4] hence the score is 8
For the prefix [1, 1, 2, 4], the conversion array is [2, 2, 4, 8] hence the score is 16
For the prefix [1, 1, 2, 4, 8], the conversion array is [2, 2, 4, 8, 16] hence the score is 32
For the prefix [1, 1, 2, 4, 8, 16], the conversion array is [2, 2, 4, 8, 16, 32] hence the score is 64
",,False
Count Distinct Numbers on Board,"You are given a positive integer n, that is initially placed on a board. Every day, for 109 days, you perform the following procedure:
For each number x present on the board, find all numbers 1 <= i <= n such that x % i == 1.
Then, place those numbers on the board.
Return the number of distinct integers present on the board after 109 days have elapsed.
Note:
Once a number is placed on the board, it will remain on it until the end.
% stands for the modulo operation. For example, 14 % 3 is 2.
","Example 1:
Input: n = 5
Output: 4
Explanation: Initially, 5 is present on the board. 
The next day, 2 and 4 will be added since 5 % 2 == 1 and 5 % 4 == 1. 
After that day, 3 will be added to the board because 4 % 3 == 1. 
At the end of a billion days, the distinct numbers on the board will be 2, 3, 4, and 5. 
Example 2:
Input: n = 3
Output: 2
Explanation: 
Since 3 % 2 == 1, 2 will be added to the board. 
After a billion days, the only two distinct numbers on the board are 2 and 3. 
","class Solution:
    def distinctIntegers(self, n: int) -> int:
      if n==1:
        return 1
      return n-1
        ",True
Determine the Winner of a Bowling Game,"You are given two 0-indexed integer arrays player1 and player2, representing the number of pins that player 1 and player 2 hit in a bowling game, respectively.
The bowling game consists of n turns, and the number of pins in each turn is exactly 10.
Assume a player hits xi pins in the ith turn. The value of the ith turn for the player is:
2xi if the player hits 10 pins in either (i - 1)th or (i - 2)th turn.
Otherwise, it is xi.
The score of the player is the sum of the values of their n turns.
Return
1 if the score of player 1 is more than the score of player 2,
2 if the score of player 2 is more than the score of player 1, and
0 in case of a draw.
","Example 1:
Input: player1 = [5,10,3,2], player2 = [6,5,7,3]
Output: 1
Explanation:
The score of player 1 is 5 + 10 + 2*3 + 2*2 = 25.
The score of player 2 is 6 + 5 + 7 + 3 = 21.
Example 2:
Input: player1 = [3,5,7,6], player2 = [8,10,10,2]
Output: 2
Explanation:
The score of player 1 is 3 + 5 + 7 + 6 = 21.
The score of player 2 is 8 + 10 + 2*10 + 2*2 = 42.
Example 3:
Input: player1 = [2,3], player2 = [4,1]
Output: 0
Explanation:
The score of player1 is 2 + 3 = 5.
The score of player2 is 4 + 1 = 5.
Example 4:
Input: player1 = [1,1,1,10,10,10,10], player2 = [10,10,10,10,1,1,1]
Output: 1
Explanation:
The score of player1 is 1 + 1 + 1 + 10 + 2*10 + 2*10 + 2*10 = 73.
The score of player2 is 10 + 2*10 + 2*10 + 2*10 + 2*1 + 2*1 + 1 = 75.
","class Solution{
    public int isWinner(int[] p1, int[] p2){
        int n = p1.length;
        int a=p1[0], b=p2[0];
        if(n==1){
            if(a>b) return 1;
            else if(b>a) return 2;
            return 0;
        }
        if(a==10) a += 2*p1[1];
        else a += p1[1];
        if(b==10) b += 2*p2[1];
        else b += p2[1];
        for(int i=2; i<n; i++){
            if(p1[i-1]==10 || p1[i-2]==10) a += 2*p1[i];
            else a += p1[i];
            if(p2[i-1]==10 || p2[i-2]==10) b += 2*p2[i];
            else b += p2[i];
        }
        if(a>b) return 1;
        else if(b>a) return 2;
        return 0;
    }
}",False
First Completely Painted Row or Column,"You are given a 0-indexed integer array arr, and an m x n integer matrix mat. arr and mat both contain all the integers in the range [1, m * n].
Go through each index i in arr starting from index 0 and paint the cell in mat containing the integer arr[i].
Return the smallest index i at which either a row or a column will be completely painted in mat.
","Example 1:


Input: arr = [1,3,4,2], mat = [[1,4],[2,3]]
Output: 2
Explanation: The moves are shown in order, and both the first row and second column of the matrix become fully painted at arr[2].
Example 2:

Input: arr = [2,8,7,4,1,3,5,6,9], mat = [[3,2,5],[1,4,6],[8,7,9]]
Output: 3
Explanation: The second column becomes fully painted at arr[3].
","class Solution:
    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:
        d={}
        for i in range(len(mat)):
            d[i]=len(mat[0])
        for j in range(len(mat[0])):
            d[j+len(mat)]=len(mat)
        d1={}
        for i in range(0,len(mat)):
            for j in range(0,len(mat[i])):
                d1[mat[i][j]]=[i,j]
        st=inf
        for k in range(len(arr)):
            if arr[k] in d1:
                x=d1[arr[k]]
                d[x[0]]-=1
                d[x[1]+len(mat)]-=1
                if d[x[0]]==0 or d[x[1]+len(mat)]==0:
                    st=min(st,k)
        return st",True
Count Vowel Strings in Ranges,"You are given a 0-indexed array of strings words and a 2D array of integers queries.
Each query queries[i] = [li, ri] asks us to find the number of strings present in the range li to ri (both inclusive) of words that start and end with a vowel.
Return an array ans of size queries.length, where ans[i] is the answer to the ith query.
Note that the vowel letters are 'a', 'e', 'i', 'o', and 'u'.
","Example 1:
Input: words = [""aba"",""bcb"",""ece"",""aa"",""e""], queries = [[0,2],[1,4],[1,1]]
Output: [2,3,0]
Explanation: The strings starting and ending with a vowel are ""aba"", ""ece"", ""aa"" and ""e"".
The answer to the query [0,2] is 2 (strings ""aba"" and ""ece"").
to query [1,4] is 3 (strings ""ece"", ""aa"", ""e"").
to query [1,1] is 0.
We return [2,3,0].
Example 2:
Input: words = [""a"",""e"",""i""], queries = [[0,2],[0,1],[2,2]]
Output: [3,2,1]
Explanation: Every string satisfies the conditions, so we return [3,2,1].
","class Solution {
    public int[] vowelStrings(String[] words, int[][] queries) {
        HashSet<Character> hs = new HashSet<>();
        hs.add('a');
        hs.add('e');
        hs.add('i');
        hs.add('o');
        hs.add('u');
        
        int N = words.length;
        int[] arr = new int[N];
        for(int i=0; i<N; i++) {
            if(hs.contains(words[i].charAt(0)) && hs.contains(words[i].charAt(words[i].length()-1))){
                arr[i] = 1;
            }
        }
        
        int[] prefix = new int[N];
        prefix[0] = arr[0];
        for(int i=1; i<N; i++) {
            prefix[i] = prefix[i-1]+arr[i];
        }
        
        int[] ansArr = new int[queries.length];
        
        for(int i=0; i<queries.length; i++) {
            int[] q = queries[i];
            int s = q[0];
            int e = q[1];
            
            int cnt = prefix[e];
            
            if(s-1>=0) {
                cnt -= prefix[s-1];
            }
            
            ansArr[i] = cnt;
        }
        
        return ansArr;
    }
}",False
Take Gifts From the Richest Pile,"You are given an integer array gifts denoting the number of gifts in various piles. Every second, you do the following:
Choose the pile with the maximum number of gifts.
If there is more than one pile with the maximum number of gifts, choose any.
Leave behind the floor of the square root of the number of gifts in the pile. Take the rest of the gifts.
Return the number of gifts remaining after k seconds.
","Example 1:
Input: gifts = [25,64,9,4,100], k = 4
Output: 29
Explanation: 
The gifts are taken in the following way:
- In the first second, the last pile is chosen and 10 gifts are left behind.
- Then the second pile is chosen and 8 gifts are left behind.
- After that the first pile is chosen and 5 gifts are left behind.
- Finally, the last pile is chosen again and 3 gifts are left behind.
The final remaining gifts are [5,8,9,4,3], so the total number of gifts remaining is 29.
Example 2:
Input: gifts = [1,1,1,1], k = 4
Output: 4
Explanation: 
In this case, regardless which pile you choose, you have to leave behind 1 gift in each pile. 
That is, you can't take any pile with you. 
So, the total gifts remaining are 4.
","class Solution:
    def pickGifts(self, gifts: List[int], k: int) -> int:
        i = 1
        while i <= k:
            max_gift = max(gifts)
            if max_gift in gifts:
                gifts.remove(max_gift)
                gifts.append(int(math.sqrt(max_gift)))
            max_gift = 0
            i += 1
        ans = sum(gifts)
        return ans
    ",True
Find the Maximum Divisibility Score,"You are given two 0-indexed integer arrays nums and divisors.
The divisibility score of divisors[i] is the number of indices j such that nums[j] is divisible by divisors[i].
Return the integer divisors[i] with the maximum divisibility score. If there is more than one integer with the maximum score, return the minimum of them.
","Example 1:
Input: nums = [4,7,9,3,9], divisors = [5,2,3]
Output: 3
Explanation: The divisibility score for every element in divisors is:
The divisibility score of divisors[0] is 0 since no number in nums is divisible by 5.
The divisibility score of divisors[1] is 1 since nums[0] is divisible by 2.
The divisibility score of divisors[2] is 3 since nums[2], nums[3], and nums[4] are divisible by 3.
Since divisors[2] has the maximum divisibility score, we return it.
Example 2:
Input: nums = [20,14,21,10], divisors = [5,7,5]
Output: 5
Explanation: The divisibility score for every element in divisors is:
The divisibility score of divisors[0] is 2 since nums[0] and nums[3] are divisible by 5.
The divisibility score of divisors[1] is 2 since nums[1] and nums[2] are divisible by 7.
The divisibility score of divisors[2] is 2 since nums[0] and nums[3] are divisible by 5.
Since divisors[0], divisors[1], and divisors[2] all have the maximum divisibility score, we return the minimum of them (i.e., divisors[2]).
Example 3:
Input: nums = [12], divisors = [10,16]
Output: 10
Explanation: The divisibility score for every element in divisors is:
The divisibility score of divisors[0] is 0 since no number in nums is divisible by 10.
The divisibility score of divisors[1] is 0 since no number in nums is divisible by 16.
Since divisors[0] and divisors[1] both have the maximum divisibility score, we return the minimum of them (i.e., divisors[0]).
","class Solution:
    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:
        ans=-1
        most=-1
        for d in divisors:
            cnt=sum(1 for n in nums if n%d==0)
            if cnt>most or cnt==most and d<ans:
                ans=d
                most=cnt

        return ans        ",True
Find Score of an Array After Marking All Elements,"You are given an array nums consisting of positive integers.
Starting with score = 0, apply the following algorithm:
Choose the smallest integer of the array that is not marked. If there is a tie, choose the one with the smallest index.
Add the value of the chosen integer to score.
Mark the chosen element and its two adjacent elements if they exist.
Repeat until all the array elements are marked.
Return the score you get after applying the above algorithm.
","Example 1:
Input: nums = [2,1,3,4,5,2]
Output: 7
Explanation: We mark the elements as follows:
- 1 is the smallest unmarked element, so we mark it and its two adjacent elements: [2,1,3,4,5,2].
- 2 is the smallest unmarked element, so we mark it and its left adjacent element: [2,1,3,4,5,2].
- 4 is the only remaining unmarked element, so we mark it: [2,1,3,4,5,2].
Our score is 1 + 2 + 4 = 7.
Example 2:
Input: nums = [2,3,5,1,3,2]
Output: 5
Explanation: We mark the elements as follows:
- 1 is the smallest unmarked element, so we mark it and its two adjacent elements: [2,3,5,1,3,2].
- 2 is the smallest unmarked element, since there are two of them, we choose the left-most one, so we mark the one at index 0 and its right adjacent element: [2,3,5,1,3,2].
- 2 is the only remaining unmarked element, so we mark it: [2,3,5,1,3,2].
Our score is 1 + 2 + 2 = 5.
","class Solution:
    def findScore(self, nums: List[int]) -> int:
        ans,pq,seen,n = 0,[],set(),len(nums)
        for i,num in enumerate(nums):
            heapq.heappush(pq,(num,i))
        while pq:
            empty = False
            while True:
                if not pq: 
                    empty = True
                    break
                num,i = heapq.heappop(pq)
                if i not in seen:
                    break
            if empty:
                break
            ans += num
            if i+1<n:
                seen.add(i+1)
            if i-1>=0:
                seen.add(i-1)
        return ans",True
The Number of Beautiful Subsets,"You are given an array nums of positive integers and a positive integer k.
A subset of nums is beautiful if it does not contain two integers with an absolute difference equal to k.
Return the number of non-empty beautiful subsets of the array nums.
A subset of nums is an array that can be obtained by deleting some (possibly none) elements from nums. Two subsets are different if and only if the chosen indices to delete are different.
","Example 1:
Input: nums = [2,4,6], k = 2
Output: 4
Explanation: The beautiful subsets of the array nums are: [2], [4], [6], [2, 6].
It can be proved that there are only 4 beautiful subsets in the array [2,4,6].
Example 2:
Input: nums = [1], k = 1
Output: 1
Explanation: The beautiful subset of the array nums is [1].
It can be proved that there is only 1 beautiful subset in the array [1].
",,False
Find the Array Concatenation Value,"You are given a 0-indexed integer array nums.
The concatenation of two numbers is the number formed by concatenating their numerals.
For example, the concatenation of 15, 49 is 1549.
The concatenation value of nums is initially equal to 0. Perform this operation until nums becomes empty:
If there exists more than one number in nums, pick the first element and last element in nums respectively and add the value of their concatenation to the concatenation value of nums, then delete the first and last element from nums.
If one element exists, add its value to the concatenation value of nums, then delete it.
Return the concatenation value of the nums.
","Example 1:
Input: nums = [7,52,2,4]
Output: 596
Explanation: Before performing any operation, nums is [7,52,2,4] and concatenation value is 0.
 - In the first operation:
We pick the first element, 7, and the last element, 4.
Their concatenation is 74, and we add it to the concatenation value, so it becomes equal to 74.
Then we delete them from nums, so nums becomes equal to [52,2].
 - In the second operation:
We pick the first element, 52, and the last element, 2.
Their concatenation is 522, and we add it to the concatenation value, so it becomes equal to 596.
Then we delete them from the nums, so nums becomes empty.
Since the concatenation value is 596 so the answer is 596.
Example 2:
Input: nums = [5,14,13,8,12]
Output: 673
Explanation: Before performing any operation, nums is [5,14,13,8,12] and concatenation value is 0.
 - In the first operation:
We pick the first element, 5, and the last element, 12.
Their concatenation is 512, and we add it to the concatenation value, so it becomes equal to 512.
Then we delete them from the nums, so nums becomes equal to [14,13,8].
 - In the second operation:
We pick the first element, 14, and the last element, 8.
Their concatenation is 148, and we add it to the concatenation value, so it becomes equal to 660.
Then we delete them from the nums, so nums becomes equal to [13].
 - In the third operation:
nums has only one element, so we pick 13 and add it to the concatenation value, so it becomes equal to 673.
Then we delete it from nums, so nums become empty.
Since the concatenation value is 673 so the answer is 673.
","class Solution:
    def findTheArrayConcVal(self, nums: List[int]) -> int:
        concatenation = 0
        while len(nums)>0:
            if len(nums)>1:
                concatenation += int(str(nums[0])+str(nums[-1]))
                del nums[-1]
            else:
                concatenation += nums[0]
            del nums[0]
        return concatenation",True
Minimum Score by Changing Two Elements,"You are given an integer array nums.
The low score of nums is the minimum absolute difference between any two integers.
The high score of nums is the maximum absolute difference between any two integers.
The score of nums is the sum of the high and low scores.
Return the minimum score after changing two elements of nums.
","Example 1:
Input: nums = [1,4,7,8,5]
Output: 3
Explanation:
Change nums[0] and nums[1] to be 6 so that nums becomes [6,6,7,8,5].
The low score is the minimum absolute difference: |6 - 6| = 0.
The high score is the maximum absolute difference: |8 - 5| = 3.
The sum of high and low score is 3.
Example 2:
Input: nums = [1,4,3]
Output: 0
Explanation:
Change nums[1] and nums[2] to 1 so that nums becomes [1,1,1].
The sum of maximum absolute difference and minimum absolute difference is 0.
","class Solution:
    def minimizeSum(self, nums: List[int]) -> int:
        nums.sort()
        return min(nums[-1]-nums[2],nums[-2]-nums[1],nums[-3]-nums[0])     ",True
Merge Two 2D Arrays by Summing Values,"You are given two 2D integer arrays nums1 and nums2.
nums1[i] = [idi, vali] indicate that the number with the id idi has a value equal to vali.
nums2[i] = [idi, vali] indicate that the number with the id idi has a value equal to vali.
Each array contains unique ids and is sorted in ascending order by id.
Merge the two arrays into one array that is sorted in ascending order by id, respecting the following conditions:
Only ids that appear in at least one of the two arrays should be included in the resulting array.
Each id should be included only once and its value should be the sum of the values of this id in the two arrays. If the id does not exist in one of the two arrays then its value in that array is considered to be 0.
Return the resulting array. The returned array must be sorted in ascending order by id.
","Example 1:
Input: nums1 = [[1,2],[2,3],[4,5]], nums2 = [[1,4],[3,2],[4,1]]
Output: [[1,6],[2,3],[3,2],[4,6]]
Explanation: The resulting array contains the following:
- id = 1, the value of this id is 2 + 4 = 6.
- id = 2, the value of this id is 3.
- id = 3, the value of this id is 2.
- id = 4, the value of this id is 5 + 1 = 6.
Example 2:
Input: nums1 = [[2,4],[3,6],[5,5]], nums2 = [[1,3],[4,3]]
Output: [[1,3],[2,4],[3,6],[4,3],[5,5]]
Explanation: There are no common ids, so we just include each id with its value in the resulting list.
","class Solution:
    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:
        d1,d2 = {},{}
		# add all entries of nums1 to map d1
        for num in nums1:
            d1[num[0]] = num[1]
			
		# add all entries of nums2 to map d2
        for num in nums2:
            d2[num[0]] = num[1]
			
		# to store final ans
        ans = []
		
		# traverse map1
        for num in d1.keys():
            val = d1[num]
			
			# if the entry is in map2 add it in the value of map1 and remove it from map2
            if num in d2:
                val += d2[num]
                del d2[num]
				
			# add the id,val pair  to ans
            ans.append([num,val])
			
		# traverse map2 to get items that are not in map1
        for key,val in d2.items():
            ans.append([key,val])
			
		# sort the final ans by ids
        ans.sort(key=lambda x:x[0])
        return ans",True
Find the Maximum Number of Marked Indices,"You are given a 0-indexed integer array nums.
Initially, all of the indices are unmarked. You are allowed to make this operation any number of times:
Pick two different unmarked indices i and j such that 2 * nums[i] <= nums[j], then mark i and j.
Return the maximum possible number of marked indices in nums using the above operation any number of times.
","Example 1:
Input: nums = [3,5,2,4]
Output: 2
Explanation: In the first operation: pick i = 2 and j = 1, the operation is allowed because 2 * nums[2] <= nums[1]. Then mark index 2 and 1.
It can be shown that there's no other valid operation so the answer is 2.
Example 2:
Input: nums = [9,2,5,4]
Output: 4
Explanation: In the first operation: pick i = 3 and j = 0, the operation is allowed because 2 * nums[3] <= nums[0]. Then mark index 3 and 0.
In the second operation: pick i = 1 and j = 2, the operation is allowed because 2 * nums[1] <= nums[2]. Then mark index 1 and 2.
Since there is no other operation, the answer is 4.
Example 3:
Input: nums = [7,6,8]
Output: 0
Explanation: There is no valid operation to do, so the answer is 0.
","class Solution {
public:
    int maxNumOfMarkedIndices(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        int j=nums.size()-1;
        int c=0;
        int i=0;
        for(int i=nums.size()/2-1;i>=0;i--)
        {
            if(nums[i]*2<=nums[j])
            {
                c+=2;
                j--;
            }
        }
        return c;
    }
};",False
Find the Divisibility Array of a String,"You are given a 0-indexed string word of length n consisting of digits, and a positive integer m.
The divisibility array div of word is an integer array of length n such that:
div[i] = 1 if the numeric value of word[0,...,i] is divisible by m, or
div[i] = 0 otherwise.
Return the divisibility array of word.
","Example 1:
Input: word = ""998244353"", m = 3
Output: [1,1,0,0,0,1,1,0,0]
Explanation: There are only 4 prefixes that are divisible by 3: ""9"", ""99"", ""998244"", and ""9982443"".
Example 2:
Input: word = ""1010"", m = 10
Output: [0,1,0,1]
Explanation: There are only 2 prefixes that are divisible by 10: ""10"", and ""1010"".
","class Solution:
    def divisibilityArray(self, word: str, m: int) -> List[int]:
        mod = 0
        div = []

        for i in range(0, len(word)):
            mod = (mod * 10 + int(word[i])) % m
            div.append(1 if mod % m == 0 else 0)
        return div",True
Left and Right Sum Differences,"Given a 0-indexed integer array nums, find a 0-indexed integer array answer where:
answer.length == nums.length.
answer[i] = |leftSum[i] - rightSum[i]|.
Where:
leftSum[i] is the sum of elements to the left of the index i in the array nums. If there is no such element, leftSum[i] = 0.
rightSum[i] is the sum of elements to the right of the index i in the array nums. If there is no such element, rightSum[i] = 0.
Return the array answer.
","Example 1:
Input: nums = [10,4,8,3]
Output: [15,1,11,22]
Explanation: The array leftSum is [0,10,14,22] and the array rightSum is [15,11,3,0].
The array answer is [|0 - 15|,|10 - 11|,|14 - 3|,|22 - 0|] = [15,1,11,22].
Example 2:
Input: nums = [1]
Output: [0]
Explanation: The array leftSum is [0] and the array rightSum is [0].
The array answer is [|0 - 0|] = [0].
","class Solution:
    def leftRigthDifference(self, nums: List[int]) -> List[int]:
        res = []

        for i in range(len(nums)):
            res.append(abs(sum(nums[0:i])-sum(nums[i+1:])))

        return res",True
Prime Subtraction Operation,"You are given a 0-indexed integer array nums of length n.
You can perform the following operation as many times as you want:
Pick an index i that you haven’t picked before, and pick a prime p strictly less than nums[i], then subtract p from nums[i].
Return true if you can make nums a strictly increasing array using the above operation and false otherwise.
A strictly increasing array is an array whose each element is strictly greater than its preceding element.
","Example 1:
Input: nums = [4,9,6,10]
Output: true
Explanation: In the first operation: Pick i = 0 and p = 3, and then subtract 3 from nums[0], so that nums becomes [1,9,6,10].
In the second operation: i = 1, p = 7, subtract 7 from nums[1], so nums becomes equal to [1,2,6,10].
After the second operation, nums is sorted in strictly increasing order, so the answer is true.
Example 2:
Input: nums = [6,8,11,12]
Output: true
Explanation: Initially nums is sorted in strictly increasing order, so we don't need to make any operations.
Example 3:
Input: nums = [5,8,3]
Output: false
Explanation: It can be proven that there is no way to perform operations to make nums sorted in strictly increasing order, so the answer is false.
","class Solution:
  def primeSubOperation(self, nums: List[int]) -> bool:
    primes = [0, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]
    prev_small = 0
    for v in nums:
      pos, is_found = bisect_left(primes, v), False
      for i in range(pos - 1, -1, -1):
        if v - primes[i] > prev_small:
          prev_small = v - primes[i]
          is_found = True
          break
      if not is_found:
        return False
    
    return True",True
Minimize the Maximum Difference of Pairs,"You are given a 0-indexed integer array nums and an integer p. Find p pairs of indices of nums such that the maximum difference amongst all the pairs is minimized. Also, ensure no index appears more than once amongst the p pairs.
Note that for a pair of elements at the index i and j, the difference of this pair is |nums[i] - nums[j]|, where |x| represents the absolute value of x.
Return the minimum maximum difference among all p pairs. We define the maximum of an empty set to be zero.
","Example 1:
Input: nums = [10,1,2,7,1,3], p = 2
Output: 1
Explanation: The first pair is formed from the indices 1 and 4, and the second pair is formed from the indices 2 and 5. 
The maximum difference is max(|nums[1] - nums[4]|, |nums[2] - nums[5]|) = max(0, 1) = 1. Therefore, we return 1.
Example 2:
Input: nums = [4,2,1,2], p = 1
Output: 0
Explanation: Let the indices 1 and 3 form a pair. The difference of that pair is |2 - 2| = 0, which is the minimum we can attain.
","class Solution:
    def minimizeMax(self, nums: list[int], p: int) -> int:
        if p == 0: return 0

        nums.sort()
        pairs = [(b-a,i) for i,(a,b) in enumerate(itertools.pairwise(nums))]
        pairs.sort()

        # edge case optimization 1 --- copied from some other solution
        if len(nums) == 2*p:
            (d,i) = pairs.pop()
            while (i&1):
                (d,i) = pairs.pop()
            return d
                
        # edge case optimization 2 --- copied from some other solution
        dictmin = pairs[p-1][0]
        dictmax = pairs[2*p-2][0]
        if (dictmin == dictmax):
            return dictmin

        m = [0]*len(nums)
        for i, (d,loc) in enumerate(pairs):
            l, r = m[loc-1], m[loc+1]
            m[loc] = m[loc-l] = m[loc+r] = l+r+1
            p -= 1&~(l|r)
            if p == 0: return d
",True
Sum of Distances,"You are given a 0-indexed integer array nums. There exists an array arr of length nums.length, where arr[i] is the sum of |i - j| over all j such that nums[j] == nums[i] and j != i. If there is no such j, set arr[i] to be 0.
Return the array arr.
","Example 1:
Input: nums = [1,3,1,1,2]
Output: [5,0,3,4,0]
Explanation: 
When i = 0, nums[0] == nums[2] and nums[0] == nums[3]. Therefore, arr[0] = |0 - 2| + |0 - 3| = 5. 
When i = 1, arr[1] = 0 because there is no other index with value 3.
When i = 2, nums[2] == nums[0] and nums[2] == nums[3]. Therefore, arr[2] = |2 - 0| + |2 - 3| = 3. 
When i = 3, nums[3] == nums[0] and nums[3] == nums[2]. Therefore, arr[3] = |3 - 0| + |3 - 2| = 4. 
When i = 4, arr[4] = 0 because there is no other index with value 2. 
Example 2:
Input: nums = [0,5,3]
Output: [0,0,0]
Explanation: Since each element in nums is distinct, arr[i] = 0 for all i.
","class Solution:
    def distance(self, nums: List[int]) -> List[int]:
        d={}
        for i in range(len(nums)):
            if(nums[i] not in d):
                d[nums[i]]=[i]
            else:
                d[nums[i]].append(d[nums[i]][-1]+i)
        ans=[]
        for i in d:
            d[i].append(0)
            d[i].append(len(d[i])-1)
        print(d)
        for i in range(len(nums)):
            a=d[nums[i]][-2]
            n=d[nums[i]][-1]
            if(n==1):
                ans.append(0)
                continue
            print(a,n)
            ans.append(abs((a+1)*i-d[nums[i]][a])+abs((n-a-1)*i-(d[nums[i]][-3]-d[nums[i]][a])))
            d[nums[i]][-2]+=1
        return ans
            
            
        ",True
Prime In Diagonal,"You are given a 0-indexed two-dimensional integer array nums.
Return the largest prime number that lies on at least one of the diagonals of nums. In case, no prime is present on any of the diagonals, return 0.
Note that:
An integer is prime if it is greater than 1 and has no positive integer divisors other than 1 and itself.
An integer val is on one of the diagonals of nums if there exists an integer i for which nums[i][i] = val or an i for which nums[i][nums.length - i - 1] = val.

In the above diagram, one diagonal is [1,5,9] and another diagonal is [3,5,7].
","Example 1:
Input: nums = [[1,2,3],[5,6,7],[9,10,11]]
Output: 11
Explanation: The numbers 1, 3, 6, 9, and 11 are the only numbers present on at least one of the diagonals. Since 11 is the largest prime, we return 11.
Example 2:
Input: nums = [[1,2,3],[5,17,7],[9,11,10]]
Output: 17
Explanation: The numbers 1, 3, 9, 10, and 17 are all present on at least one of the diagonals. 17 is the largest prime, so we return 17.
","class Solution {
    bool prime(int n) {
        if(n < 2) return false;
        for(int i=2;i*i<=n;i++) {
            if(n % i == 0) return false;
        }
        return true;
    }
public:
    int diagonalPrime(vector<vector<int>>& nums) {
        int n = nums.size();
        int maxi = 0;
        for(int i=0;i<n;i++) {
            if(prime(nums[i][i])) {
                maxi = max(maxi, nums[i][i]);
            }
            if(prime(nums[i][n - i - 1])) {
                maxi = max(maxi, nums[i][n - i - 1]);
            }
        }
        return maxi;
    }
};",False
Convert an Array Into a 2D Array With Conditions,"You are given an integer array nums. You need to create a 2D array from nums satisfying the following conditions:
The 2D array should contain only the elements of the array nums.
Each row in the 2D array contains distinct integers.
The number of rows in the 2D array should be minimal.
Return the resulting array. If there are multiple answers, return any of them.
Note that the 2D array can have a different number of elements on each row.
","Example 1:
Input: nums = [1,3,4,1,2,3,1]
Output: [[1,3,4,2],[1,3],[1]]
Explanation: We can create a 2D array that contains the following rows:
- 1,3,4,2
- 1,3
- 1
All elements of nums were used, and each row of the 2D array contains distinct integers, so it is a valid answer.
It can be shown that we cannot have less than 3 rows in a valid array.
Example 2:
Input: nums = [1,2,3,4]
Output: [[4,3,2,1]]
Explanation: All elements of the array are distinct, so we can keep all of them in the first row of the 2D array.
","class Solution:
    def findMatrix(self, nums: List[int]) -> List[List[int]]:
        res = []

        # Iterate over the input array
        for num in nums:
            # Try to add the number to an existing row
            for row in res:
                if num not in row:
                    row.add(num)
                    break
            else:
                # If no such row is found, create a new one
                res.append(set([num]))

        # Convert sets to lists for the final result
        return [list(row) for row in res]",True
Number of Senior Citizens,"You are given a 0-indexed array of strings details. Each element of details provides information about a given passenger compressed into a string of length 15. The system is such that:
The first ten characters consist of the phone number of passengers.
The next character denotes the gender of the person.
The following two characters are used to indicate the age of the person.
The last two characters determine the seat allotted to that person.
Return the number of passengers who are strictly more than 60 years old.
","Example 1:
Input: details = [""7868190130M7522"",""5303914400F9211"",""9273338290F4010""]
Output: 2
Explanation: The passengers at indices 0, 1, and 2 have ages 75, 92, and 40. Thus, there are 2 people who are over 60 years old.
Example 2:
Input: details = [""1313579440F2036"",""2921522980M5644""]
Output: 0
Explanation: None of the passengers are older than 60.
",,False
Sum in a Matrix,"You are given a 0-indexed 2D integer array nums. Initially, your score is 0. Perform the following operations until the matrix becomes empty:
From each row in the matrix, select the largest number and remove it. In the case of a tie, it does not matter which number is chosen.
Identify the highest number amongst all those removed in step 1. Add that number to your score.
Return the final score.
","Example 1:
Input: nums = [[7,2,1],[6,4,2],[6,5,3],[3,2,1]]
Output: 15
Explanation: In the first operation, we remove 7, 6, 6, and 3. We then add 7 to our score. Next, we remove 2, 4, 5, and 2. We add 5 to our score. Lastly, we remove 1, 2, 3, and 1. We add 3 to our score. Thus, our final score is 7 + 5 + 3 = 15.
Example 2:
Input: nums = [[1]]
Output: 1
Explanation: We remove 1 and add it to the answer. We return 1.
",,False
Maximum OR,"You are given a 0-indexed integer array nums of length n and an integer k. In an operation, you can choose an element and multiply it by 2.
Return the maximum possible value of nums[0] | nums[1] | ... | nums[n - 1] that can be obtained after applying the operation on nums at most k times.
Note that a | b denotes the bitwise or between two integers a and b.
","Example 1:
Input: nums = [12,9], k = 1
Output: 30
Explanation: If we apply the operation to index 1, our new array nums will be equal to [12,18]. Thus, we return the bitwise or of 12 and 18, which is 30.
Example 2:
Input: nums = [8,1,2], k = 2
Output: 35
Explanation: If we apply the operation twice on index 0, we yield a new array of [32,1,2]. Thus, we return 32|1|2 = 35.
","class Solution:
    def maximumOr(self, nums: List[int], k: int) -> int:
        cur = 0
        saved = 0
        for num in nums:
            saved |= num & cur
            cur |= num
        
        max_num = 0
        
        for num in nums:
            max_num = max(max_num, saved | (cur & ~num) | num << k)
        return max_num
        ",True
Row With Maximum Ones,"Given a m x n binary matrix mat, find the 0-indexed position of the row that contains the maximum count of ones, and the number of ones in that row.
In case there are multiple rows that have the maximum count of ones, the row with the smallest row number should be selected.
Return an array containing the index of the row, and the number of ones in it.
","Example 1:
Input: mat = [[0,1],[1,0]]
Output: [0,1]
Explanation: Both rows have the same number of 1's. So we return the index of the smaller row, 0, and the maximum count of ones (1). So, the answer is [0,1]. 
Example 2:
Input: mat = [[0,0,0],[0,1,1]]
Output: [1,2]
Explanation: The row indexed 1 has the maximum count of ones (2). So we return its index, 1, and the count. So, the answer is [1,2].
Example 3:
Input: mat = [[0,0],[1,1],[0,0]]
Output: [1,2]
Explanation: The row indexed 1 has the maximum count of ones (2). So the answer is [1,2].
","class Solution:
    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:
        maxcount=0
        res=[0,0]
        for i,row in enumerate(mat):
            count=sum(row)
            if maxcount<count:
                res=[i,count]
                maxcount=count
        return res
        ",True
Sliding Subarray Beauty,"Given an integer array nums containing n integers, find the beauty of each subarray of size k.
The beauty of a subarray is the xth smallest integer in the subarray if it is negative, or 0 if there are fewer than x negative integers.
Return an integer array containing n - k + 1 integers, which denote the beauty of the subarrays in order from the first index in the array.
A subarray is a contiguous non-empty sequence of elements within an array.
","Example 1:
Input: nums = [1,-1,-3,-2,3], k = 3, x = 2
Output: [-1,-2,-2]
Explanation: There are 3 subarrays with size k = 3. 
The first subarray is [1, -1, -3] and the 2nd smallest negative integer is -1. 
The second subarray is [-1, -3, -2] and the 2nd smallest negative integer is -2. 
The third subarray is [-3, -2, 3] and the 2nd smallest negative integer is -2.
Example 2:
Input: nums = [-1,-2,-3,-4,-5], k = 2, x = 2
Output: [-1,-2,-3,-4]
Explanation: There are 4 subarrays with size k = 2.
For [-1, -2], the 2nd smallest negative integer is -1.
For [-2, -3], the 2nd smallest negative integer is -2.
For [-3, -4], the 2nd smallest negative integer is -3.
For [-4, -5], the 2nd smallest negative integer is -4. 
Example 3:
Input: nums = [-3,1,2,-3,0,-3], k = 2, x = 1
Output: [-3,0,-3,-3,-3]
Explanation: There are 5 subarrays with size k = 2.
For [-3, 1], the 1st smallest negative integer is -3.
For [1, 2], there is no negative integer so the beauty is 0.
For [2, -3], the 1st smallest negative integer is -3.
For [-3, 0], the 1st smallest negative integer is -3.
For [0, -3], the 1st smallest negative integer is -3.
",,False
Minimum Number of Operations to Make All Array Elements Equal to 1,"You are given a 0-indexed array nums consisiting of positive integers. You can do the following operation on the array any number of times:
Select an index i such that 0 <= i < n - 1 and replace either of nums[i] or nums[i+1] with their gcd value.
Return the minimum number of operations to make all elements of nums equal to 1. If it is impossible, return -1.
The gcd of two integers is the greatest common divisor of the two integers.
","Example 1:
Input: nums = [2,6,3,4]
Output: 4
Explanation: We can do the following operations:
- Choose index i = 2 and replace nums[2] with gcd(3,4) = 1. Now we have nums = [2,6,1,4].
- Choose index i = 1 and replace nums[1] with gcd(6,1) = 1. Now we have nums = [2,1,1,4].
- Choose index i = 0 and replace nums[0] with gcd(2,1) = 1. Now we have nums = [1,1,1,4].
- Choose index i = 2 and replace nums[3] with gcd(1,4) = 1. Now we have nums = [1,1,1,1].
Example 2:
Input: nums = [2,10,6,14]
Output: -1
Explanation: It can be shown that it is impossible to make all the elements equal to 1.
","class Solution:
    def minOperations(self, nums):
        n, ones, diff = len(nums), nums.count(1), float(""inf"")

        if ones: return n-ones

        for i in range(n):
            val = nums[i]
            for j in range(i+1,n):
                val = gcd(val,nums[j])
                if val == 1:
                    diff = min(diff,j-i+(n-1))
                    break

        return -1 if diff == float(""inf"") else diff",True
Maximum Strength of a Group,"You are given a 0-indexed integer array nums representing the score of students in an exam. The teacher would like to form one non-empty group of students with maximal strength, where the strength of a group of students of indices i0, i1, i2, ... , ik is defined as nums[i0] * nums[i1] * nums[i2] * ... * nums[ik].
Return the maximum strength of a group the teacher can create.
","Example 1:
Input: nums = [3,-1,-5,2,5,-9]
Output: 1350
Explanation: One way to form a group of maximal strength is to group the students at indices [0,2,3,4,5]. Their strength is 3 * (-5) * 2 * 5 * (-9) = 1350, which we can show is optimal.
Example 2:
Input: nums = [-4,-5,-4]
Output: 20
Explanation: Group the students at indices [0, 1] . Then, we’ll have a resulting strength of 20. We cannot achieve greater strength.
","class Solution:
    def maxStrength(self, nums: List[int]) -> int:
        pos,neg=[],[]

        if len(nums)==1:
            return nums[0]

        for x in nums:
            if x>0:
                pos.append(x)
            elif x<0:
                neg.append(-x)

        neg.sort(reverse=True)
        
        if len(neg)%2==1:
            neg.pop()

        if len(neg)==0 and len(pos)==0:
            return 0
        else:
            res=1
            for x in neg: res*=x
            for x in pos: res*=x
            return res
       ",True
Extra Characters in a String,"You are given a 0-indexed string s and a dictionary of words dictionary. You have to break s into one or more non-overlapping substrings such that each substring is present in dictionary. There may be some extra characters in s which are not present in any of the substrings.
Return the minimum number of extra characters left over if you break up s optimally.
","Example 1:
Input: s = ""leetscode"", dictionary = [""leet"",""code"",""leetcode""]
Output: 1
Explanation: We can break s in two substrings: ""leet"" from index 0 to 3 and ""code"" from index 5 to 8. There is only 1 unused character (at index 4), so we return 1.
Example 2:
Input: s = ""sayhelloworld"", dictionary = [""hello"",""world""]
Output: 3
Explanation: We can break s in two substrings: ""hello"" from index 3 to 7 and ""world"" from index 8 to 12. The characters at indices 0, 1, 2 are not used in any substring and thus are considered as extra characters. Hence, we return 3.
","class Solution:
    def minExtraChar(self, s: str, dictionary: List[str]) -> int:

        # Build a trie with reversed words in dictionary
        trie = {}
        for w in dictionary:
            w = reversed(w)
            cur = trie
            for c in w:
                if c not in cur:
                    cur[c] = {}
                cur = cur[c]
            cur['match'] = True

        def getDictWord(i, trie, s):
            '''Retrieve the lookback indices with revserd trie and index.'''
            cur = trie
            res = []
            for j in range(i+1)[::-1]:
                if s[j] in cur:
                    cur = cur[s[j]]
                    if 'match' in cur:
                        res += [j]
                else:
                    break
            return res


        n = len(s)
        dp = []
        for i in range(n):
            # - Fetch lookback indices
            lookback = getDictWord(i, trie, s)
            # - Initial cost
            if dp:
                v = dp[-1] + 1
            else:
                v = 1
            # - Optimized the cost with lookback indices
            if lookback:
                for j in lookback:
                    if j == 0:
                        v = 0
                        break
                    v = min(v, dp[j-1])
            dp += [v]
        return dp[-1]
",True
Buy Two Chocolates,"You are given an integer array prices representing the prices of various chocolates in a store. You are also given a single integer money, which represents your initial amount of money.
You must buy exactly two chocolates in such a way that you still have some non-negative leftover money. You would like to minimize the sum of the prices of the two chocolates you buy.
Return the amount of money you will have leftover after buying the two chocolates. If there is no way for you to buy two chocolates without ending up in debt, return money. Note that the leftover must be non-negative.
","Example 1:
Input: prices = [1,2,2], money = 3
Output: 0
Explanation: Purchase the chocolates priced at 1 and 2 units respectively. You will have 3 - 3 = 0 units of money afterwards. Thus, we return 0.
Example 2:
Input: prices = [3,2,3], money = 3
Output: 3
Explanation: You cannot buy 2 chocolates without going in debt, so we return 3.
","class Solution {
public:
    int buyChoco(vector<int>& prices, int money) {
          int n=prices.size();
          int n1=prices[0],n2=prices[1];
          if(n1>n2){swap(n1,n2);}
          for(int i=2;i<n;i++){
              if(n1>prices[i]){
                  n2=n1;
                  n1=prices[i];
              }else if(n2>prices[i]){
                  n2=prices[i];
              }
          }
          if(n1+n2<=money){
              return (money-n1-n2);
          }return money;
    }
};",False
Maximum Number of Fish in a Grid,"You are given a 0-indexed 2D matrix grid of size m x n, where (r, c) represents:
A land cell if grid[r][c] = 0, or
A water cell containing grid[r][c] fish, if grid[r][c] > 0.
A fisher can start at any water cell (r, c) and can do the following operations any number of times:
Catch all the fish at cell (r, c), or
Move to any adjacent water cell.
Return the maximum number of fish the fisher can catch if he chooses his starting cell optimally, or 0 if no water cell exists.
An adjacent cell of the cell (r, c), is one of the cells (r, c + 1), (r, c - 1), (r + 1, c) or (r - 1, c) if it exists.
","Example 1:

Input: grid = [[0,2,1,0],[4,0,0,3],[1,0,0,4],[0,3,2,0]]
Output: 7
Explanation: The fisher can start at cell (1,3) and collect 3 fish, then move to cell (2,3) and collect 4 fish.
Example 2:

Input: grid = [[1,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,1]]
Output: 1
Explanation: The fisher can start at cells (0,0) or (3,3) and collect a single fish. 
",,False
Find the Prefix Common Array of Two Arrays,"You are given two 0-indexed integer permutations A and B of length n.
A prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.
Return the prefix common array of A and B.
A sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.
","Example 1:
Input: A = [1,3,2,4], B = [3,1,2,4]
Output: [0,2,3,4]
Explanation: At i = 0: no number is common, so C[0] = 0.
At i = 1: 1 and 3 are common in A and B, so C[1] = 2.
At i = 2: 1, 2, and 3 are common in A and B, so C[2] = 3.
At i = 3: 1, 2, 3, and 4 are common in A and B, so C[3] = 4.
Example 2:
Input: A = [2,3,1], B = [3,1,2]
Output: [0,1,3]
Explanation: At i = 0: no number is common, so C[0] = 0.
At i = 1: only 3 is common in A and B, so C[1] = 1.
At i = 2: 1, 2, and 3 are common in A and B, so C[2] = 3.
","class Solution:
    def findThePrefixCommonArray(self, a: list[int], b: list[int]) -> list[int]:
        prefix_array = []
        a_mask = 0
        b_mask = 0

        for a_num, b_num in zip(a, b):
            a_mask ^= (1 << a_num)
            b_mask ^= (1 << b_num)
            prefix_array.append((a_mask & b_mask).bit_count())
        
        return prefix_array",True
Maximum Sum With Exactly K Elements ,"You are given a 0-indexed integer array nums and an integer k. Your task is to perform the following operation exactly k times in order to maximize your score:
Select an element m from nums.
Remove the selected element m from the array.
Add a new element with a value of m + 1 to the array.
Increase your score by m.
Return the maximum score you can achieve after performing the operation exactly k times.
","Example 1:
Input: nums = [1,2,3,4,5], k = 3
Output: 18
Explanation: We need to choose exactly 3 elements from nums to maximize the sum.
For the first iteration, we choose 5. Then sum is 5 and nums = [1,2,3,4,6]
For the second iteration, we choose 6. Then sum is 5 + 6 and nums = [1,2,3,4,7]
For the third iteration, we choose 7. Then sum is 5 + 6 + 7 = 18 and nums = [1,2,3,4,8]
So, we will return 18.
It can be proven, that 18 is the maximum answer that we can achieve.
Example 2:
Input: nums = [5,5,5], k = 2
Output: 11
Explanation: We need to choose exactly 2 elements from nums to maximize the sum.
For the first iteration, we choose 5. Then sum is 5 and nums = [5,5,6]
For the second iteration, we choose 6. Then sum is 5 + 6 = 11 and nums = [5,5,7]
So, we will return 11.
It can be proven, that 11 is the maximum answer that we can achieve.
","class Solution {
public:
    int maximizeSum(vector<int>& nums, int k) {
        sort(nums.begin(),nums.end());
        
        int n = nums[nums.size()-1];
        int ans = nums[nums.size()-1];
        for(int i = 1; i<k; i++){
            n+=1;
            ans+=n;
        }
        return ans;
    }
};

",False
Find the Distinct Difference Array,"You are given a 0-indexed array nums of length n.
The distinct difference array of nums is an array diff of length n such that diff[i] is equal to the number of distinct elements in the suffix nums[i + 1, ..., n - 1] subtracted from the number of distinct elements in the prefix nums[0, ..., i].
Return the distinct difference array of nums.
Note that nums[i, ..., j] denotes the subarray of nums starting at index i and ending at index j inclusive. Particularly, if i > j then nums[i, ..., j] denotes an empty subarray.
","Example 1:
Input: nums = [1,2,3,4,5]
Output: [-3,-1,1,3,5]
Explanation: For index i = 0, there is 1 element in the prefix and 4 distinct elements in the suffix. Thus, diff[0] = 1 - 4 = -3.
For index i = 1, there are 2 distinct elements in the prefix and 3 distinct elements in the suffix. Thus, diff[1] = 2 - 3 = -1.
For index i = 2, there are 3 distinct elements in the prefix and 2 distinct elements in the suffix. Thus, diff[2] = 3 - 2 = 1.
For index i = 3, there are 4 distinct elements in the prefix and 1 distinct element in the suffix. Thus, diff[3] = 4 - 1 = 3.
For index i = 4, there are 5 distinct elements in the prefix and no elements in the suffix. Thus, diff[4] = 5 - 0 = 5.
Example 2:
Input: nums = [3,2,3,4,2]
Output: [-2,-1,0,2,3]
Explanation: For index i = 0, there is 1 element in the prefix and 3 distinct elements in the suffix. Thus, diff[0] = 1 - 3 = -2.
For index i = 1, there are 2 distinct elements in the prefix and 3 distinct elements in the suffix. Thus, diff[1] = 2 - 3 = -1.
For index i = 2, there are 2 distinct elements in the prefix and 2 distinct elements in the suffix. Thus, diff[2] = 2 - 2 = 0.
For index i = 3, there are 3 distinct elements in the prefix and 1 distinct element in the suffix. Thus, diff[3] = 3 - 1 = 2.
For index i = 4, there are 3 distinct elements in the prefix and no elements in the suffix. Thus, diff[4] = 3 - 0 = 3.
",,False
Number of Adjacent Elements With the Same Color,"You are given an integer n representing an array colors of length n where all elements are set to 0's meaning uncolored. You are also given a 2D integer array queries where queries[i] = [indexi, colori]. For the ith query:
Set colors[indexi] to colori.
Count adjacent pairs in colors set to the same color (regardless of colori).
Return an array answer of the same length as queries where answer[i] is the answer to the ith query.
","Example 1:
Input: n = 4, queries = [[0,2],[1,2],[3,1],[1,1],[2,1]]
Output: [0,1,1,0,2]
Explanation:
Initially array colors = [0,0,0,0], where 0 denotes uncolored elements of the array.
After the 1st query colors = [2,0,0,0]. The count of adjacent pairs with the same color is 0.
After the 2nd query colors = [2,2,0,0]. The count of adjacent pairs with the same color is 1.
After the 3rd query colors = [2,2,0,1]. The count of adjacent pairs with the same color is 1.
After the 4th query colors = [2,1,0,1]. The count of adjacent pairs with the same color is 0.
After the 5th query colors = [2,1,1,1]. The count of adjacent pairs with the same color is 2.
Example 2:
Input: n = 1, queries = [[0,100000]]
Output: [0]
Explanation:
After the 1st query colors = [100000]. The count of adjacent pairs with the same color is 0.
","class Solution:
    def colorTheArray(self, n, queries):
        ans, nums, count = [], [0]*n, 0

        for i in range(len(queries)):
            index, color = queries[i][0], queries[i][1]

            if index-1 >= 0 and nums[index] != 0 and nums[index-1] == nums[index]:
                count -= 1
            if index+1 < n and nums[index] != 0 and nums[index+1] == nums[index]:
                count -= 1

            nums[index] = color

            if index-1 >= 0 and nums[index] != 0 and nums[index-1] == nums[index]:
                count += 1
            if index+1 < n and nums[index] != 0 and nums[index+1] == nums[index]:
                count += 1

            ans.append(count)

        return ans

            




",True
Make Costs of Paths Equal in a Binary Tree,"You are given an integer n representing the number of nodes in a perfect binary tree consisting of nodes numbered from 1 to n. The root of the tree is node 1 and each node i in the tree has two children where the left child is the node 2 * i and the right child is 2 * i + 1.
Each node in the tree also has a cost represented by a given 0-indexed integer array cost of size n where cost[i] is the cost of node i + 1. You are allowed to increment the cost of any node by 1 any number of times.
Return the minimum number of increments you need to make the cost of paths from the root to each leaf node equal.
Note:
A perfect binary tree is a tree where each node, except the leaf nodes, has exactly 2 children.
The cost of a path is the sum of costs of nodes in the path.
","Example 1:

Input: n = 7, cost = [1,5,2,2,3,3,1]
Output: 6
Explanation: We can do the following increments:
- Increase the cost of node 4 one time.
- Increase the cost of node 3 three times.
- Increase the cost of node 7 two times.
Each path from the root to a leaf will have a total cost of 9.
The total increments we did is 1 + 3 + 2 = 6.
It can be shown that this is the minimum answer we can achieve.
Example 2:

Input: n = 3, cost = [5,3,3]
Output: 0
Explanation: The two paths already have equal total costs, so no increments are needed.
","class Solution:
    def minIncrements(self, n: int, cost: List[int]) -> int:
        idx, ans = n - 1, 0
        while idx >= 2:
            parent_idx = idx // 2 - 1
            child_cost = cost[idx]
            if cost[idx] != cost[idx - 1]:
                child_cost = max(cost[idx], cost[idx - 1])
                ans += abs(cost[idx] - cost[idx - 1])
            cost[parent_idx] += child_cost
            idx -= 2
        return ans",True
Semi-Ordered Permutation,"You are given a 0-indexed permutation of n integers nums.
A permutation is called semi-ordered if the first number equals 1 and the last number equals n. You can perform the below operation as many times as you want until you make nums a semi-ordered permutation:
Pick two adjacent elements in nums, then swap them.
Return the minimum number of operations to make nums a semi-ordered permutation.
A permutation is a sequence of integers from 1 to n of length n containing each number exactly once.
","Example 1:
Input: nums = [2,1,4,3]
Output: 2
Explanation: We can make the permutation semi-ordered using these sequence of operations: 
1 - swap i = 0 and j = 1. The permutation becomes [1,2,4,3].
2 - swap i = 2 and j = 3. The permutation becomes [1,2,3,4].
It can be proved that there is no sequence of less than two operations that make nums a semi-ordered permutation. 
Example 2:
Input: nums = [2,4,1,3]
Output: 3
Explanation: We can make the permutation semi-ordered using these sequence of operations:
1 - swap i = 1 and j = 2. The permutation becomes [2,1,4,3].
2 - swap i = 0 and j = 1. The permutation becomes [1,2,4,3].
3 - swap i = 2 and j = 3. The permutation becomes [1,2,3,4].
It can be proved that there is no sequence of less than three operations that make nums a semi-ordered permutation.
Example 3:
Input: nums = [1,3,4,2,5]
Output: 0
Explanation: The permutation is already a semi-ordered permutation.
","class Solution {
public:
    int semiOrderedPermutation(vector<int>& nums) {
        int n=nums.size();
        int cnt=0;
        bool f=false;
        while(f==false){
               for(int i=0;i<n;i++){
                   if(nums[i]==n & i!=(n-1)){
                       swap(nums[i],nums[i+1]);
                       cnt++;
                   }
                   if(nums[i]==1 && i!=0){
                       swap(nums[i], nums[i-1]);
                       cnt++;
                   }
               }
               if(nums[0]==1 && nums[n-1]==n){
                   f=true;
               }

        }
        return cnt;
    }
};",False
Movement of Robots,"Some robots are standing on an infinite number line with their initial coordinates given by a 0-indexed integer array nums and will start moving once given the command to move. The robots will move a unit distance each second.
You are given a string s denoting the direction in which robots will move on command. 'L' means the robot will move towards the left side or negative side of the number line, whereas 'R' means the robot will move towards the right side or positive side of the number line.
If two robots collide, they will start moving in opposite directions.
Return the sum of distances between all the pairs of robots d seconds after the command. Since the sum can be very large, return it modulo 109 + 7.
Note:
For two robots at the index i and j, pair (i,j) and pair (j,i) are considered the same pair.
When robots collide, they instantly change their directions without wasting any time.
Collision happens when two robots share the same place in a moment.
For example, if a robot is positioned in 0 going to the right and another is positioned in 2 going to the left, the next second they'll be both in 1 and they will change direction and the next second the first one will be in 0, heading left, and another will be in 2, heading right.
For example, if a robot is positioned in 0 going to the right and another is positioned in 1 going to the left, the next second the first one will be in 0, heading left, and another will be in 1, heading right.
","Example 1:
Input: nums = [-2,0,2], s = ""RLL"", d = 3
Output: 8
Explanation: 
After 1 second, the positions are [-1,-1,1]. Now, the robot at index 0 will move left, and the robot at index 1 will move right.
After 2 seconds, the positions are [-2,0,0]. Now, the robot at index 1 will move left, and the robot at index 2 will move right.
After 3 seconds, the positions are [-3,-1,1].
The distance between the robot at index 0 and 1 is abs(-3 - (-1)) = 2.
The distance between the robot at index 0 and 2 is abs(-3 - 1) = 4.
The distance between the robot at index 1 and 2 is abs(-1 - 1) = 2.
The sum of the pairs of all distances = 2 + 4 + 2 = 8.
Example 2:
Input: nums = [1,0], s = ""RL"", d = 2
Output: 5
Explanation: 
After 1 second, the positions are [2,-1].
After 2 seconds, the positions are [3,-2].
The distance between the two robots is abs(-2 - 3) = 5.
","class Solution:
    def sumDistance(self, nums: List[int], s: str, d: int) -> int:
        for i in range(len(s)):
            if s[i] == 'L':
                nums[i] -= d
            else:
                nums[i] += d
                
        ans = 0
        nums.sort()
        mod = 10 ** 9 + 7
        s = 0
        
        for i in range(len(nums)):
            ans += (nums[i] * i - s)
            s += nums[i]
            ans %= mod
            s %= mod
        
        return ans % mod",True
Find the Losers of the Circular Game,"There are n friends that are playing a game. The friends are sitting in a circle and are numbered from 1 to n in clockwise order. More formally, moving clockwise from the ith friend brings you to the (i+1)th friend for 1 <= i < n, and moving clockwise from the nth friend brings you to the 1st friend.
The rules of the game are as follows:
1st friend receives the ball.
After that, 1st friend passes it to the friend who is k steps away from them in the clockwise direction.
After that, the friend who receives the ball should pass it to the friend who is 2 * k steps away from them in the clockwise direction.
After that, the friend who receives the ball should pass it to the friend who is 3 * k steps away from them in the clockwise direction, and so on and so forth.
In other words, on the ith turn, the friend holding the ball should pass it to the friend who is i * k steps away from them in the clockwise direction.
The game is finished when some friend receives the ball for the second time.
The losers of the game are friends who did not receive the ball in the entire game.
Given the number of friends, n, and an integer k, return the array answer, which contains the losers of the game in the ascending order.
","Example 1:
Input: n = 5, k = 2
Output: [4,5]
Explanation: The game goes as follows:
1) Start at 1st friend and pass the ball to the friend who is 2 steps away from them - 3rd friend.
2) 3rd friend passes the ball to the friend who is 4 steps away from them - 2nd friend.
3) 2nd friend passes the ball to the friend who is 6 steps away from them  - 3rd friend.
4) The game ends as 3rd friend receives the ball for the second time.
Example 2:
Input: n = 4, k = 4
Output: [2,3,4]
Explanation: The game goes as follows:
1) Start at the 1st friend and pass the ball to the friend who is 4 steps away from them - 1st friend.
2) The game ends as 1st friend receives the ball for the second time.
","class Solution:
    def circularGameLosers(self, n: int, k: int) -> List[int]:
        res = [i for i in range(1,n+1)]
        res.remove(1)
        curr = 1
        count = 1
        while True:
            curr = (curr+(count*k))%n
            if curr == 0:
                curr = n
            if curr not in res:
                return res
            else:
                res.remove(curr)
            count+=1                ",True
Neighboring Bitwise XOR,"A 0-indexed array derived with length n is derived by computing the bitwise XOR (⊕) of adjacent values in a binary array original of length n.
Specifically, for each index i in the range [0, n - 1]:
If i = n - 1, then derived[i] = original[i] ⊕ original[0].
Otherwise, derived[i] = original[i] ⊕ original[i + 1].
Given an array derived, your task is to determine whether there exists a valid binary array original that could have formed derived.
Return true if such an array exists or false otherwise.
A binary array is an array containing only 0's and 1's
","Example 1:
Input: derived = [1,1,0]
Output: true
Explanation: A valid original array that gives derived is [0,1,0].
derived[0] = original[0] ⊕ original[1] = 0 ⊕ 1 = 1 
derived[1] = original[1] ⊕ original[2] = 1 ⊕ 0 = 1
derived[2] = original[2] ⊕ original[0] = 0 ⊕ 0 = 0
Example 2:
Input: derived = [1,1]
Output: true
Explanation: A valid original array that gives derived is [0,1].
derived[0] = original[0] ⊕ original[1] = 1
derived[1] = original[1] ⊕ original[0] = 1
Example 3:
Input: derived = [1,0]
Output: false
Explanation: There is no valid original array that gives derived.
","class Solution {
public:
    bool doesValidArrayExist(vector<int>& derived) {
        return !accumulate(derived.begin(), derived.end(), 0, bit_xor<int>());
    }
};",False
Maximum Number of Moves in a Grid,"You are given a 0-indexed m x n matrix grid consisting of positive integers.
You can start at any cell in the first column of the matrix, and traverse the grid in the following way:
From a cell (row, col), you can move to any of the cells: (row - 1, col + 1), (row, col + 1) and (row + 1, col + 1) such that the value of the cell you move to, should be strictly bigger than the value of the current cell.
Return the maximum number of moves that you can perform.
","Example 1:

Input: grid = [[2,4,3,5],[5,4,9,3],[3,4,2,11],[10,9,13,15]]
Output: 3
Explanation: We can start at the cell (0, 0) and make the following moves:
- (0, 0) -> (0, 1).
- (0, 1) -> (1, 2).
- (1, 2) -> (2, 3).
It can be shown that it is the maximum number of moves that can be made.
Example 2:
Input: grid = [[3,2,4],[2,1,9],[1,1,7]]
Output: 0
Explanation: Starting from any cell in the first column we cannot perform any moves.
","class Solution:
    def maxMoves(self, grid: List[List[int]]) -> int:
        dp={}
        def dfs(i,j):
            n=0
            n1=0
            n2=0
            if((i,j) in dp):return dp[(i,j)]
            if(i-1>=0 and j+1<len(grid[0]) and grid[i][j]<grid[i-1][j+1]):
                n=1+dfs(i-1,j+1)
            if(i>=0 and i<len(grid) and j+1<len(grid[0])):
                if(i+1<len(grid) and grid[i+1][j+1]>grid[i][j]):
                    n1=1+dfs(i+1,j+1)
                if(grid[i][j+1]>grid[i][j]):
                    n2=1+dfs(i,j+1)
            dp[(i,j)]=max(n,n1,n2)
            return dp[(i,j)]
        res=0
        for i in range(len(grid)):
            res=max(res,dfs(i,0))
        return res",True
Difference of Number of Distinct Values on Diagonals,"Given a 2D grid of size m x n, you should find the matrix answer of size m x n.
The cell answer[r][c] is calculated by looking at the diagonal values of the cell grid[r][c]:
Let leftAbove[r][c] be the number of distinct values on the diagonal to the left and above the cell grid[r][c] not including the cell grid[r][c] itself.
Let rightBelow[r][c] be the number of distinct values on the diagonal to the right and below the cell grid[r][c], not including the cell grid[r][c] itself.
Then answer[r][c] = |leftAbove[r][c] - rightBelow[r][c]|.
A matrix diagonal is a diagonal line of cells starting from some cell in either the topmost row or leftmost column and going in the bottom-right direction until the end of the matrix is reached.
For example, in the below diagram the diagonal is highlighted using the cell with indices (2, 3) colored gray:
Red-colored cells are left and above the cell.
Blue-colored cells are right and below the cell.

Return the matrix answer.
","Example 1:
Input: grid = [[1,2,3],[3,1,5],[3,2,1]]
Output: Output: [[1,1,0],[1,0,1],[0,1,1]]
Explanation:
To calculate the answer cells:
answer left-above elements leftAbove right-below elements rightBelow |leftAbove - rightBelow|
[0][0] [] 0 [grid[1][1], grid[2][2]] |{1, 1}| = 1 1
[0][1] [] 0 [grid[1][2]] |{5}| = 1 1
[0][2] [] 0 [] 0 0
[1][0] [] 0 [grid[2][1]] |{2}| = 1 1
[1][1] [grid[0][0]] |{1}| = 1 [grid[2][2]] |{1}| = 1 0
[1][2] [grid[0][1]] |{2}| = 1 [] 0 1
[2][0] [] 0 [] 0 0
[2][1] [grid[1][0]] |{3}| = 1 [] 0 1
[2][2] [grid[0][0], grid[1][1]] |{1, 1}| = 1 [] 0 1
Example 2:
Input: grid = [[1]]
Output: Output: [[0]]
","class Solution:
    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:
        row, col = len(grid), len(grid[0])
        ans = [[0] * col for i in range(row)]
        
        start = set([(i,0)for i in range(len(grid))]) | set([(0,i) for i in range(len(grid[0]))])
        for (i,j) in start:
            upper_dict = defaultdict(int)
            lower_dict = defaultdict(int)
            for j1 in range(len(grid)):
                if 0<= i +j1< row and 0<= j+j1< col:
                    lower_dict[grid[i+j1][j+j1]] += 1
            for j1 in range(len(grid)):
                if 0<= i +j1< row and 0<= j+j1< col:
                    ele = grid[i+j1][j+j1]
                    lower_dict[ele] -= 1
                    if lower_dict[ele] == 0: lower_dict.pop(ele)
                    ans[i+j1][j+j1] = abs(len(lower_dict) - len(upper_dict))
                    upper_dict[ele] += 1
            
        return ans        ",True
Number of Beautiful Pairs,"You are given a 0-indexed integer array nums. A pair of indices i, j where 0 <= i < j < nums.length is called beautiful if the first digit of nums[i] and the last digit of nums[j] are coprime.
Return the total number of beautiful pairs in nums.
Two integers x and y are coprime if there is no integer greater than 1 that divides both of them. In other words, x and y are coprime if gcd(x, y) == 1, where gcd(x, y) is the greatest common divisor of x and y.
","Example 1:
Input: nums = [2,5,1,4]
Output: 5
Explanation: There are 5 beautiful pairs in nums:
When i = 0 and j = 1: the first digit of nums[0] is 2, and the last digit of nums[1] is 5. We can confirm that 2 and 5 are coprime, since gcd(2,5) == 1.
When i = 0 and j = 2: the first digit of nums[0] is 2, and the last digit of nums[2] is 1. Indeed, gcd(2,1) == 1.
When i = 1 and j = 2: the first digit of nums[1] is 5, and the last digit of nums[2] is 1. Indeed, gcd(5,1) == 1.
When i = 1 and j = 3: the first digit of nums[1] is 5, and the last digit of nums[3] is 4. Indeed, gcd(5,4) == 1.
When i = 2 and j = 3: the first digit of nums[2] is 1, and the last digit of nums[3] is 4. Indeed, gcd(1,4) == 1.
Thus, we return 5.
Example 2:
Input: nums = [11,21,12]
Output: 2
Explanation: There are 2 beautiful pairs:
When i = 0 and j = 1: the first digit of nums[0] is 1, and the last digit of nums[1] is 1. Indeed, gcd(1,1) == 1.
When i = 0 and j = 2: the first digit of nums[0] is 1, and the last digit of nums[2] is 2. Indeed, gcd(1,2) == 1.
Thus, we return 2.
",,False
Relocate Marbles,"You are given a 0-indexed integer array nums representing the initial positions of some marbles. You are also given two 0-indexed integer arrays moveFrom and moveTo of equal length.
Throughout moveFrom.length steps, you will change the positions of the marbles. On the ith step, you will move all marbles at position moveFrom[i] to position moveTo[i].
After completing all the steps, return the sorted list of occupied positions.
Notes:
We call a position occupied if there is at least one marble in that position.
There may be multiple marbles in a single position.
","Example 1:
Input: nums = [1,6,7,8], moveFrom = [1,7,2], moveTo = [2,9,5]
Output: [5,6,8,9]
Explanation: Initially, the marbles are at positions 1,6,7,8.
At the i = 0th step, we move the marbles at position 1 to position 2. Then, positions 2,6,7,8 are occupied.
At the i = 1st step, we move the marbles at position 7 to position 9. Then, positions 2,6,8,9 are occupied.
At the i = 2nd step, we move the marbles at position 2 to position 5. Then, positions 5,6,8,9 are occupied.
At the end, the final positions containing at least one marbles are [5,6,8,9].
Example 2:
Input: nums = [1,1,3,3], moveFrom = [1,3], moveTo = [2,2]
Output: [2]
Explanation: Initially, the marbles are at positions [1,1,3,3].
At the i = 0th step, we move all the marbles at position 1 to position 2. Then, the marbles are at positions [2,2,3,3].
At the i = 1st step, we move all the marbles at position 3 to position 2. Then, the marbles are at positions [2,2,2,2].
Since 2 is the only occupied position, we return [2].
","class Solution:
    def relocateMarbles(self, nums: List[int], f: List[int], t: List[int]) -> List[int]:
        d = {}
        for i in nums:
            if i not in d:
                d[i] = 1
            else:
                d[i]+=1
        # print(d)
        for i,j in zip(f,t):
            if d.get(i) is not None:
                a = d[i]
                del d[i]
                d[j] = a        
        l = []
        for i in d:
            l += [i]*d[i]
        l.sort()
        return sorted(list((set(l))))
        
        ",True
Neither Minimum nor Maximum,"Given an integer array nums containing distinct positive integers, find and return any number from the array that is neither the minimum nor the maximum value in the array, or -1 if there is no such number.
Return the selected integer.
","Example 1:
Input: nums = [3,2,1,4]
Output: 2
Explanation: In this example, the minimum value is 1 and the maximum value is 4. Therefore, either 2 or 3 can be valid answers.
Example 2:
Input: nums = [1,2]
Output: -1
Explanation: Since there is no number in nums that is neither the maximum nor the minimum, we cannot select a number that satisfies the given condition. Therefore, there is no answer.
Example 3:
Input: nums = [2,1,3]
Output: 2
Explanation: Since 2 is neither the maximum nor the minimum value in nums, it is the only valid answer. 
","class Solution:
    def findNonMinOrMax(self, nums: List[int]) -> int:
        minimum, maximum = min(nums), max(nums)
        return next((num for num in nums if num not in (minimum, maximum)), -1)",True
Sum of Matrix After Queries,"You are given an integer n and a 0-indexed 2D array queries where queries[i] = [typei, indexi, vali].
Initially, there is a 0-indexed n x n matrix filled with 0's. For each query, you must apply one of the following changes:
if typei == 0, set the values in the row with indexi to vali, overwriting any previous values.
if typei == 1, set the values in the column with indexi to vali, overwriting any previous values.
Return the sum of integers in the matrix after all queries are applied.
","Example 1:

Input: n = 3, queries = [[0,0,1],[1,2,2],[0,2,3],[1,0,4]]
Output: 23
Explanation: The image above describes the matrix after each query. The sum of the matrix after all queries are applied is 23. 
Example 2:

Input: n = 3, queries = [[0,0,4],[0,1,2],[1,0,1],[0,2,3],[1,2,1]]
Output: 17
Explanation: The image above describes the matrix after each query. The sum of the matrix after all queries are applied is 17.
","class Solution:
    def matrixSumQueries(self, n, queries):
        ans = 0
        rsum = 0
        csum = 0
        mpr = {}
        mpc = {}
        queries.reverse()
        
        for it in queries:
            if it[0] == 0:
                # row
                r = it[1]
                val = it[2]
                if r not in mpr:
                    rsum += 1
                    mpr[r] = val
                    ans += val * (n - csum)
            else:
                # col
                c = it[1]
                val = it[2]
                if c not in mpc:
                    csum += 1
                    mpc[c] = val
                    ans += val * (n - rsum)
        
        return ans",True
Sum of Squares of Special Elements ,"You are given a 1-indexed integer array nums of length n.
An element nums[i] of nums is called special if i divides n, i.e. n % i == 0.
Return the sum of the squares of all special elements of nums.
","Example 1:
Input: nums = [1,2,3,4]
Output: 21
Explanation: There are exactly 3 special elements in nums: nums[1] since 1 divides 4, nums[2] since 2 divides 4, and nums[4] since 4 divides 4. 
Hence, the sum of the squares of all special elements of nums is nums[1] * nums[1] + nums[2] * nums[2] + nums[4] * nums[4] = 1 * 1 + 2 * 2 + 4 * 4 = 21.  
Example 2:
Input: nums = [2,7,1,19,18,3]
Output: 63
Explanation: There are exactly 4 special elements in nums: nums[1] since 1 divides 6, nums[2] since 2 divides 6, nums[3] since 3 divides 6, and nums[6] since 6 divides 6. 
Hence, the sum of the squares of all special elements of nums is nums[1] * nums[1] + nums[2] * nums[2] + nums[3] * nums[3] + nums[6] * nums[6] = 2 * 2 + 7 * 7 + 1 * 1 + 3 * 3 = 63. 
","class Solution:
    def sumOfSquares(self, nums: List[int]) -> int:
        #count of the sum of squares
        count=0
        #length of nums
        n=len(nums) 
        for i in range(0,n) :
            if  n%(i+1)==0:
                count+=nums[i]**2
        return count",True
Find the Value of the Partition,"You are given a positive integer array nums.
Partition nums into two arrays, nums1 and nums2, such that:
Each element of the array nums belongs to either the array nums1 or the array nums2.
Both arrays are non-empty.
The value of the partition is minimized.
The value of the partition is |max(nums1) - min(nums2)|.
Here, max(nums1) denotes the maximum element of the array nums1, and min(nums2) denotes the minimum element of the array nums2.
Return the integer denoting the value of such partition.
","Example 1:
Input: nums = [1,3,2,4]
Output: 1
Explanation: We can partition the array nums into nums1 = [1,2] and nums2 = [3,4].
- The maximum element of the array nums1 is equal to 2.
- The minimum element of the array nums2 is equal to 3.
The value of the partition is |2 - 3| = 1. 
It can be proven that 1 is the minimum value out of all partitions.
Example 2:
Input: nums = [100,1,10]
Output: 9
Explanation: We can partition the array nums into nums1 = [10] and nums2 = [100,1].
- The maximum element of the array nums1 is equal to 10.
- The minimum element of the array nums2 is equal to 1.
The value of the partition is |10 - 1| = 9.
It can be proven that 9 is the minimum value out of all partitions.
","class Solution {
public:
    int findValueOfPartition(vector<int>& nums) {
        int n= nums.size();
        sort(nums.begin(),nums.end());
        int mini= INT_MAX;
        for(int i=1; i<n; i++){
            mini= min(nums[i]-nums[i-1],mini);
        }
        return mini;
        
    }
};",False
Find Maximum Number of String Pairs,"You are given a 0-indexed array words consisting of distinct strings.
The string words[i] can be paired with the string words[j] if:
The string words[i] is equal to the reversed string of words[j].
0 <= i < j < words.length.
Return the maximum number of pairs that can be formed from the array words.
Note that each string can belong in at most one pair.
","Example 1:
Input: words = [""cd"",""ac"",""dc"",""ca"",""zz""]
Output: 2
Explanation: In this example, we can form 2 pair of strings in the following way:
- We pair the 0th string with the 2nd string, as the reversed string of word[0] is ""dc"" and is equal to words[2].
- We pair the 1st string with the 3rd string, as the reversed string of word[1] is ""ca"" and is equal to words[3].
It can be proven that 2 is the maximum number of pairs that can be formed.
Example 2:
Input: words = [""ab"",""ba"",""cc""]
Output: 1
Explanation: In this example, we can form 1 pair of strings in the following way:
- We pair the 0th string with the 1st string, as the reversed string of words[1] is ""ab"" and is equal to words[0].
It can be proven that 1 is the maximum number of pairs that can be formed.
Example 3:
Input: words = [""aa"",""ab""]
Output: 0
Explanation: In this example, we are unable to form any pair of strings.
","class Solution:
    def maximumNumberOfStringPairs(self, words: List[str]) -> int:
        strings = set()
        ans = 0
        for w in words:
            if w in strings:
                ans += 1
            else:
                strings.add(w[::-1])
        return ans",True
Decremental String Concatenation,"You are given a 0-indexed array words containing n strings.
Let's define a join operation join(x, y) between two strings x and y as concatenating them into xy. However, if the last character of x is equal to the first character of y, one of them is deleted.
For example join(""ab"", ""ba"") = ""aba"" and join(""ab"", ""cde"") = ""abcde"".
You are to perform n - 1 join operations. Let str0 = words[0]. Starting from i = 1 up to i = n - 1, for the ith operation, you can do one of the following:
Make stri = join(stri - 1, words[i])
Make stri = join(words[i], stri - 1)
Your task is to minimize the length of strn - 1.
Return an integer denoting the minimum possible length of strn - 1.
","Example 1:
Input: words = [""aa"",""ab"",""bc""]
Output: 4
Explanation: In this example, we can perform join operations in the following order to minimize the length of str2: 
str0 = ""aa""
str1 = join(str0, ""ab"") = ""aab""
str2 = join(str1, ""bc"") = ""aabc"" 
It can be shown that the minimum possible length of str2 is 4.
Example 2:
Input: words = [""ab"",""b""]
Output: 2
Explanation: In this example, str0 = ""ab"", there are two ways to get str1: 
join(str0, ""b"") = ""ab"" or join(""b"", str0) = ""bab"". 
The first string, ""ab"", has the minimum length. Hence, the answer is 2.
Example 3:
Input: words = [""aaa"",""c"",""aba""]
Output: 6
Explanation: In this example, we can perform join operations in the following order to minimize the length of str2: 
str0 = ""aaa""
str1 = join(str0, ""c"") = ""aaac""
str2 = join(""aba"", str1) = ""abaaac""
It can be shown that the minimum possible length of str2 is 6.
","class Solution:
    def minimizeConcatenatedLength(self, words: List[str]) -> int:
        N = len(words)
        C = 26
        cid = {chr(i + ord('a')) : i for i in range(C)}
        INF = float('-inf')
        
        # dp: max delete
        # assume dp[i][l][r]: step i, with (l, r) as left and right
        dp_l = [INF] * C   # [r]: dp[i][pl][r], pl ~ r
        dp_r = [INF] * C   # [l]: dp[i][l][pr], l ~ pr
        # Notice that for dp[i][l][r] to be valid, we need either l == pl or r == pr, so just using the two arrays above can save the info
        # We also derive update functions below to get rid of the [i] dimension
        
        # Previous l, r character
        pl = cid[words[0][0]]
        pr = cid[words[0][-1]]
        dp_l[pr] = dp_r[pl] = 0

        # max(dp_l), max(dp_r)
        lmax = rmax = 0

        # global add
        ladd = radd = 0
        
        for i in range(1, N):
            # Current l, r character
            cl = cid[words[i][0]]
            cr = cid[words[i][-1]]

            # To update dp_l:
            # dp_l[r] = dp[i][pl][r] = max(dp[i-1][_l][r] + (_l == cr))
            # (1) if r != pr, it's dp[i-1][pl][r] = dp_l[r] (no change); if pl == cr, should +1 (below)
            # (2) if r == pr, it's max(dp[i-1][_l][r] + (_l == cr)) = max(dp_r) and if best _l == cr, should +1 (here)
            # same for updating dp_r
            _lmax = lmax + (dp_l[cl] == lmax)   # the (2) case for updating dp_r
            _rmax = rmax + (dp_r[cr] == rmax)   # the (2) case for updating dp_l
            new_ladd = ladd + (pl == cr)        # the (1) case (add to this global variable instead of each element to improve complexity)
            new_radd = radd + (pr == cl)        # the (1) case
            dp_l[pr] = _rmax + radd - new_ladd  # the (1) case for dp_l, if ladd incremented, this essentially -1, cancelling out the +1 on dp_l[pr]
            dp_r[pl] = _lmax + ladd - new_radd  # the (1) case for dp_r
            ladd = new_ladd
            radd = new_radd

            # state (cl, cr) is maintained in both, should sync
            dp_l[cr] = max(dp_l[cr], dp_r[cl] + radd - ladd)
            dp_r[cl] = max(dp_r[cl], dp_l[cr] + ladd - radd)

            # only these entries are updated
            lmax = max([lmax, dp_l[pr], dp_l[cr]])
            rmax = max([rmax, dp_r[pl], dp_r[cl]])

            pl = cl
            pr = cr
        
        return sum([len(w) for w in words]) - max(lmax + ladd, rmax + radd)

",True
Maximum Number of Jumps to Reach the Last Index,"You are given a 0-indexed array nums of n integers and an integer target.
You are initially positioned at index 0. In one step, you can jump from index i to any index j such that:
0 <= i < j < n
-target <= nums[j] - nums[i] <= target
Return the maximum number of jumps you can make to reach index n - 1.
If there is no way to reach index n - 1, return -1.
","Example 1:
Input: nums = [1,3,6,4,1,2], target = 2
Output: 3
Explanation: To go from index 0 to index n - 1 with the maximum number of jumps, you can perform the following jumping sequence:
- Jump from index 0 to index 1. 
- Jump from index 1 to index 3.
- Jump from index 3 to index 5.
It can be proven that there is no other jumping sequence that goes from 0 to n - 1 with more than 3 jumps. Hence, the answer is 3. 
Example 2:
Input: nums = [1,3,6,4,1,2], target = 3
Output: 5
Explanation: To go from index 0 to index n - 1 with the maximum number of jumps, you can perform the following jumping sequence:
- Jump from index 0 to index 1.
- Jump from index 1 to index 2.
- Jump from index 2 to index 3.
- Jump from index 3 to index 4.
- Jump from index 4 to index 5.
It can be proven that there is no other jumping sequence that goes from 0 to n - 1 with more than 5 jumps. Hence, the answer is 5. 
Example 3:
Input: nums = [1,3,6,4,1,2], target = 0
Output: -1
Explanation: It can be proven that there is no jumping sequence that goes from 0 to n - 1. Hence, the answer is -1. 
","class Solution:
    def maximumJumps(self, nums: List[int], target: int) -> int:
        dp = [-1] * len(nums)
        dp[0] = 0
        for i in range(len(nums)):
            if dp[i] == -1: continue
            for j in range(i + 1, len(nums)):
                if abs(nums[j] - nums[i]) <= target:   
                    dp[j] = max(dp[i] + 1, dp[j])
        return dp[-1]",True
Count Complete Subarrays in an Array,"You are given an array nums consisting of positive integers.
We call a subarray of an array complete if the following condition is satisfied:
The number of distinct elements in the subarray is equal to the number of distinct elements in the whole array.
Return the number of complete subarrays.
A subarray is a contiguous non-empty part of an array.
","Example 1:
Input: nums = [1,3,1,2,2]
Output: 4
Explanation: The complete subarrays are the following: [1,3,1,2], [1,3,1,2,2], [3,1,2] and [3,1,2,2].
Example 2:
Input: nums = [5,5,5,5]
Output: 10
Explanation: The array consists only of the integer 5, so any subarray is complete. The number of subarrays that we can choose is 10.
","class Solution {
public:
    int countCompleteSubarrays(vector<int>& nums){
        unordered_set<int> freq(nums.begin(), nums.end());

        int count = 0;
        for (int i = 0; i < nums.size(); i++) {
            unordered_set<int> subFreq;
            for (int j = i; j < nums.size(); j++) {
                subFreq.insert(nums[j]);
                if (subFreq.size() == freq.size()) {
                    count++;
                }
            }
        }

        return count;
    }
};",False
Longest Even Odd Subarray With Threshold,"You are given a 0-indexed integer array nums and an integer threshold.
Find the length of the longest subarray of nums starting at index l and ending at index r (0 <= l <= r < nums.length) that satisfies the following conditions:
nums[l] % 2 == 0
For all indices i in the range [l, r - 1], nums[i] % 2 != nums[i + 1] % 2
For all indices i in the range [l, r], nums[i] <= threshold
Return an integer denoting the length of the longest such subarray.
Note: A subarray is a contiguous non-empty sequence of elements within an array.
","Example 1:
Input: nums = [3,2,5,4], threshold = 5
Output: 3
Explanation: In this example, we can select the subarray that starts at l = 1 and ends at r = 3 => [2,5,4]. This subarray satisfies the conditions.
Hence, the answer is the length of the subarray, 3. We can show that 3 is the maximum possible achievable length.
Example 2:
Input: nums = [1,2], threshold = 2
Output: 1
Explanation: In this example, we can select the subarray that starts at l = 1 and ends at r = 1 => [2]. 
It satisfies all the conditions and we can show that 1 is the maximum possible achievable length.
Example 3:
Input: nums = [2,3,4,5], threshold = 4
Output: 3
Explanation: In this example, we can select the subarray that starts at l = 0 and ends at r = 2 => [2,3,4]. 
It satisfies all the conditions.
Hence, the answer is the length of the subarray, 3. We can show that 3 is the maximum possible achievable length.
","class Solution:
    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:
        ans = 0
        for l in range(len(nums)):
            # check nums[l] is valid
            if nums[l] % 2 == 0 and nums[l] <= threshold:
                ans = max(ans, 1) # nums[l] is valid
                # check l+1 to the last element
                # break if any condition is not satisfied
                for r in range(l+1, len(nums)):
                    if nums[r] % 2 == nums[r-1] % 2:
                        break
                    if nums[r] > threshold:
                        break
                    # if ok, the length is r-l+1
                    ans = max(ans, r - l + 1)
        return ans
                
                ",True
Ways to Split Array Into Good Subarrays,"You are given a binary array nums.
A subarray of an array is good if it contains exactly one element with the value 1.
Return an integer denoting the number of ways to split the array nums into good subarrays. As the number may be too large, return it modulo 109 + 7.
A subarray is a contiguous non-empty sequence of elements within an array.
","Example 1:
Input: nums = [0,1,0,0,1]
Output: 3
Explanation: There are 3 ways to split nums into good subarrays:
- [0,1] [0,0,1]
- [0,1,0] [0,1]
- [0,1,0,0] [1]
Example 2:
Input: nums = [0,1,0]
Output: 1
Explanation: There is 1 way to split nums into good subarrays:
- [0,1,0]
",,False
Continuous Subarrays,"You are given a 0-indexed integer array nums. A subarray of nums is called continuous if:
Let i, i + 1, ..., j be the indices in the subarray. Then, for each pair of indices i <= i1, i2 <= j, 0 <= |nums[i1] - nums[i2]| <= 2.
Return the total number of continuous subarrays.
A subarray is a contiguous non-empty sequence of elements within an array.
","Example 1:
Input: nums = [5,4,2,4]
Output: 8
Explanation: 
Continuous subarray of size 1: [5], [4], [2], [4].
Continuous subarray of size 2: [5,4], [4,2], [2,4].
Continuous subarray of size 3: [4,2,4].
Thereare no subarrys of size 4.
Total continuous subarrays = 4 + 3 + 1 = 8.
It can be shown that there are no more continuous subarrays.
","class Solution:
    def continuousSubarrays(self, nums: List[int]) -> int:
        st = deque()
        st2 = deque()
        i = 0
        ans = 0
        j = 0
        while i < len(nums):
            if not st or st[-1] >= nums[i]:
                st.append(nums[i])
            else:
                while st and st[-1] < nums[i]:
                    st.pop()
                st.append(nums[i])
            while st and st[0] > nums[i] + 2:
                while nums[j] != st[0]:
                    j+=1
                st.popleft()
                j+=1
            
            if not st2 or st2[-1] <= nums[i]:
                st2.append(nums[i])
            else:
                while st2 and st2[-1] > nums[i]:
                    st2.pop()
                st2.append(nums[i])
            while st2 and st2[0] < nums[i] - 2:
                while nums[j] != st2[0]:
                    j+=1
                st2.popleft()
                j+=1
            ans += i-j+1
            i+=1
            # print(st,i,j)
        return ans
        
            
                
",True
Longest Non-decreasing Subarray From Two Arrays,"You are given two 0-indexed integer arrays nums1 and nums2 of length n.
Let's define another 0-indexed integer array, nums3, of length n. For each index i in the range [0, n - 1], you can assign either nums1[i] or nums2[i] to nums3[i].
Your task is to maximize the length of the longest non-decreasing subarray in nums3 by choosing its values optimally.
Return an integer representing the length of the longest non-decreasing subarray in nums3.
Note: A subarray is a contiguous non-empty sequence of elements within an array.
","Example 1:
Input: nums1 = [2,3,1], nums2 = [1,2,1]
Output: 2
Explanation: One way to construct nums3 is: 
nums3 = [nums1[0], nums2[1], nums2[2]] => [2,2,1]. 
The subarray starting from index 0 and ending at index 1, [2,2], forms a non-decreasing subarray of length 2. 
We can show that 2 is the maximum achievable length.
Example 2:
Input: nums1 = [1,3,2,1], nums2 = [2,2,3,4]
Output: 4
Explanation: One way to construct nums3 is: 
nums3 = [nums1[0], nums2[1], nums2[2], nums2[3]] => [1,2,3,4]. 
The entire array forms a non-decreasing subarray of length 4, making it the maximum achievable length.
Example 3:
Input: nums1 = [1,1], nums2 = [2,2]
Output: 2
Explanation: One way to construct nums3 is: 
nums3 = [nums1[0], nums1[1]] => [1,1]. 
The entire array forms a non-decreasing subarray of length 2, making it the maximum achievable length.
","class Solution:
    def maxNonDecreasingLength(self, nums1: List[int], nums2: List[int]) -> int:
        prev_elems = (0, 0)
        prev_lengths = [0, 0]
        
        result = 0

        for elems in zip(nums1, nums2):
            current_lengths = [1, 1]
            for i, elem in enumerate(elems):
                for j, prev_elem in enumerate(prev_elems):
                    if elem >= prev_elem:
                        current_lengths[i] = max(current_lengths[i], prev_lengths[j] + 1)
            
            result = max(result, max(current_lengths))

            prev_elems = elems
            prev_lengths = current_lengths
        
        return result",True
Longest Alternating Subarray,"You are given a 0-indexed integer array nums. A subarray s of length m is called alternating if:
m is greater than 1.
s1 = s0 + 1.
The 0-indexed subarray s looks like [s0, s1, s0, s1,...,s(m-1) % 2]. In other words, s1 - s0 = 1, s2 - s1 = -1, s3 - s2 = 1, s4 - s3 = -1, and so on up to s[m - 1] - s[m - 2] = (-1)m.
Return the maximum length of all alternating subarrays present in nums or -1 if no such subarray exists.
A subarray is a contiguous non-empty sequence of elements within an array.
","Example 1:
Input: nums = [2,3,4,3,4]
Output: 4
Explanation: The alternating subarrays are [3,4], [3,4,3], and [3,4,3,4]. The longest of these is [3,4,3,4], which is of length 4.
Example 2:
Input: nums = [4,5,6]
Output: 2
Explanation: [4,5] and [5,6] are the only two alternating subarrays. They are both of length 2.
","class Solution:
    def alternatingSubarray(self, nums: List[int]) -> int:
        n = len(nums) 
        res = dp = -1 
        for i in range(1, n): 
            if dp > 0 and nums[i] == nums[i - 2]: 
                dp += 1 
            else: 
                dp = 2 if nums[i] == nums[i - 1] + 1 else -1 
            res = max(res, dp) 
        return res ",True
Largest Element in an Array after Merge Operations,"You are given a 0-indexed array nums consisting of positive integers.
You can do the following operation on the array any number of times:
Choose an integer i such that 0 <= i < nums.length - 1 and nums[i] <= nums[i + 1]. Replace the element nums[i + 1] with nums[i] + nums[i + 1] and delete the element nums[i] from the array.
Return the value of the largest element that you can possibly obtain in the final array.
","Example 1:
Input: nums = [2,3,7,9,3]
Output: 21
Explanation: We can apply the following operations on the array:
- Choose i = 0. The resulting array will be nums = [5,7,9,3].
- Choose i = 1. The resulting array will be nums = [5,16,3].
- Choose i = 0. The resulting array will be nums = [21,3].
The largest element in the final array is 21. It can be shown that we cannot obtain a larger element.
Example 2:
Input: nums = [5,3,3]
Output: 11
Explanation: We can do the following operations on the array:
- Choose i = 1. The resulting array will be nums = [5,6].
- Choose i = 0. The resulting array will be nums = [11].
There is only one element in the final array, which is 11.
","class Solution:
    def maxArrayValue(self, nums: List[int]) -> int:
        n=len(nums)
        for i in range(n-1,0,-1):
            if nums[i-1]<=nums[i]:
                nums[i-1]=nums[i-1]+nums[i]

        return nums[0]        ",True
Prime Pairs With Target Sum,"You are given an integer n. We say that two integers x and y form a prime number pair if:
1 <= x <= y <= n
x + y == n
x and y are prime numbers
Return the 2D sorted list of prime number pairs [xi, yi]. The list should be sorted in increasing order of xi. If there are no prime number pairs at all, return an empty array.
Note: A prime number is a natural number greater than 1 with only two factors, itself and 1.
","Example 1:
Input: n = 10
Output: [[3,7],[5,5]]
Explanation: In this example, there are two prime pairs that satisfy the criteria. 
These pairs are [3,7] and [5,5], and we return them in the sorted order as described in the problem statement.
Example 2:
Input: n = 2
Output: []
Explanation: We can show that there is no prime number pair that gives a sum of 2, so we return an empty array. 
","class Solution:
    def findPrimePairs(self, n: int) -> List[List[int]]:
        def generate_primes(n):
            prime = [True]*(n+1)
            prime[0] = prime[1] = False
            p = 2
            while p*p<=n:
                if prime[p]:
                    for num in range(p*p,n+1,p):
                        prime[num] = False               
                p+=1
        
            ans = []
            for i in range(2,n+1):
                if prime[i]:
                    ans.append(i)
            return ans
        
        prime = generate_primes(n)
        l,r=0,len(prime)-1
        ans =[]
        while(l<=r):
            if prime[l]+ prime[r] == n:
                ans.append([prime[l],prime[r]])
                l+=1
                r-=1
            elif prime[l]+ prime[r] <n:
                l+=1
            else:
                r-=1
        return ans",True
Number of Employees Who Met the Target,"There are n employees in a company, numbered from 0 to n - 1. Each employee i has worked for hours[i] hours in the company.
The company requires each employee to work for at least target hours.
You are given a 0-indexed array of non-negative integers hours of length n and a non-negative integer target.
Return the integer denoting the number of employees who worked at least target hours.
","Example 1:
Input: hours = [0,1,2,3,4], target = 2
Output: 3
Explanation: The company wants each employee to work for at least 2 hours.
- Employee 0 worked for 0 hours and didn't meet the target.
- Employee 1 worked for 1 hours and didn't meet the target.
- Employee 2 worked for 2 hours and met the target.
- Employee 3 worked for 3 hours and met the target.
- Employee 4 worked for 4 hours and met the target.
There are 3 employees who met the target.
Example 2:
Input: hours = [5,1,4,2,2], target = 6
Output: 0
Explanation: The company wants each employee to work for at least 6 hours.
There are 0 employees who met the target.
","class Solution {
  int numberOfEmployeesWhoMetTarget(List<int> hours, int target) {
   int count=0;
   for(int i=0;i<hours.length;i++){
    if(hours[i]>=target){
        count+=1;
    }
   }
   return count;
  }
}",False
Minimum Index of a Valid Split,"An element x of an integer array arr of length m is dominant if freq(x) * 2 > m, where freq(x) is the number of occurrences of x in arr. Note that this definition implies that arr can have at most one dominant element.
You are given a 0-indexed integer array nums of length n with one dominant element.
You can split nums at an index i into two arrays nums[0, ..., i] and nums[i + 1, ..., n - 1], but the split is only valid if:
0 <= i < n - 1
nums[0, ..., i], and nums[i + 1, ..., n - 1] have the same dominant element.
Here, nums[i, ..., j] denotes the subarray of nums starting at index i and ending at index j, both ends being inclusive. Particularly, if j < i then nums[i, ..., j] denotes an empty subarray.
Return the minimum index of a valid split. If no valid split exists, return -1.
","Example 1:
Input: nums = [1,2,2,2]
Output: 2
Explanation: We can split the array at index 2 to obtain arrays [1,2,2] and [2]. 
In array [1,2,2], element 2 is dominant since it occurs twice in the array and 2 * 2 > 3. 
In array [2], element 2 is dominant since it occurs once in the array and 1 * 2 > 1.
Both [1,2,2] and [2] have the same dominant element as nums, so this is a valid split. 
It can be shown that index 2 is the minimum index of a valid split. 
Example 2:
Input: nums = [2,1,3,1,1,1,7,1,2,1]
Output: 4
Explanation: We can split the array at index 4 to obtain arrays [2,1,3,1,1] and [1,7,1,2,1].
In array [2,1,3,1,1], element 1 is dominant since it occurs thrice in the array and 3 * 2 > 5.
In array [1,7,1,2,1], element 1 is dominant since it occurs thrice in the array and 3 * 2 > 5.
Both [2,1,3,1,1] and [1,7,1,2,1] have the same dominant element as nums, so this is a valid split.
It can be shown that index 4 is the minimum index of a valid split.
Example 3:
Input: nums = [3,3,3,3,7,2,2]
Output: -1
Explanation: It can be shown that there is no valid split.
","class Solution:
    def minimumIndex(self, nums: List[int]) -> int:
        maxi=0

        freq=collections.defaultdict(int)
        for num in nums:
            freq[num]+=1
        maxi=0
        value=0
        n=len(nums)
        for num in freq:
            if freq[num]>maxi:
                maxi=freq[num]
                value=num
        cnt=0
        for i in range(n):
            if nums[i]==value:
                cnt+=1
                if cnt*2>(i+1):
                    break
        

        if (n-(i+1))>=(maxi-cnt)*2:
            return -1
        return i ",True
Maximum Beauty of an Array After Applying Operation,"You are given a 0-indexed array nums and a non-negative integer k.
In one operation, you can do the following:
Choose an index i that hasn't been chosen before from the range [0, nums.length - 1].
Replace nums[i] with any integer from the range [nums[i] - k, nums[i] + k].
The beauty of the array is the length of the longest subsequence consisting of equal elements.
Return the maximum possible beauty of the array nums after applying the operation any number of times.
Note that you can apply the operation to each index only once.
A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the order of the remaining elements.
","Example 1:
Input: nums = [4,6,1,2], k = 2
Output: 3
Explanation: In this example, we apply the following operations:
- Choose index 1, replace it with 4 (from range [4,8]), nums = [4,4,1,2].
- Choose index 3, replace it with 4 (from range [0,4]), nums = [4,4,1,4].
After the applied operations, the beauty of the array nums is 3 (subsequence consisting of indices 0, 1, and 3).
It can be proven that 3 is the maximum possible length we can achieve.
Example 2:
Input: nums = [1,1,1,1], k = 10
Output: 4
Explanation: In this example we don't have to apply any operations.
The beauty of the array nums is 4 (whole array).
","class Solution:
    def maximumBeauty(self, nums: List[int], k: int) -> int:
        max_a, max_b = -1, -1
        
        nums.sort(reverse=True)
        maxA = 0
        j = 0
        for i in range(len(nums)):
            max_a, max_b = nums[i] - k, nums[i] + k
            while (j < len(nums) and nums[j] + k >= max_a and nums[j] + k <= max_b):
                j += 1
                maxA = max(maxA, j - i)
        return maxA
            ",True
Check if Array is Good,"You are given an integer array nums. We consider an array good if it is a permutation of an array base[n].
base[n] = [1, 2, ..., n - 1, n, n] (in other words, it is an array of length n + 1 which contains 1 to n - 1 exactly once, plus two occurrences of n). For example, base[1] = [1, 1] and base[3] = [1, 2, 3, 3].
Return true if the given array is good, otherwise return false.
Note: A permutation of integers represents an arrangement of these numbers.
","Example 1:
Input: nums = [2, 1, 3]
Output: false
Explanation: Since the maximum element of the array is 3, the only candidate n for which this array could be a permutation of base[n], is n = 3. However, base[3] has four elements but array nums has three. Therefore, it can not be a permutation of base[3] = [1, 2, 3, 3]. So the answer is false.
Example 2:
Input: nums = [1, 3, 3, 2]
Output: true
Explanation: Since the maximum element of the array is 3, the only candidate n for which this array could be a permutation of base[n], is n = 3. It can be seen that nums is a permutation of base[3] = [1, 2, 3, 3] (by swapping the second and fourth elements in nums, we reach base[3]). Therefore, the answer is true.
Example 3:
Input: nums = [1, 1]
Output: true
Explanation: Since the maximum element of the array is 1, the only candidate n for which this array could be a permutation of base[n], is n = 1. It can be seen that nums is a permutation of base[1] = [1, 1]. Therefore, the answer is true.
Example 4:
Input: nums = [3, 4, 4, 1, 2, 1]
Output: false
Explanation: Since the maximum element of the array is 4, the only candidate n for which this array could be a permutation of base[n], is n = 4. However, base[4] has five elements but array nums has six. Therefore, it can not be a permutation of base[4] = [1, 2, 3, 4, 4]. So the answer is false.
","class Solution:
    def isGood(self, nums: List[int]) -> bool:
        return min(nums)==1 and max(nums)==len(nums)-1 and nums.count(len(nums)-1)==2 and len(set(nums))==len(nums)-1",True
Visit Array Positions to Maximize Score,"You are given a 0-indexed integer array nums and a positive integer x.
You are initially at position 0 in the array and you can visit other positions according to the following rules:
If you are currently in position i, then you can move to any position j such that i < j.
For each position i that you visit, you get a score of nums[i].
If you move from a position i to a position j and the parities of nums[i] and nums[j] differ, then you lose a score of x.
Return the maximum total score you can get.
Note that initially you have nums[0] points.
","Example 1:
Input: nums = [2,3,6,1,9,2], x = 5
Output: 13
Explanation: We can visit the following positions in the array: 0 -> 2 -> 3 -> 4.
The corresponding values are 2, 6, 1 and 9. Since the integers 6 and 1 have different parities, the move 2 -> 3 will make you lose a score of x = 5.
The total score will be: 2 + 6 + 1 + 9 - 5 = 13.
Example 2:
Input: nums = [2,4,6,8], x = 3
Output: 20
Explanation: All the integers in the array have the same parities, so we can visit all of them without losing any score.
The total score is: 2 + 4 + 6 + 8 = 20.
","class Solution:
    def maxScore(self, nums: List[int], x: int) -> int:
        
        #defining memorization
        memo = {}
        def dp(i,prev):
            #if the curr index is greater then or equal to the length of the array return 0
            if i >= len(nums):
                return 0

            #if previously computed then return the precomputed result
            elif (i,prev) in memo:
                return memo[(i,prev)]
            else:
                #if parities is equal
                if prev==nums[i]%2:
                    left = dp(i+1,nums[i]%2)+nums[i]
                #if parities is not equal
                else:
                    left = dp(i+1,nums[i]%2)+nums[i]-x

                #if not consider the current index
                memo[(i,prev)] = max(left,dp(i+1,prev))
                return memo[(i,prev)]

        return dp(1,nums[0]%2) +nums[0]",True
Max Pair Sum in an Array,"You are given an integer array nums. You have to find the maximum sum of a pair of numbers from nums such that the largest digit in both numbers is equal.
For example, 2373 is made up of three distinct digits: 2, 3, and 7, where 7 is the largest among them.
Return the maximum sum or -1 if no such pair exists.
","Example 1:
Input: nums = [112,131,411]
Output: -1
Explanation:
Each numbers largest digit in order is [2,3,4].
Example 2:
Input: nums = [2536,1613,3366,162]
Output: 5902
Explanation:
All the numbers have 6 as their largest digit, so the answer is 2536 + 3366 = 5902.
Example 3:
Input: nums = [51,71,17,24,42]
Output: 88
Explanation:
Each number's largest digit in order is [5,7,7,4,4].
So we have only two possible pairs, 71 + 17 = 88 and 24 + 42 = 66.
","class Solution {
 int
   maxSum(List<int> nums) {

int temp=0;

for(int i=0;i<nums.length-1;i++){
int max1 =maxDigit(nums[i]);
  for(int j=i+1;j<nums.length;j++){
      int max2 =maxDigit(nums[j]);
    if(max1==max2){
      int sum = nums[i]+nums[j];

      if(sum> temp){
          temp=sum;
      }
    }
  }

}
return temp==0? -1:temp;

  }


int maxDigit(int x){
 List<int> val = x.toString().split('').map((e)=>int.parse(e)).toList();
 int value = val.reduce(max);
return value;
}


}",False
Find the Safest Path in a Grid,"You are given a 0-indexed 2D matrix grid of size n x n, where (r, c) represents:
A cell containing a thief if grid[r][c] = 1
An empty cell if grid[r][c] = 0
You are initially positioned at cell (0, 0). In one move, you can move to any adjacent cell in the grid, including cells containing thieves.
The safeness factor of a path on the grid is defined as the minimum manhattan distance from any cell in the path to any thief in the grid.
Return the maximum safeness factor of all paths leading to cell (n - 1, n - 1).
An adjacent cell of cell (r, c), is one of the cells (r, c + 1), (r, c - 1), (r + 1, c) and (r - 1, c) if it exists.
The Manhattan distance between two cells (a, b) and (x, y) is equal to |a - x| + |b - y|, where |val| denotes the absolute value of val.
","Example 1:

Input: grid = [[1,0,0],[0,0,0],[0,0,1]]
Output: 0
Explanation: All paths from (0, 0) to (n - 1, n - 1) go through the thieves in cells (0, 0) and (n - 1, n - 1).
Example 2:

Input: grid = [[0,0,1],[0,0,0],[0,0,0]]
Output: 2
Explanation: The path depicted in the picture above has a safeness factor of 2 since:
- The closest cell of the path to the thief at cell (0, 2) is cell (0, 0). The distance between them is | 0 - 0 | + | 0 - 2 | = 2.
It can be shown that there are no other paths with a higher safeness factor.
Example 3:

Input: grid = [[0,0,0,1],[0,0,0,0],[0,0,0,0],[1,0,0,0]]
Output: 2
Explanation: The path depicted in the picture above has a safeness factor of 2 since:
- The closest cell of the path to the thief at cell (0, 3) is cell (1, 2). The distance between them is | 0 - 1 | + | 3 - 2 | = 2.
- The closest cell of the path to the thief at cell (3, 0) is cell (3, 2). The distance between them is | 3 - 3 | + | 0 - 2 | = 2.
It can be shown that there are no other paths with a higher safeness factor.
","class Solution:
    def __init__(self):
        self.roww = [0, 0, -1, 1]
        self.coll = [-1, 1, 0, 0]

    def bfs(self, grid, score, n):
        q = deque()

        for i in range(n):
            for j in range(n):
                if grid[i][j]:
                    score[i][j] = 0
                    q.append((i, j))

        while q:
            x, y = q.popleft()
            s = score[x][y]

            for i in range(4):
                new_x = x + self.roww[i]
                new_y = y + self.coll[i]

                if 0 <= new_x < n and 0 <= new_y < n and score[new_x][new_y] > s + 1:
                    score[new_x][new_y] = s + 1
                    q.append((new_x, new_y))

    def maximumSafenessFactor(self, grid):
        n = len(grid)
        if grid[0][0] or grid[n - 1][n - 1]:
            return 0

        score = [[float('inf')] * n for _ in range(n)]
        self.bfs(grid, score, n)

        vis = [[False] * n for _ in range(n)]
        pq = [(-score[0][0], 0, 0)]
        heapq.heapify(pq)

        while pq:
            safe, x, y = heapq.heappop(pq)
            safe = -safe

            if x == n - 1 and y == n - 1:
                return safe

            vis[x][y] = True

            for i in range(4):
                new_x = x + self.roww[i]
                new_y = y + self.coll[i]

                if 0 <= new_x < n and 0 <= new_y < n and not vis[new_x][new_y]:
                    s = min(safe, score[new_x][new_y])
                    heapq.heappush(pq, (-s, new_x, new_y))
                    vis[new_x][new_y] = True

        return -1
",True
Check if it is Possible to Split Array,"You are given an array nums of length n and an integer m. You need to determine if it is possible to split the array into n non-empty arrays by performing a series of steps.
In each step, you can select an existing array (which may be the result of previous steps) with a length of at least two and split it into two subarrays, if, for each resulting subarray, at least one of the following holds:
The length of the subarray is one, or
The sum of elements of the subarray is greater than or equal to m.
Return true if you can split the given array into n arrays, otherwise return false.
Note: A subarray is a contiguous non-empty sequence of elements within an array.
","Example 1:
Input: nums = [2, 2, 1], m = 4
Output: true
Explanation: We can split the array into [2, 2] and [1] in the first step. Then, in the second step, we can split [2, 2] into [2] and [2]. As a result, the answer is true.
Example 2:
Input: nums = [2, 1, 3], m = 5 
Output: false
Explanation: We can try splitting the array in two different ways: the first way is to have [2, 1] and [3], and the second way is to have [2] and [1, 3]. However, both of these ways are not valid. So, the answer is false.
Example 3:
Input: nums = [2, 3, 3, 2, 3], m = 6
Output: true
Explanation: We can split the array into [2, 3, 3, 2] and [3] in the first step. Then, in the second step, we can split [2, 3, 3, 2] into [2, 3, 3] and [2]. Then, in the third step, we can split [2, 3, 3] into [2] and [3, 3]. And in the last step we can split [3, 3] into [3] and [3]. As a result, the answer is true.
","class Solution:
    def canSplitArray(self, nums: List[int], m: int) -> bool:
        n = len(nums)
        if n<=2: #can split into two length==1's lists
            return True

        for i in range(1, n): # if there no (nums[i-1]+nums[i]) >= m will be false  
            if nums[i-1]+nums[i] >= m:
                return True

        return False
    ",True
Count Pairs Whose Sum is Less than Target,"0-indexed
nums
n
target
the number of pairs
(i, j)
where
0 <= i < j < n
and
nums[i] + nums[j] < target
","Example 1:
Input: nums = [-1,1,2,3,1], target = 2
Output: 3
Explanation: There are 3 pairs of indices that satisfy the conditions in the statement:
- (0, 1) since 0 < 1 and nums[0] + nums[1] = 0 < target
- (0, 2) since 0 < 2 and nums[0] + nums[2] = 1 < target 
- (0, 4) since 0 < 4 and nums[0] + nums[4] = 0 < target
Note that (0, 3) is not counted since nums[0] + nums[3] is not strictly less than the target.
Example 2:
Input: nums = [-6,2,5,-2,-7,-1,3], target = -2
Output: 10
Explanation: There are 10 pairs of indices that satisfy the conditions in the statement:
- (0, 1) since 0 < 1 and nums[0] + nums[1] = -4 < target
- (0, 3) since 0 < 3 and nums[0] + nums[3] = -8 < target
- (0, 4) since 0 < 4 and nums[0] + nums[4] = -13 < target
- (0, 5) since 0 < 5 and nums[0] + nums[5] = -7 < target
- (0, 6) since 0 < 6 and nums[0] + nums[6] = -3 < target
- (1, 4) since 1 < 4 and nums[1] + nums[4] = -5 < target
- (3, 4) since 3 < 4 and nums[3] + nums[4] = -9 < target
- (3, 5) since 3 < 5 and nums[3] + nums[5] = -3 < target
- (4, 5) since 4 < 5 and nums[4] + nums[5] = -8 < target
- (4, 6) since 4 < 6 and nums[4] + nums[6] = -4 < target
","class Solution(object):
    def countPairs(self, nums, target):
        n = len(nums)

        nums.sort()

        c = 0
        l = 0
        r = n-1

        while l < r:
            if nums[l] + nums[r] < target:
                c += r - l
                l += 1
            else:
                r -= 1

        return c",True
Minimum Seconds to Equalize a Circular Array,"You are given a 0-indexed array nums containing n integers.
At each second, you perform the following operation on the array:
For every index i in the range [0, n - 1], replace nums[i] with either nums[i], nums[(i - 1 + n) % n], or nums[(i + 1) % n].
Note that all the elements get replaced simultaneously.
Return the minimum number of seconds needed to make all elements in the array nums equal.
","Example 1:
Input: nums = [1,2,1,2]
Output: 1
Explanation: We can equalize the array in 1 second in the following way:
- At 1st second, replace values at each index with [nums[3],nums[1],nums[3],nums[3]]. After replacement, nums = [2,2,2,2].
It can be proven that 1 second is the minimum amount of seconds needed for equalizing the array.
Example 2:
Input: nums = [2,1,3,3,2]
Output: 2
Explanation: We can equalize the array in 2 seconds in the following way:
- At 1st second, replace values at each index with [nums[0],nums[2],nums[2],nums[2],nums[3]]. After replacement, nums = [2,3,3,3,3].
- At 2nd second, replace values at each index with [nums[1],nums[1],nums[2],nums[3],nums[4]]. After replacement, nums = [3,3,3,3,3].
It can be proven that 2 seconds is the minimum amount of seconds needed for equalizing the array.
Example 3:
Input: nums = [5,5,5,5]
Output: 0
Explanation: We don't need to perform any operations as all elements in the initial array are the same.
","class Solution:
    def minimumSeconds(self, nums: List[int]) -> int:
        n=len(nums)
        d={}
# Calculate gaps between same elements of the array
# in map we store for each unique element (maxgap , first_index , prev_index)
        for i in range(n):
            if(nums[i] not in d):
                d[nums[i]]=[0,i,i]
            else:
# maximum between present gap and (prev index - current index) 
                d[nums[i]][0]=max(d[nums[i]][0],i-d[nums[i]][2]-1)
                d[nums[i]][2]=i

# for difference of first and last similar element of array (CIRCULAR ARRAY)
        for i in d:
            d[i][0]=max(n-(d[i][2]-d[i][1])-1,d[i][0])

# for minimum between maximum gaps of all elements
        ans=10**9
        for i in d:
                ans=min(ans,d[i][0])

# every second gap decrease by 2 (element-->   <--element)
        ans=math.ceil(ans/2)
        return ans
        


                
            
            
        ",True
Maximum Sum of Almost Unique Subarray,"You are given an integer array nums and two positive integers m and k.
Return the maximum sum out of all almost unique subarrays of length k of nums. If no such subarray exists, return 0.
A subarray of nums is almost unique if it contains at least m distinct elements.
A subarray is a contiguous non-empty sequence of elements within an array.
","Example 1:
Input: nums = [2,6,7,3,1,7], m = 3, k = 4
Output: 18
Explanation: There are 3 almost unique subarrays of size k = 4. These subarrays are [2, 6, 7, 3], [6, 7, 3, 1], and [7, 3, 1, 7]. Among these subarrays, the one with the maximum sum is [2, 6, 7, 3] which has a sum of 18.
Example 2:
Input: nums = [5,9,9,2,4,5,4], m = 1, k = 3
Output: 23
Explanation: There are 5 almost unique subarrays of size k. These subarrays are [5, 9, 9], [9, 9, 2], [9, 2, 4], [2, 4, 5], and [4, 5, 4]. Among these subarrays, the one with the maximum sum is [5, 9, 9] which has a sum of 23.
Example 3:
Input: nums = [1,2,1,2,1,2,1], m = 3, k = 3
Output: 0
Explanation: There are no subarrays of size k = 3 that contain at least m = 3 distinct elements in the given array [1,2,1,2,1,2,1]. Therefore, no almost unique subarrays exist, and the maximum sum is 0.
","class Solution:
    def maxSum(self, nums: List[int], m: int, k: int) -> int:
        result = 0
        window = Counter()
        left = 0
        total = 0

        for right in range(len(nums)):
            window[nums[right]] += 1
            total += nums[right]

            if right - left + 1 < k:
                continue

            if len(window) >= m:
                result = max(result, total)

            window[nums[left]] -= 1
            total -= nums[left]
            left += 1

            if window[nums[left - 1]] == 0:
                del window[nums[left - 1]]

        return result",True
Check if a String Is an Acronym of Words,"Given an array of strings words and a string s, determine if s is an acronym of words.
The string s is considered an acronym of words if it can be formed by concatenating the first character of each string in words in order. For example, ""ab"" can be formed from [""apple"", ""banana""], but it can't be formed from [""bear"", ""aardvark""].
Return true if s is an acronym of words, and false otherwise.
","Example 1:
Input: words = [""alice"",""bob"",""charlie""], s = ""abc""
Output: true
Explanation: The first character in the words ""alice"", ""bob"", and ""charlie"" are 'a', 'b', and 'c', respectively. Hence, s = ""abc"" is the acronym. 
Example 2:
Input: words = [""an"",""apple""], s = ""a""
Output: false
Explanation: The first character in the words ""an"" and ""apple"" are 'a' and 'a', respectively. 
The acronym formed by concatenating these characters is ""aa"". 
Hence, s = ""a"" is not the acronym.
Example 3:
Input: words = [""never"",""gonna"",""give"",""up"",""on"",""you""], s = ""ngguoy""
Output: true
Explanation: By concatenating the first character of the words in the array, we get the string ""ngguoy"". 
Hence, s = ""ngguoy"" is the acronym.
","class Solution:
    def isAcronym(self, words: List[str], s: str) -> bool:

        return ''.join(word[0] for word in words) == s",True
Maximize the Profit as the Salesman,"You are given an integer n representing the number of houses on a number line, numbered from 0 to n - 1.
Additionally, you are given a 2D integer array offers where offers[i] = [starti, endi, goldi], indicating that ith buyer wants to buy all the houses from starti to endi for goldi amount of gold.
As a salesman, your goal is to maximize your earnings by strategically selecting and selling houses to buyers.
Return the maximum amount of gold you can earn.
Note that different buyers can't buy the same house, and some houses may remain unsold.
","Example 1:
Input: n = 5, offers = [[0,0,1],[0,2,2],[1,3,2]]
Output: 3
Explanation: There are 5 houses numbered from 0 to 4 and there are 3 purchase offers.
We sell houses in the range [0,0] to 1st buyer for 1 gold and houses in the range [1,3] to 3rd buyer for 2 golds.
It can be proven that 3 is the maximum amount of gold we can achieve.
Example 2:
Input: n = 5, offers = [[0,0,1],[0,2,10],[1,3,2]]
Output: 10
Explanation: There are 5 houses numbered from 0 to 4 and there are 3 purchase offers.
We sell houses in the range [0,2] to 2nd buyer for 10 golds.
It can be proven that 10 is the maximum amount of gold we can achieve.
","class Solution:
    def maximizeTheProfit(self, n: int, offers: List[List[int]]) -> int:
        offers.sort(key=lambda a: a[1])
        ends = [o[1] for o in offers]
        m = len(offers)
        dp = [0]*m
        for i in range(m):
            s, e, g = offers[i]
            j = bisect_right(ends, s-1)
            bestPrevDp = dp[j-1] if i > 0 else 0
            dp[i] = max(dp[i-1] if i > 0 else 0, bestPrevDp + g)
        return dp[-1]",True
Minimum Absolute Difference Between Elements With Constraint,"You are given a 0-indexed integer array nums and an integer x.
Find the minimum absolute difference between two elements in the array that are at least x indices apart.
In other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.
Return an integer denoting the minimum absolute difference between two elements that are at least x indices apart.
","Example 1:
Input: nums = [4,3,2,4], x = 2
Output: 0
Explanation: We can select nums[0] = 4 and nums[3] = 4. 
They are at least 2 indices apart, and their absolute difference is the minimum, 0. 
It can be shown that 0 is the optimal answer.
Example 2:
Input: nums = [5,3,2,10,15], x = 1
Output: 1
Explanation: We can select nums[1] = 3 and nums[2] = 2.
They are at least 1 index apart, and their absolute difference is the minimum, 1.
It can be shown that 1 is the optimal answer.
Example 3:
Input: nums = [1,2,3,4], x = 3
Output: 3
Explanation: We can select nums[0] = 1 and nums[3] = 4.
They are at least 3 indices apart, and their absolute difference is the minimum, 3.
It can be shown that 3 is the optimal answer.
","class Solution:
    def minAbsoluteDifference(self, nums: List[int], x: int) -> int:
        minimum = inf
        allowed = []
        for i in range(x, len(nums)):
            insort(allowed, nums[i-x])
            at = bisect_left(allowed, nums[i])
            if at > 0:
                minimum = min(minimum, nums[i] - allowed[at-1])
            if at < len(allowed):
                minimum = min(minimum, allowed[at] - nums[i])
        return minimum",True
Construct Product Matrix,"Given a 0-indexed 2D integer matrix grid of size n * m, we define a 0-indexed 2D matrix p of size n * m as the product matrix of grid if the following condition is met:
Each element p[i][j] is calculated as the product of all elements in grid except for the element grid[i][j]. This product is then taken modulo 12345.
Return the product matrix of grid.
","Example 1:
Input: grid = [[1,2],[3,4]]
Output: [[24,12],[8,6]]
Explanation: p[0][0] = grid[0][1] * grid[1][0] * grid[1][1] = 2 * 3 * 4 = 24
p[0][1] = grid[0][0] * grid[1][0] * grid[1][1] = 1 * 3 * 4 = 12
p[1][0] = grid[0][0] * grid[0][1] * grid[1][1] = 1 * 2 * 4 = 8
p[1][1] = grid[0][0] * grid[0][1] * grid[1][0] = 1 * 2 * 3 = 6
So the answer is [[24,12],[8,6]].
Example 2:
Input: grid = [[12345],[2],[1]]
Output: [[2],[0],[0]]
Explanation: p[0][0] = grid[0][1] * grid[0][2] = 2 * 1 = 2.
p[0][1] = grid[0][0] * grid[0][2] = 12345 * 1 = 12345. 12345 % 12345 = 0. So p[0][1] = 0.
p[0][2] = grid[0][0] * grid[0][1] = 12345 * 2 = 24690. 24690 % 12345 = 0. So p[0][2] = 0.
So the answer is [[2],[0],[0]].
","class Solution {
public:
    vector<vector<int>> constructProductMatrix(vector<vector<int>>& grid) {
        //2 option h
        //yaa to division operator lgake inverse modulo khel lo
        //yaa fir pre suf pro se pro nikaalo
        int mod=12345;
        int n=grid.size();
        int m=grid[0].size();
        vector<vector<int>>t(n,vector<int>(m));
        t[0][0]=1;
        vector<long long >ans(n*m);
        vector<long long int>nums(n*m);
        long long  k=0;
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<m;j++)
            {
                nums[k++]=grid[i][j];
            }
        }
        ans[0]=1;
        long long pro=1;
        for(int i=1;i<n*m;i++)
        {
            pro=pro%12345*nums[i-1]%12345;
            ans[i]=pro%mod;
        }
        pro=1;
        for(int i=n*m-2;i>=0;i--)
        {
            pro=(pro%mod*nums[i+1]%mod)%mod;
            ans[i]=(ans[i]%mod*pro%mod)%mod;
        }
        k=0;
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<m;j++)
            {
                t[i][j]=ans[k++];
            }
        }
        return t;
    }
};",False
Minimum Operations to Collect Elements,"You are given an array nums of positive integers and an integer k.
In one operation, you can remove the last element of the array and add it to your collection.
Return the minimum number of operations needed to collect elements 1, 2, ..., k.
","Example 1:
Input: nums = [3,1,5,4,2], k = 2
Output: 4
Explanation: After 4 operations, we collect elements 2, 4, 5, and 1, in this order. Our collection contains elements 1 and 2. Hence, the answer is 4.
Example 2:
Input: nums = [3,1,5,4,2], k = 5
Output: 5
Explanation: After 5 operations, we collect elements 2, 4, 5, 1, and 3, in this order. Our collection contains elements 1 through 5. Hence, the answer is 5.
Example 3:
Input: nums = [3,2,5,3,1], k = 3
Output: 4
Explanation: After 4 operations, we collect elements 1, 3, 5, and 2, in this order. Our collection contains elements 1 through 3. Hence, the answer is 4.
","class Solution:
    def minOperations(self, nums: List[int], k: int) -> int:
        
                                                #  Example: nums = [3,1,5,4,2]   k=2
        s = cnt = 0                             #           goal = (1<<3)-2 = 6 = '110'
        goal = (1<<(k+1)) - 2

        while nums:                             #   num    s    cnt
                                                #   –––   –––   ––– 
            cnt+= 1                             #    2    100    1
            if (num:=nums.pop()) <= k:          #    4    100    2
                s|= (1<<num)                    #    5    100    3
                                                #    1    110    4 <--return 4
            if  s == goal: return cnt",True
Split Array Into Maximum Number of Subarrays,"You are given an array nums consisting of non-negative integers.
We define the score of subarray nums[l..r] such that l <= r as nums[l] AND nums[l + 1] AND ... AND nums[r] where AND is the bitwise AND operation.
Consider splitting the array into one or more subarrays such that the following conditions are satisfied:
Each element of the array belongs to exactly one subarray.
The sum of scores of the subarrays is the minimum possible.
Return the maximum number of subarrays in a split that satisfies the conditions above.
A subarray is a contiguous part of an array.
","Example 1:
Input: nums = [1,0,2,0,1,2]
Output: 3
Explanation: We can split the array into the following subarrays:
- [1,0]. The score of this subarray is 1 AND 0 = 0.
- [2,0]. The score of this subarray is 2 AND 0 = 0.
- [1,2]. The score of this subarray is 1 AND 2 = 0.
The sum of scores is 0 + 0 + 0 = 0, which is the minimum possible score that we can obtain.
It can be shown that we cannot split the array into more than 3 subarrays with a total score of 0. So we return 3.
Example 2:
Input: nums = [5,7,1,3]
Output: 1
Explanation: We can split the array into one subarray: [5,7,1,3] with a score of 1, which is the minimum possible score that we can obtain.
It can be shown that we cannot split the array into more than 1 subarray with a total score of 1. So we return 1.
","class Solution {
    public int maxSubarrays(int[] nums) {
        
        int min=nums[0];
        for(int i=1;i<nums.length;++i){
            min&=nums[i];
        }

        if(min>0) return 1;

        int ans=1;
        int temp=nums[0];
        for(int i=1;i<nums.length;++i){
            if(temp==0){
                ans++;
                temp=nums[i];
            }
            else
                temp&=nums[i];
            if(i==nums.length-1 && temp>0)
                ans--;
        }
        return ans;
    }
}",False
Sum of Values at Indices With K Set Bits,"You are given a 0-indexed integer array nums and an integer k.
Return an integer that denotes the sum of elements in nums whose corresponding indices have exactly k set bits in their binary representation.
The set bits in an integer are the 1's present when it is written in binary.
For example, the binary representation of 21 is 10101, which has 3 set bits.
","Example 1:
Input: nums = [5,10,1,5,2], k = 1
Output: 13
Explanation: The binary representation of the indices are: 
0 = 0002
1 = 0012
2 = 0102
3 = 0112
4 = 1002 
Indices 1, 2, and 4 have k = 1 set bits in their binary representation.
Hence, the answer is nums[1] + nums[2] + nums[4] = 13.
Example 2:
Input: nums = [4,3,2,1], k = 2
Output: 1
Explanation: The binary representation of the indices are:
0 = 002
1 = 012
2 = 102
3 = 112
Only index 3 has k = 2 set bits in its binary representation.
Hence, the answer is nums[3] = 1.
","class Solution:
    def sumIndicesWithKSetBits(self, nums: List[int], k: int) -> int:
        return sum(x for i, x in enumerate(nums) if bin(i).count('1') == k)",True
Minimum Number of Operations to Make Array Empty,"You are given a 0-indexed array nums consisting of positive integers.
There are two types of operations that you can apply on the array any number of times:
Choose two elements with equal values and delete them from the array.
Choose three elements with equal values and delete them from the array.
Return the minimum number of operations required to make the array empty, or -1 if it is not possible.
","Example 1:
Input: nums = [2,3,3,2,2,4,2,3,4]
Output: 4
Explanation: We can apply the following operations to make the array empty:
- Apply the first operation on the elements at indices 0 and 3. The resulting array is nums = [3,3,2,4,2,3,4].
- Apply the first operation on the elements at indices 2 and 4. The resulting array is nums = [3,3,4,3,4].
- Apply the second operation on the elements at indices 0, 1, and 3. The resulting array is nums = [4,4].
- Apply the first operation on the elements at indices 0 and 1. The resulting array is nums = [].
It can be shown that we cannot make the array empty in less than 4 operations.
Example 2:
Input: nums = [2,1,2,2,3,3]
Output: -1
Explanation: It is impossible to empty the array.
","class Solution:
    def minOperations(self, nums: List[int]) -> int:
        count=Counter(nums).values()
        ans=0
        for i in count:
            if i==1:
                return -1
            else:
                ans+=i//3 + (i%3!=0)
        return ans            ",True
Maximum Number of Alloys,"You are the owner of a company that creates alloys using various types of metals. There are n different types of metals available, and you have access to k machines that can be used to create alloys. Each machine requires a specific amount of each metal type to create an alloy.
For the ith machine to create an alloy, it needs composition[i][j] units of metal of type j. Initially, you have stock[i] units of metal type i, and purchasing one unit of metal type i costs cost[i] coins.
Given integers n, k, budget, a 1-indexed 2D array composition, and 1-indexed arrays stock and cost, your goal is to maximize the number of alloys the company can create while staying within the budget of budget coins.
All alloys must be created with the same machine.
Return the maximum number of alloys that the company can create.
","Example 1:
Input: n = 3, k = 2, budget = 15, composition = [[1,1,1],[1,1,10]], stock = [0,0,0], cost = [1,2,3]
Output: 2
Explanation: It is optimal to use the 1st machine to create alloys.
To create 2 alloys we need to buy the:
- 2 units of metal of the 1st type.
- 2 units of metal of the 2nd type.
- 2 units of metal of the 3rd type.
In total, we need 2 * 1 + 2 * 2 + 2 * 3 = 12 coins, which is smaller than or equal to budget = 15.
Notice that we have 0 units of metal of each type and we have to buy all the required units of metal.
It can be proven that we can create at most 2 alloys.
Example 2:
Input: n = 3, k = 2, budget = 15, composition = [[1,1,1],[1,1,10]], stock = [0,0,100], cost = [1,2,3]
Output: 5
Explanation: It is optimal to use the 2nd machine to create alloys.
To create 5 alloys we need to buy:
- 5 units of metal of the 1st type.
- 5 units of metal of the 2nd type.
- 0 units of metal of the 3rd type.
In total, we need 5 * 1 + 5 * 2 + 0 * 3 = 15 coins, which is smaller than or equal to budget = 15.
It can be proven that we can create at most 5 alloys.
Example 3:
Input: n = 2, k = 3, budget = 10, composition = [[2,1],[1,2],[1,1]], stock = [1,1], cost = [5,5]
Output: 2
Explanation: It is optimal to use the 3rd machine to create alloys.
To create 2 alloys we need to buy the:
- 1 unit of metal of the 1st type.
- 1 unit of metal of the 2nd type.
In total, we need 1 * 5 + 1 * 5 = 10 coins, which is smaller than or equal to budget = 10.
It can be proven that we can create at most 2 alloys.
","class Solution {
public:
    bool solve(int mid,int i,int n, int k, int budget, vector<vector<int>>& composition, vector<int>& stock, vector<int>& cost)
    {   
        long long c=0;
        vector<long long>v;
        for(int x=0;x<n;x++)
        {
            long long y=mid*(long long)composition[i][x];
            v.push_back(y);
        }
        for(int x=0;x<n;x++)
        {   
            if(v[x]-stock[x]>0)
                v[x]=v[x]-stock[x];
            else
                v[x]=0;
            c=c+v[x]*cost[x];
            if(c>budget)
                break;
        }
        return c<=budget;
    }
    int maxNumberOfAlloys(int n, int k, int budget, vector<vector<int>>& composition, vector<int>& stock, vector<int>& cost) {
        int l=0,h=1e9;
        int ans=0;
        for(int i=0;i<composition.size();i++)
        {   
            int l=0,h=1e9;
            int s=0;
            while(l<=h)
            {
                int mid=l+(h-l)/2;
                if(solve(mid,i,n,k,budget,composition,stock,cost))
                {
                    s=mid;
                    l=mid+1;
                }
                else
                    h=mid-1;
            }
            ans=max(ans,s);
        }
        return ans;
    }
};",False
Length of the Longest Subsequence That Sums to Target,"You are given a 0-indexed array of integers nums, and an integer target.
Return the length of the longest subsequence of nums that sums up to target. If no such subsequence exists, return -1.
A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.
","Example 1:
Input: nums = [1,2,3,4,5], target = 9
Output: 3
Explanation: There are 3 subsequences with a sum equal to 9: [4,5], [1,3,5], and [2,3,4]. The longest subsequences are [1,3,5], and [2,3,4]. Hence, the answer is 3.
Example 2:
Input: nums = [4,1,3,2,1,5], target = 7
Output: 4
Explanation: There are 5 subsequences with a sum equal to 7: [4,3], [4,1,2], [4,2,1], [1,1,5], and [1,3,2,1]. The longest subsequence is [1,3,2,1]. Hence, the answer is 4.
Example 3:
Input: nums = [1,1,5,4,5], target = 3
Output: -1
Explanation: It can be shown that nums has no subsequence that sums up to 3.
","class Solution {
public:
int dp[1001][1001];
int solve(int ind,int target,vector<int>&nums,int n){
    if(target<0)
    return -1e5;
    if(target==0){
        return 0;
    }
    if(ind==n)
    return -1e5;
    if(dp[ind][target]!=-1)
    return dp[ind][target];
    int nontake=solve(ind+1,target,nums,n);
    int take=1+solve(ind+1,target-nums[ind],nums,n);
    return dp[ind][target]=max(take,nontake);
}
    int lengthOfLongestSubsequence(vector<int>& nums, int target) {
        int n=nums.size();
        memset(dp,-1,sizeof(dp));
        int ans=solve(0,target,nums,n);
        if(ans>=-1e5 && ans<=-1e4)
        return -1;
        return ans;
    }
};",False
Beautiful Towers I,"You are given an array heights of n integers representing the number of bricks in n consecutive towers. Your task is to remove some bricks to form a mountain-shaped tower arrangement. In this arrangement, the tower heights are non-decreasing, reaching a maximum peak value with one or multiple consecutive towers and then non-increasing.
Return the maximum possible sum of heights of a mountain-shaped tower arrangement.
","Example 1:
Input: heights = [5,3,4,1,1]
Output: 13
Explanation:
We remove some bricks to make heights = [5,3,3,1,1], the peak is at index 0.
Example 2:
Input: heights = [6,5,3,9,2,7]
Output: 22
Explanation:
We remove some bricks to make heights = [3,3,3,9,2,2], the peak is at index 3.
Example 3:
Input: heights = [3,2,5,5,2,3]
Output: 18
Explanation:
We remove some bricks to make heights = [2,2,5,5,2,2], the peak is at index 2 or 3.
","class Solution:
    def maximumSumOfHeights(self, maxHeights: List[int]) -> int:

        # for each possible peek, compute maximum sum of heights;
        # this is achieved by maintaining a monotonic stack with 
        # heights and counts 
        
        def find_peak(arr):

            stack, acc = [], 0
            peeks = []

            for height in arr:
                count = 1
                while stack and height <= stack[-1][0]:
                    h, c = stack.pop()
                    acc -= h * c
                    count += c
                stack.append((height, count))
                acc += height * count
                peeks.append(acc)
            return peeks

        # precompute sums both from both tails (forward and reverse)
        fwd = [0] + find_peak(maxHeights)
        rev = find_peak(maxHeights[::-1])[::-1] + [0]

        # the answer is the maximum sum for two tails
        return max(f + r for f, r in zip(fwd, rev))",True
Longest Unequal Adjacent Groups Subsequence I,"You are given a string array words and a binary array groups both of length n, where words[i] is associated with groups[i].
Your task is to select the longest alternating
subsequence
from words. A subsequence of words is alternating if for any two consecutive strings in the sequence, their corresponding elements in the binary array groups differ. Essentially, you are to choose strings such that adjacent elements have non-matching corresponding bits in the groups array.
Formally, you need to find the longest subsequence of an array of indices [0, 1, ..., n - 1] denoted as [i0, i1, ..., ik-1], such that groups[ij] != groups[ij+1] for each 0 <= j < k - 1 and then find the words corresponding to these indices.
Return the selected subsequence. If there are multiple answers, return any of them.
Note: The elements in words are distinct.
","Example 1:
Input: words = [""e"",""a"",""b""], groups = [0,0,1]
Output: [""e"",""b""]
Explanation: A subsequence that can be selected is [""e"",""b""] because groups[0] != groups[2]. Another subsequence that can be selected is [""a"",""b""] because groups[1] != groups[2]. It can be demonstrated that the length of the longest subsequence of indices that satisfies the condition is 2.
Example 2:
Input: words = [""a"",""b"",""c"",""d""], groups = [1,0,1,1]
Output: [""a"",""b"",""c""]
Explanation: A subsequence that can be selected is [""a"",""b"",""c""] because groups[0] != groups[1] and groups[1] != groups[2]. Another subsequence that can be selected is [""a"",""b"",""d""] because groups[0] != groups[1] and groups[1] != groups[3]. It can be shown that the length of the longest subsequence of indices that satisfies the condition is 3.
",,False
Minimum Processing Time,"You have a certain number of processors, each having 4 cores. The number of tasks to be executed is four times the number of processors. Each task must be assigned to a unique core, and each core can only be used once.
You are given an array processorTime representing the time each processor becomes available and an array tasks representing how long each task takes to complete. Return the minimum time needed to complete all tasks.
","Example 1:
Input: processorTime = [8,10], tasks = [2,2,3,1,8,7,4,5]
Output: 16
Explanation:
Assign the tasks at indices 4, 5, 6, 7 to the first processor which becomes available at time = 8, and the tasks at indices 0, 1, 2, 3 to the second processor which becomes available at time = 10. 
The time taken by the first processor to finish the execution of all tasks is max(8 + 8, 8 + 7, 8 + 4, 8 + 5) = 16.
The time taken by the second processor to finish the execution of all tasks is max(10 + 2, 10 + 2, 10 + 3, 10 + 1) = 13.
Example 2:
Input: processorTime = [10,20], tasks = [2,3,1,2,5,8,4,3]
Output: 23
Explanation:
Assign the tasks at indices 1, 4, 5, 6 to the first processor and the others to the second processor.
The time taken by the first processor to finish the execution of all tasks is max(10 + 3, 10 + 5, 10 + 8, 10 + 4) = 18.
The time taken by the second processor to finish the execution of all tasks is max(20 + 2, 20 + 1, 20 + 2, 20 + 3) = 23.
","class Solution:
    def minProcessingTime(self, processorTime: List[int], tasks: List[int]) -> int:
        tasks, processorTime, ans = sorted(tasks), sorted(processorTime), 0
        for i in processorTime:
            ans = max(ans, i + max(tasks[-4:]))
            tasks = tasks[:-4]
        return ans
",True
Maximum Value of an Ordered Triplet II,"You are given a 0-indexed integer array nums.
Return the maximum value over all triplets of indices (i, j, k) such that i < j < k. If all such triplets have a negative value, return 0.
The value of a triplet of indices (i, j, k) is equal to (nums[i] - nums[j]) * nums[k].
","Example 1:
Input: nums = [12,6,1,2,7]
Output: 77
Explanation: The value of the triplet (0, 2, 4) is (nums[0] - nums[2]) * nums[4] = 77.
It can be shown that there are no ordered triplets of indices with a value greater than 77. 
Example 2:
Input: nums = [1,10,3,4,19]
Output: 133
Explanation: The value of the triplet (1, 2, 4) is (nums[1] - nums[2]) * nums[4] = 133.
It can be shown that there are no ordered triplets of indices with a value greater than 133.
Example 3:
Input: nums = [1,2,3]
Output: 0
Explanation: The only ordered triplet of indices (0, 1, 2) has a negative value of (nums[0] - nums[1]) * nums[2] = -3. Hence, the answer would be 0.
",,False
Maximum Value of an Ordered Triplet I,"You are given a 0-indexed integer array nums.
Return the maximum value over all triplets of indices (i, j, k) such that i < j < k. If all such triplets have a negative value, return 0.
The value of a triplet of indices (i, j, k) is equal to (nums[i] - nums[j]) * nums[k].
","Example 1:
Input: nums = [12,6,1,2,7]
Output: 77
Explanation: The value of the triplet (0, 2, 4) is (nums[0] - nums[2]) * nums[4] = 77.
It can be shown that there are no ordered triplets of indices with a value greater than 77. 
Example 2:
Input: nums = [1,10,3,4,19]
Output: 133
Explanation: The value of the triplet (1, 2, 4) is (nums[1] - nums[2]) * nums[4] = 133.
It can be shown that there are no ordered triplets of indices with a value greater than 133.
Example 3:
Input: nums = [1,2,3]
Output: 0
Explanation: The only ordered triplet of indices (0, 1, 2) has a negative value of (nums[0] - nums[1]) * nums[2] = -3. Hence, the answer would be 0.
","class Solution:
    def maximumTripletValue(self, nums: List[int], mx = 0) -> int:

        pref = accumulate(nums, max)
        suff = list(accumulate(nums[::-1], max))[::-1]

        return max(0,*((J-I) * K for I, J, K 
                                  in zip(nums[1:],pref,suff[2:])))",True
Last Visited Integers,"Given an integer array nums where nums[i] is either a positive integer or -1. We need to find for each -1 the respective positive integer, which we call the last visited integer.
To achieve this goal, let's define two empty arrays: seen and ans.
Start iterating from the beginning of the array nums.
If a positive integer is encountered, prepend it to the front of seen.
If -1 is encountered, let k be the number of consecutive -1s seen so far (including the current -1),
If k is less than or equal to the length of seen, append the k-th element of seen to ans.
If k is strictly greater than the length of seen, append -1 to ans.
Return the array ans.
","Example 1:
Input: nums = [1,2,-1,-1,-1]
Output: [2,1,-1]
Explanation:
Start with seen = [] and ans = [].
Process nums[0]: The first element in nums is 1. We prepend it to the front of seen. Now, seen == [1].
Process nums[1]: The next element is 2. We prepend it to the front of seen. Now, seen == [2, 1].
Process nums[2]: The next element is -1. This is the first occurrence of -1, so k == 1. We look for the first element in seen. We append 2 to ans. Now, ans == [2].
Process nums[3]: Another -1. This is the second consecutive -1, so k == 2. The second element in seen is 1, so we append 1 to ans. Now, ans == [2, 1].
Process nums[4]: Another -1, the third in a row, making k = 3. However, seen only has two elements ([2, 1]). Since k is greater than the number of elements in seen, we append -1 to ans. Finally, ans == [2, 1, -1].
Example 2:
Input: nums = [1,-1,2,-1,-1]
Output: [1,2,1]
Explanation:
Start with seen = [] and ans = [].
Process nums[0]: The first element in nums is 1. We prepend it to the front of seen. Now, seen == [1].
Process nums[1]: The next element is -1. This is the first occurrence of -1, so k == 1. We look for the first element in seen, which is 1. Append 1 to ans. Now, ans == [1].
Process nums[2]: The next element is 2. Prepend this to the front of seen. Now, seen == [2, 1].
Process nums[3]: The next element is -1. This -1 is not consecutive to the first -1 since 2 was in between. Thus, k resets to 1. The first element in seen is 2, so append 2 to ans. Now, ans == [1, 2].
Process nums[4]: Another -1. This is consecutive to the previous -1, so k == 2. The second element in seen is 1, append 1 to ans. Finally, ans == [1, 2, 1].
","class Solution:
    def lastVisitedIntegers(self, words: List[str]) -> List[int]:
        stack = []
        position = -1
        result = []
        for elem in words:
            if elem == 'prev':
                if position == -1:
                    result.append(-1)
                else:
                    result.append(stack[position])
                    position -= 1 
            else:
                stack.append(int(elem))
                position = len(stack) - 1
        
        return result",True
Find Indices With Index and Value Difference I,"You are given a 0-indexed integer array nums having length n, an integer indexDifference, and an integer valueDifference.
Your task is to find two indices i and j, both in the range [0, n - 1], that satisfy the following conditions:
abs(i - j) >= indexDifference, and
abs(nums[i] - nums[j]) >= valueDifference
Return an integer array answer, where answer = [i, j] if there are two such indices, and answer = [-1, -1] otherwise. If there are multiple choices for the two indices, return any of them.
Note: i and j may be equal.
","Example 1:
Input: nums = [5,1,4,1], indexDifference = 2, valueDifference = 4
Output: [0,3]
Explanation: In this example, i = 0 and j = 3 can be selected.
abs(0 - 3) >= 2 and abs(nums[0] - nums[3]) >= 4.
Hence, a valid answer is [0,3].
[3,0] is also a valid answer.
Example 2:
Input: nums = [2,1], indexDifference = 0, valueDifference = 0
Output: [0,0]
Explanation: In this example, i = 0 and j = 0 can be selected.
abs(0 - 0) >= 0 and abs(nums[0] - nums[0]) >= 0.
Hence, a valid answer is [0,0].
Other valid answers are [0,1], [1,0], and [1,1].
Example 3:
Input: nums = [1,2,3], indexDifference = 2, valueDifference = 4
Output: [-1,-1]
Explanation: In this example, it can be shown that it is impossible to find two indices that satisfy both conditions.
Hence, [-1,-1] is returned.
","class Solution:
    def findIndices(self, nums: List[int], indexDifference: int, valueDifference: int) -> List[int]:
        a = 0
        b = indexDifference
        while (a<len(nums)-indexDifference):
            if abs(nums[b] - nums[a]) >= valueDifference:
                return [a,b]
            elif not (abs(nums[b] - nums[a]) >= valueDifference) and b<len(nums)-1:
                b=b+1
            elif b == len(nums) - 1:
                a =a + 1
                b = a + indexDifference
            
        return [-1,-1]
        
",True
Find Indices With Index and Value Difference II,"You are given a 0-indexed integer array nums having length n, an integer indexDifference, and an integer valueDifference.
Your task is to find two indices i and j, both in the range [0, n - 1], that satisfy the following conditions:
abs(i - j) >= indexDifference, and
abs(nums[i] - nums[j]) >= valueDifference
Return an integer array answer, where answer = [i, j] if there are two such indices, and answer = [-1, -1] otherwise. If there are multiple choices for the two indices, return any of them.
Note: i and j may be equal.
","Example 1:
Input: nums = [5,1,4,1], indexDifference = 2, valueDifference = 4
Output: [0,3]
Explanation: In this example, i = 0 and j = 3 can be selected.
abs(0 - 3) >= 2 and abs(nums[0] - nums[3]) >= 4.
Hence, a valid answer is [0,3].
[3,0] is also a valid answer.
Example 2:
Input: nums = [2,1], indexDifference = 0, valueDifference = 0
Output: [0,0]
Explanation: In this example, i = 0 and j = 0 can be selected.
abs(0 - 0) >= 0 and abs(nums[0] - nums[0]) >= 0.
Hence, a valid answer is [0,0].
Other valid answers are [0,1], [1,0], and [1,1].
Example 3:
Input: nums = [1,2,3], indexDifference = 2, valueDifference = 4
Output: [-1,-1]
Explanation: In this example, it can be shown that it is impossible to find two indices that satisfy both conditions.
Hence, [-1,-1] is returned.
","class Solution:
    def findIndices(self, nums: List[int], indexDifference: int, valueDifference: int) -> List[int]:
        
        H1=[(nums[i],i) for i in range(indexDifference,len(nums))] # it will give me the smallest to largest (min heap)
        H2=[(-1*nums[i],i) for i in range(indexDifference,len(nums))] # it will give me the largest to smallest (max heap)
        heapq.heapify(H1)
        heapq.heapify(H2)
        for i in range(len(nums)-indexDifference):
            while abs(H1[0][1]-i)<indexDifference:
                heapq.heappop(H1)
            while abs(H2[0][1]-i)<indexDifference:
                heapq.heappop(H2)
            if abs(H1[0][0]-nums[i])>=valueDifference:
                return [i,H1[0][1]]
            if abs(-1*H2[0][0]-nums[i])>=valueDifference:
                return [i,H2[0][1]]
        return [-1,-1]",True
Minimum Equal Sum of Two Arrays After Replacing Zeros,"You are given two arrays nums1 and nums2 consisting of positive integers.
You have to replace all the 0's in both arrays with strictly positive integers such that the sum of elements of both arrays becomes equal.
Return the minimum equal sum you can obtain, or -1 if it is impossible.
","Example 1:
Input: nums1 = [3,2,0,1,0], nums2 = [6,5,0]
Output: 12
Explanation: We can replace 0's in the following way:
- Replace the two 0's in nums1 with the values 2 and 4. The resulting array is nums1 = [3,2,2,1,4].
- Replace the 0 in nums2 with the value 1. The resulting array is nums2 = [6,5,1].
Both arrays have an equal sum of 12. It can be shown that it is the minimum sum we can obtain.
Example 2:
Input: nums1 = [2,0,2,0], nums2 = [1,4]
Output: -1
Explanation: It is impossible to make the sum of both arrays equal.
","class Solution:
    def minSum(self, nums1: List[int], nums2: List[int]) -> int:
        # Calculate number of 0 in each array
        numOfZeros1 = nums1.count(0)
        numOfZeros2 = nums2.count(0)
        
       # Calculate sum of each array
        sum1 = sum(nums1)
        sum2 = sum(nums2)

        # Calculate min and max possible sum of each array after replacing all 0
        minNums1 = sum1 + numOfZeros1
        minNums2 = sum2 + numOfZeros2
        maxNums1 = inf if numOfZeros1 > 0 else sum1
        maxNums2 = inf if numOfZeros2 > 0 else sum2

        # If max sum of an array < min sum of the other array -> Impossible to have equal sum
        if maxNums1 < minNums2 or maxNums2 < minNums1:
            return -1
        
        # Return max of min possible sum of 2 arrays, so both arrays can each to that sum
        return max(minNums1, minNums2)
",True
Minimum Sum of Mountain Triplets I,"You are given a 0-indexed array nums of integers.
A triplet of indices (i, j, k) is a mountain if:
i < j < k
nums[i] < nums[j] and nums[k] < nums[j]
Return the minimum possible sum of a mountain triplet of nums. If no such triplet exists, return -1.
","Example 1:
Input: nums = [8,6,1,5,3]
Output: 9
Explanation: Triplet (2, 3, 4) is a mountain triplet of sum 9 since: 
- 2 < 3 < 4
- nums[2] < nums[3] and nums[4] < nums[3]
And the sum of this triplet is nums[2] + nums[3] + nums[4] = 9. It can be shown that there are no mountain triplets with a sum of less than 9.
Example 2:
Input: nums = [5,4,8,7,10,2]
Output: 13
Explanation: Triplet (1, 3, 5) is a mountain triplet of sum 13 since: 
- 1 < 3 < 5
- nums[1] < nums[3] and nums[5] < nums[3]
And the sum of this triplet is nums[1] + nums[3] + nums[5] = 13. It can be shown that there are no mountain triplets with a sum of less than 13.
Example 3:
Input: nums = [6,5,4,3,4,5]
Output: -1
Explanation: It can be shown that there are no mountain triplets in nums.
","class Solution:
    def minimumSum(self, nums: List[int]) -> int:
        
        if(len(nums) < 3):
            return -1
        
        min_sum = float('inf')
        
        for i in range(1,len(nums)-1):
            left_min = min(nums[:i])              # Maximum element on right side 
            right_min = min(nums[i+1:])           # Maximum element on left side 
            
            if(nums[i] > left_min and nums[i] > right_min):
                min_sum = min(min_sum , left_min + nums[i] + right_min)
                
                
        if(min_sum != float(""inf"")):
            return min_sum
        else:
            return -1",True
Minimum Increment Operations to Make Array Beautiful,"You are given a 0-indexed integer array nums having length n, and an integer k.
You can perform the following increment operation any number of times (including zero):
Choose an index i in the range [0, n - 1], and increase nums[i] by 1.
An array is considered beautiful if, for any subarray with a size of 3 or more, its maximum element is greater than or equal to k.
Return an integer denoting the minimum number of increment operations needed to make nums beautiful.
A subarray is a contiguous non-empty sequence of elements within an array.
","Example 1:
Input: nums = [2,3,0,0,2], k = 4
Output: 3
Explanation: We can perform the following increment operations to make nums beautiful:
Choose index i = 1 and increase nums[1] by 1 -> [2,4,0,0,2].
Choose index i = 4 and increase nums[4] by 1 -> [2,4,0,0,3].
Choose index i = 4 and increase nums[4] by 1 -> [2,4,0,0,4].
The subarrays with a size of 3 or more are: [2,4,0], [4,0,0], [0,0,4], [2,4,0,0], [4,0,0,4], [2,4,0,0,4].
In all the subarrays, the maximum element is equal to k = 4, so nums is now beautiful.
It can be shown that nums cannot be made beautiful with fewer than 3 increment operations.
Hence, the answer is 3.
Example 2:
Input: nums = [0,1,3,3], k = 5
Output: 2
Explanation: We can perform the following increment operations to make nums beautiful:
Choose index i = 2 and increase nums[2] by 1 -> [0,1,4,3].
Choose index i = 2 and increase nums[2] by 1 -> [0,1,5,3].
The subarrays with a size of 3 or more are: [0,1,5], [1,5,3], [0,1,5,3].
In all the subarrays, the maximum element is equal to k = 5, so nums is now beautiful.
It can be shown that nums cannot be made beautiful with fewer than 2 increment operations.
Hence, the answer is 2.
Example 3:
Input: nums = [1,1,2], k = 1
Output: 0
Explanation: The only subarray with a size of 3 or more in this example is [1,1,2].
The maximum element, 2, is already greater than k = 1, so we don't need any increment operation.
Hence, the answer is 0.
","class Solution {
public:
    long long minIncrementOperations(vector<int>& nums, int k) {
        int n = nums.size();
        vector<long long> dp(n + 1, 1e18); // Initialize a dynamic programming (DP) array with a large value.
        dp[0] = 0; // Initialize the base case.

        for (int i = 1; i <= n; i++) {
            long long required = max(0, k - nums[i - 1]); // Calculate the required increment for the current element.

            // Iterate through a specific range of previous elements to find the minimum cost.
            for (int j = i - 1; j >= max(0, i - 3); j--) {
                dp[i] = min(dp[j], dp[i]); // Update the DP array with the minimum cost.
            }
            dp[i] += required; // Add the required increment to the current DP state.
        }

        // Return the minimum cost from the last three states in the DP array.
        return min({dp[n], dp[n - 1], dp[n - 2]});
    }
};


",False
Find the K-or of an Array,"You are given an integer array nums, and an integer k. Let's introduce K-or operation by extending the standard bitwise OR. In K-or, a bit position in the result is set to 1 if at least k numbers in nums have a 1 in that position.
Return the K-or of nums.
","Example 1:
Input: nums = [7,12,9,8,9,15], k = 4
Output: 9
Explanation:
Represent numbers in binary:
Number Bit 3 Bit 2 Bit 1 Bit 0
7 0 1 1 1
12 1 1 0 0
9 1 0 0 1
8 1 0 0 0
9 1 0 0 1
15 1 1 1 1
Result = 9 1 0 0 1
Bit 0 is set in 7, 9, 9, and 15. Bit 3 is set in 12, 9, 8, 9, and 15.
Only bits 0 and 3 qualify. The result is (1001)2 = 9.
Example 2:
Input: nums = [2,12,1,11,4,5], k = 6
Output: 0
Explanation: No bit appears as 1 in all six array numbers, as required for K-or with k = 6. Thus, the result is 0.
Example 3:
Input: nums = [10,8,5,9,11,6,8], k = 1
Output: 15
Explanation: Since k == 1, the 1-or of the array is equal to the bitwise OR of all its elements. Hence, the answer is 10 OR 8 OR 5 OR 9 OR 11 OR 6 OR 8 = 15.
","class Solution:
    def findKOr(self, nums: List[int], k: int) -> int:

        nums = enumerate(zip_longest(*map(
                   lambda x: bin(x)[-1:1:-1],nums),fillvalue = '0'))

        return sum((1<<i)for i,arr in nums if arr.count('1') >= k)",True
Minimum Sum of Mountain Triplets II,"You are given a 0-indexed array nums of integers.
A triplet of indices (i, j, k) is a mountain if:
i < j < k
nums[i] < nums[j] and nums[k] < nums[j]
Return the minimum possible sum of a mountain triplet of nums. If no such triplet exists, return -1.
","Example 1:
Input: nums = [8,6,1,5,3]
Output: 9
Explanation: Triplet (2, 3, 4) is a mountain triplet of sum 9 since: 
- 2 < 3 < 4
- nums[2] < nums[3] and nums[4] < nums[3]
And the sum of this triplet is nums[2] + nums[3] + nums[4] = 9. It can be shown that there are no mountain triplets with a sum of less than 9.
Example 2:
Input: nums = [5,4,8,7,10,2]
Output: 13
Explanation: Triplet (1, 3, 5) is a mountain triplet of sum 13 since: 
- 1 < 3 < 5
- nums[1] < nums[3] and nums[5] < nums[3]
And the sum of this triplet is nums[1] + nums[3] + nums[5] = 13. It can be shown that there are no mountain triplets with a sum of less than 13.
Example 3:
Input: nums = [6,5,4,3,4,5]
Output: -1
Explanation: It can be shown that there are no mountain triplets in nums.
",,False
Minimum Operations to Maximize Last Elements in Arrays,"You are given two 0-indexed integer arrays, nums1 and nums2, both having length n.
You are allowed to perform a series of operations (possibly none).
In an operation, you select an index i in the range [0, n - 1] and swap the values of nums1[i] and nums2[i].
Your task is to find the minimum number of operations required to satisfy the following conditions:
nums1[n - 1] is equal to the maximum value among all elements of nums1, i.e., nums1[n - 1] = max(nums1[0], nums1[1], ..., nums1[n - 1]).
nums2[n - 1] is equal to the maximum value among all elements of nums2, i.e., nums2[n - 1] = max(nums2[0], nums2[1], ..., nums2[n - 1]).
Return an integer denoting the minimum number of operations needed to meet both conditions, or -1 if it is impossible to satisfy both conditions.
","Example 1:
Input: nums1 = [1,2,7], nums2 = [4,5,3]
Output: 1
Explanation: In this example, an operation can be performed using index i = 2.
When nums1[2] and nums2[2] are swapped, nums1 becomes [1,2,3] and nums2 becomes [4,5,7].
Both conditions are now satisfied.
It can be shown that the minimum number of operations needed to be performed is 1.
So, the answer is 1.
Example 2:
Input: nums1 = [2,3,4,5,9], nums2 = [8,8,4,4,4]
Output: 2
Explanation: In this example, the following operations can be performed:
First operation using index i = 4.
When nums1[4] and nums2[4] are swapped, nums1 becomes [2,3,4,5,4], and nums2 becomes [8,8,4,4,9].
Another operation using index i = 3.
When nums1[3] and nums2[3] are swapped, nums1 becomes [2,3,4,4,4], and nums2 becomes [8,8,4,5,9].
Both conditions are now satisfied.
It can be shown that the minimum number of operations needed to be performed is 2.
So, the answer is 2.   
Example 3:
Input: nums1 = [1,5,4], nums2 = [2,5,3]
Output: -1
Explanation: In this example, it is not possible to satisfy both conditions. 
So, the answer is -1.
","class Solution:
    def minOperations(self, nums1, nums2):
        dp1, dp2 = 0, 0 

        for i,j in zip(nums1,nums2):
            if max(i,j) > max(nums1[-1],nums2[-1]): return -1 
            if min(i,j) > min(nums1[-1],nums2[-1]): return -1
            if i > nums1[-1] or j > nums2[-1]: dp1 += 1
            if i > nums2[-1] or j > nums1[-1]: dp2 += 1

        return min(dp1,dp2)",True
Find Words Containing Character,"You are given a 0-indexed array of strings words and a character x.
Return an array of indices representing the words that contain the character x.
Note that the returned array may be in any order.
","Example 1:
Input: words = [""leet"",""code""], x = ""e""
Output: [0,1]
Explanation: ""e"" occurs in both words: ""leet"", and ""code"". Hence, we return indices 0 and 1.
Example 2:
Input: words = [""abc"",""bcd"",""aaaa"",""cbc""], x = ""a""
Output: [0,2]
Explanation: ""a"" occurs in ""abc"", and ""aaaa"". Hence, we return indices 0 and 2.
Example 3:
Input: words = [""abc"",""bcd"",""aaaa"",""cbc""], x = ""z""
Output: []
Explanation: ""z"" does not occur in any of the words. Hence, we return an empty array.
","class Solution {
    public List<Integer> findWordsContaining(String[] words, char x) {
        List<Integer> ans = new ArrayList<>();
       for(int i=0;i<words.length;i++){
           for(int j = 0; j < words[i].length(); j++){
               if(words[i].charAt(j) == x){
                   ans.add(i); 
                   break; 
               }

           }
              
       }
       
       return ans;

    }
}",False
High-Access Employees,"You are given a 2D 0-indexed array of strings, access_times, with size n. For each i where 0 <= i <= n - 1, access_times[i][0] represents the name of an employee, and access_times[i][1] represents the access time of that employee. All entries in access_times are within the same day.
The access time is represented as four digits using a 24-hour time format, for example, ""0800"" or ""2250"".
An employee is said to be high-access if he has accessed the system three or more times within a one-hour period.
Times with exactly one hour of difference are not considered part of the same one-hour period. For example, ""0815"" and ""0915"" are not part of the same one-hour period.
Access times at the start and end of the day are not counted within the same one-hour period. For example, ""0005"" and ""2350"" are not part of the same one-hour period.
Return a list that contains the names of high-access employees with any order you want.
","Example 1:
Input: access_times = [[""a"",""0549""],[""b"",""0457""],[""a"",""0532""],[""a"",""0621""],[""b"",""0540""]]
Output: [""a""]
Explanation: ""a"" has three access times in the one-hour period of [05:32, 06:31] which are 05:32, 05:49, and 06:21.
But ""b"" does not have more than two access times at all.
So the answer is [""a""].
Example 2:
Input: access_times = [[""d"",""0002""],[""c"",""0808""],[""c"",""0829""],[""e"",""0215""],[""d"",""1508""],[""d"",""1444""],[""d"",""1410""],[""c"",""0809""]]
Output: [""c"",""d""]
Explanation: ""c"" has three access times in the one-hour period of [08:08, 09:07] which are 08:08, 08:09, and 08:29.
""d"" has also three access times in the one-hour period of [14:10, 15:09] which are 14:10, 14:44, and 15:08.
However, ""e"" has just one access time, so it can not be in the answer and the final answer is [""c"",""d""].
Example 3:
Input: access_times = [[""cd"",""1025""],[""ab"",""1025""],[""cd"",""1046""],[""cd"",""1055""],[""ab"",""1124""],[""ab"",""1120""]]
Output: [""ab"",""cd""]
Explanation: ""ab"" has three access times in the one-hour period of [10:25, 11:24] which are 10:25, 11:20, and 11:24.
""cd"" has also three access times in the one-hour period of [10:25, 11:24] which are 10:25, 10:46, and 10:55.
So the answer is [""ab"",""cd""].
","class Solution:
    def findHighAccessEmployees(self, access_times: List[List[str]]) -> List[str]:
        answ=[]
        d={}
        for name,time in access_times:
            if name not in d:
                d[name]=[]
            time=int(time[:2])*60 + int(time[2:])
            d[name].append(time)
        for name,times in d.items():
            if 2<len(times):
                times.sort()
                for a,b in zip(times,times[2:]):
                    if b-a<60:
                        answ.append(name)
                        break
        return answ   ",True
Find Common Elements Between Two Arrays,"You are given two integer arrays nums1 and nums2 of sizes n and m, respectively. Calculate the following values:
answer1 : the number of indices i such that nums1[i] exists in nums2.
answer2 : the number of indices i such that nums2[i] exists in nums1.
Return [answer1,answer2].
","Example 1:
Input: nums1 = [2,3,2], nums2 = [1,2]
Output: [2,1]
Explanation:
Example 2:
Input: nums1 = [4,3,2,3,1], nums2 = [2,2,5,2,3,6]
Output: [3,4]
Explanation:
The elements at indices 1, 2, and 3 in nums1 exist in nums2 as well. So answer1 is 3.
The elements at indices 0, 1, 3, and 4 in nums2 exist in nums1. So answer2 is 4.
Example 3:
Input: nums1 = [3,4,2,3], nums2 = [1,5]
Output: [0,0]
Explanation:
No numbers are common between nums1 and nums2, so answer is [0,0].
",,False
Count Subarrays Where Max Element Appears at Least K Times,"You are given an integer array nums and a positive integer k.
Return the number of subarrays where the maximum element of nums appears at least k times in that subarray.
A subarray is a contiguous sequence of elements within an array.
","Example 1:
Input: nums = [1,3,2,3,3], k = 2
Output: 6
Explanation: The subarrays that contain the element 3 at least 2 times are: [1,3,2,3], [1,3,2,3,3], [3,2,3], [3,2,3,3], [2,3,3] and [3,3].
Example 2:
Input: nums = [1,4,2,1], k = 3
Output: 0
Explanation: No subarray contains the element 4 at least 3 times.
","class Solution {
    public long countSubarrays(int[] nums, int k) {
        int maxVal = 0;

        for (int val : nums) {
            maxVal = Math.max(maxVal, val);
        }

        int left = 0;
        int count = 0;
        long res = 0;
        for (int val : nums) {
            if (val == maxVal) {
                count++;
            }

            while (count >= k) {
                if (nums[left++] == maxVal) {
                    count--;
                } 
            }

            res += left;
        }

        return res;
    }
}",False
Matrix Similarity After Cyclic Shifts,"You are given an m x n integer matrix mat and an integer k. The matrix rows are 0-indexed.
The following proccess happens k times:
Even-indexed rows (0, 2, 4, ...) are cyclically shifted to the left.

Odd-indexed rows (1, 3, 5, ...) are cyclically shifted to the right.

Return true if the final modified matrix after k steps is identical to the original matrix, and false otherwise.
","Example 1:
Input: mat = [[1,2,3],[4,5,6],[7,8,9]], k = 4
Output: false
Explanation:
In each step left shift is applied to rows 0 and 2 (even indices), and right shift to row 1 (odd index).
Example 2:
Input: mat = [[1,2,1,2],[5,5,5,5],[6,3,6,3]], k = 2
Output: true
Explanation:
Example 3:
Input: mat = [[2,2],[2,2]], k = 3
Output: true
Explanation:
As all the values are equal in the matrix, even after performing cyclic shifts the matrix will remain the same.
","class Solution:
    def areSimilar(self, mat: List[List[int]], k: int) -> bool:
        m = len(mat)
        n = len(mat[0])
        k2 = k % n
        
        if k2 == 0:
            return True
        
        mat2 = []
        
        for i in range(m):
            row = mat[i]
            if i % 2 == 0:
                row2 = row[k2:] + row[:k2]
                mat2.append(row2)
            else:
                row2 = row[-k2:] + row[:n - k2]
                mat2.append(row2)
        
        return mat2 == mat
                
                ",True
Count Tested Devices After Test Operations,"You are given a 0-indexed integer array batteryPercentages having length n, denoting the battery percentages of n 0-indexed devices.
Your task is to test each device i in order from 0 to n - 1, by performing the following test operations:
If batteryPercentages[i] is greater than 0:
Increment the count of tested devices.
Decrease the battery percentage of all devices with indices j in the range [i + 1, n - 1] by 1, ensuring their battery percentage never goes below 0, i.e, batteryPercentages[j] = max(0, batteryPercentages[j] - 1).
Move to the next device.
Otherwise, move to the next device without performing any test.
Return an integer denoting the number of devices that will be tested after performing the test operations in order.
","Example 1:
Input: batteryPercentages = [1,1,2,1,3]
Output: 3
Explanation: Performing the test operations in order starting from device 0:
At device 0, batteryPercentages[0] > 0, so there is now 1 tested device, and batteryPercentages becomes [1,0,1,0,2].
At device 1, batteryPercentages[1] == 0, so we move to the next device without testing.
At device 2, batteryPercentages[2] > 0, so there are now 2 tested devices, and batteryPercentages becomes [1,0,1,0,1].
At device 3, batteryPercentages[3] == 0, so we move to the next device without testing.
At device 4, batteryPercentages[4] > 0, so there are now 3 tested devices, and batteryPercentages stays the same.
So, the answer is 3.
Example 2:
Input: batteryPercentages = [0,1,2]
Output: 2
Explanation: Performing the test operations in order starting from device 0:
At device 0, batteryPercentages[0] == 0, so we move to the next device without testing.
At device 1, batteryPercentages[1] > 0, so there is now 1 tested device, and batteryPercentages becomes [0,1,1].
At device 2, batteryPercentages[2] > 0, so there are now 2 tested devices, and batteryPercentages stays the same.
So, the answer is 2.
","class Solution:
    def countTestedDevices(self, batteryPercentages: List[int]) -> int:
        res = 0
        delta = 0
        for i,p in enumerate(batteryPercentages):
            if p - delta > 0:
                delta += 1
                res += 1
        return res
        ",True
Find the Peaks,"You are given a 0-indexed array mountain. Your task is to find all the peaks in the mountain array.
Return an array that consists of indices of peaks in the given array in any order.
Notes:
A peak is defined as an element that is strictly greater than its neighboring elements.
The first and last elements of the array are not a peak.
","Example 1:
Input: mountain = [2,4,4]
Output: []
Explanation: mountain[0] and mountain[2] can not be a peak because they are first and last elements of the array.
mountain[1] also can not be a peak because it is not strictly greater than mountain[2].
So the answer is [].
Example 2:
Input: mountain = [1,4,3,8,5]
Output: [1,3]
Explanation: mountain[0] and mountain[4] can not be a peak because they are first and last elements of the array.
mountain[2] also can not be a peak because it is not strictly greater than mountain[3] and mountain[1].
But mountain [1] and mountain[3] are strictly greater than their neighboring elements.
So the answer is [1,3].
","class Solution:
    def findPeaks(self, mountain: List[int]) -> List[int]:

        return [idx+1 for  idx, (a,b,c) in enumerate(zip(mountain, 
                            mountain[1:], mountain[2:])) if a<b>c]",True
Length of Longest Subarray With at Most K Frequency,"You are given an integer array nums and an integer k.
The frequency of an element x is the number of times it occurs in an array.
An array is called good if the frequency of each element in this array is less than or equal to k.
Return the length of the longest good subarray of nums.
A subarray is a contiguous non-empty sequence of elements within an array.
","Example 1:
Input: nums = [1,2,3,1,2,3,1,2], k = 2
Output: 6
Explanation: The longest possible good subarray is [1,2,3,1,2,3] since the values 1, 2, and 3 occur at most twice in this subarray. Note that the subarrays [2,3,1,2,3,1] and [3,1,2,3,1,2] are also good.
It can be shown that there are no good subarrays with length more than 6.
Example 2:
Input: nums = [1,2,1,2,1,2,1,2], k = 1
Output: 2
Explanation: The longest possible good subarray is [1,2] since the values 1 and 2 occur at most once in this subarray. Note that the subarray [2,1] is also good.
It can be shown that there are no good subarrays with length more than 2.
Example 3:
Input: nums = [5,5,5,5,5,5,5], k = 4
Output: 4
Explanation: The longest possible good subarray is [5,5,5,5] since the value 5 occurs 4 times in this subarray.
It can be shown that there are no good subarrays with length more than 4.
","class Solution:
    def maxSubarrayLength(self, nums: List[int], k: int) -> int:
        n=len(nums)
        start=0
        end=0
        ans=0
        freq={}
        while end<n:
            freq[nums[end]]=freq.get(nums[end],0)+1
            while freq[nums[end]]>k:
                freq[nums[start]]-=1
                start+=1
            ans=max(ans,end-start+1)
            end+=1  
        return ans      ",True
Minimum Number Game,"You are given a 0-indexed integer array nums of even length and there is also an empty array arr. Alice and Bob decided to play a game where in every round Alice and Bob will do one move. The rules of the game are as follows:
Every round, first Alice will remove the minimum element from nums, and then Bob does the same.
Now, first Bob will append the removed element in the array arr, and then Alice does the same.
The game continues until nums becomes empty.
Return the resulting array arr.
","Example 1:
Input: nums = [5,4,2,3]
Output: [3,2,5,4]
Explanation: In round one, first Alice removes 2 and then Bob removes 3. Then in arr firstly Bob appends 3 and then Alice appends 2. So arr = [3,2].
At the begining of round two, nums = [5,4]. Now, first Alice removes 4 and then Bob removes 5. Then both append in arr which becomes [3,2,5,4].
Example 2:
Input: nums = [2,5]
Output: [5,2]
Explanation: In round one, first Alice removes 2 and then Bob removes 5. Then in arr firstly Bob appends and then Alice appends. So arr = [5,2].
","class Solution:
    def numberGame(self, nums: List[int]) -> List[int]:
        #This is a sorted array.
        nums=sorted(nums) 
        # Swap each pair via loop
        for i in range(0,len(nums),2):
            nums[i],nums[i+1]=nums[i+1],nums[i]
        #Return the final array
        return nums    
        ",True
Find Missing and Repeated Values,"You are given a 0-indexed 2D integer matrix grid of size n * n with values in the range [1, n2]. Each integer appears exactly once except a which appears twice and b which is missing. The task is to find the repeating and missing numbers a and b.
Return a 0-indexed integer array ans of size 2 where ans[0] equals to a and ans[1] equals to b.
","Example 1:
Input: grid = [[1,3],[2,2]]
Output: [2,4]
Explanation: Number 2 is repeated and number 4 is missing so the answer is [2,4].
Example 2:
Input: grid = [[9,1,7],[8,9,2],[3,4,6]]
Output: [9,5]
Explanation: Number 9 is repeated and number 5 is missing so the answer is [9,5].
","class Solution:
    def findMissingAndRepeatedValues(self, grid: List[List[int]], ans = [0,0]) -> List[int]:

        n= len(ctr:= Counter(chain(*grid)))+1 

        for num in range(1, n+1):
            if ctr[num] == 1: continue
            ans[1-ctr[num]//2] = num

        return ans",True
Minimum Number of Coins to be Added,"You are given a 0-indexed integer array coins, representing the values of the coins available, and an integer target.
An integer x is obtainable if there exists a subsequence of coins that sums to x.
Return the minimum number of coins of any value that need to be added to the array so that every integer in the range [1, target] is obtainable.
A subsequence of an array is a new non-empty array that is formed from the original array by deleting some (possibly none) of the elements without disturbing the relative positions of the remaining elements.
","Example 1:
Input: coins = [1,4,10], target = 19
Output: 2
Explanation: We need to add coins 2 and 8. The resulting array will be [1,2,4,8,10].
It can be shown that all integers from 1 to 19 are obtainable from the resulting array, and that 2 is the minimum number of coins that need to be added to the array. 
Example 2:
Input: coins = [1,4,10,5,7,19], target = 19
Output: 1
Explanation: We only need to add the coin 2. The resulting array will be [1,2,4,5,7,10,19].
It can be shown that all integers from 1 to 19 are obtainable from the resulting array, and that 1 is the minimum number of coins that need to be added to the array. 
Example 3:
Input: coins = [1,1,1], target = 20
Output: 3
Explanation: We need to add coins 4, 8, and 16. The resulting array will be [1,1,1,4,8,16].
It can be shown that all integers from 1 to 20 are obtainable from the resulting array, and that 3 is the minimum number of coins that need to be added to the array.
","class Solution:
    def minimumAddedCoins(self, coins: List[int], target: int) -> int:
        amounts = defaultdict(int)
        for coin in coins:
            amounts[coin] += coin
        count = _sum = 0
        for i in range(1, target+1):
            if i in amounts:
                _sum += amounts[i]
            elif i > _sum:
                count += 1
                _sum += i
        return count",True
Smallest Missing Integer Greater Than Sequential Prefix Sum,"You are given a 0-indexed array of integers nums.
A prefix nums[0..i] is sequential if, for all 1 <= j <= i, nums[j] = nums[j - 1] + 1. In particular, the prefix consisting only of nums[0] is sequential.
Return the smallest integer x missing from nums such that x is greater than or equal to the sum of the longest sequential prefix.
","Example 1:
Input: nums = [1,2,3,2,5]
Output: 6
Explanation: The longest sequential prefix of nums is [1,2,3] with a sum of 6. 6 is not in the array, therefore 6 is the smallest missing integer greater than or equal to the sum of the longest sequential prefix.
Example 2:
Input: nums = [3,4,5,1,12,14,13]
Output: 15
Explanation: The longest sequential prefix of nums is [3,4,5] with a sum of 12. 12, 13, and 14 belong to the array while 15 does not. Therefore 15 is the smallest missing integer greater than or equal to the sum of the longest sequential prefix.
","class Solution {
public:
    int missingInteger(vector<int>& nums) {
        int sum=nums[0];
        for(int j=1;j<nums.size();j++)
        {
            if(nums[j]==nums[j-1]+1)
            sum=sum+nums[j];
            else
            break;
        }

        // Approach 1 :

        // sort(nums.begin(),nums.end());
        // for(int i=0;i<nums.size();i++)
        // if(nums[i]==sum)
        // sum++;
        
        //Approach 2 : 
        
        while(true)
        {
            bool k=false;
            for(int i=0;i<nums.size();i++)
            {
                if(nums[i]==sum)
                k=true;
            }
            if(k==false)
            return sum;
            sum++;
        }

        return -1;
        
    }
};",False
Divide Array Into Arrays With Max Difference,"You are given an integer array nums of size n and a positive integer k.
Divide the array into one or more arrays of size 3 satisfying the following conditions:
Each element of nums should be in exactly one array.
The difference between any two elements in one array is less than or equal to k.
Return a 2D array containing all the arrays. If it is impossible to satisfy the conditions, return an empty array. And if there are multiple answers, return any of them.
","Example 1:
Input: nums = [1,3,4,8,7,9,3,5,1], k = 2
Output: [[1,1,3],[3,4,5],[7,8,9]]
Explanation: We can divide the array into the following arrays: [1,1,3], [3,4,5] and [7,8,9].
The difference between any two elements in each array is less than or equal to 2.
Note that the order of elements is not important.
Example 2:
Input: nums = [1,3,3,2,7,3], k = 3
Output: []
Explanation: It is not possible to divide the array satisfying all the conditions.
","class Solution:
    def divideArray(self, nums: List[int], k: int) -> List[List[int]]:
        nums.sort()     

        if max(i-j for i, j in zip(nums[2::3],nums[::3])) > k: 
            return []
            
        return zip(nums[::3],nums[1::3],nums[2::3])




        '''
        :: is used for slicing sequences such as lists or strings. 
        The syntax for slicing is [start:stop:step]. 
        If start is not provided, it defaults to the beginning of the sequence. 
        If stop is not provided, it defaults to the end of the sequence. 
        If step is not provided, it defaults to 1.

        nums[::3] means “take every third element from nums, starting from the first element”. 
        Similarly, nums[1::3] means “take every third element from nums, 
        starting from the second element”, 
        and nums[2::3] means “take every third element from nums, 
        starting from the third element”.

        So, if nums is [0, 1, 2, 3, 4, 5, 6, 7, 8], then nums[::3] would be [0, 3, 6], 
        nums[1::3] would be [1, 4, 7], and nums[2::3] would be [2, 5, 8].
        '''


",True
Count Elements With Maximum Frequency,"You are given an array nums consisting of positive integers.
Return the total frequencies of elements in nums such that those elements all have the maximum frequency.
The frequency of an element is the number of occurrences of that element in the array.
","Example 1:
Input: nums = [1,2,2,3,1,4]
Output: 4
Explanation: The elements 1 and 2 have a frequency of 2 which is the maximum frequency in the array.
So the number of elements in the array with maximum frequency is 4.
Example 2:
Input: nums = [1,2,3,4,5]
Output: 5
Explanation: All elements of the array have a frequency of 1 which is the maximum.
So the number of elements in the array with maximum frequency is 5.
","class Solution:
    def maxFrequencyElements(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return 1
        m = max(nums)

        # Encode frequencies
        for i in range(len(nums)):
            nums[nums[i] % 101 % len(nums)] += pow(101, ((nums[i] % 101) // len(nums) + 1))

        # Find max frequency
        m_freq = 0
        pow_num = 101
        for i in range(1,m+1):
            if i % len(nums) == 0:
                pow_num *= 101
            if (nums[i % len(nums)] // pow_num) % 101 > m_freq:
                m_freq = (nums[i % len(nums)] // pow_num) % 101

        # Count amount of elements at max frequency
        pow_num = 101
        tot = 0
        for i in range(1,m+1):
            if i % len(nums) == 0:
                pow_num *= 101
            if (nums[i % len(nums)] // pow_num) % 101 == m_freq:
                tot += m_freq

        return tot
",True
Minimize Length of Array Using Operations,"You are given a 0-indexed integer array nums containing positive integers.
Your task is to minimize the length of nums by performing the following operations any number of times (including zero):
Select two distinct indices i and j from nums, such that nums[i] > 0 and nums[j] > 0.
Insert the result of nums[i] % nums[j] at the end of nums.
Delete the elements at indices i and j from nums.
Return an integer denoting the minimum length of nums after performing the operation any number of times.
","Example 1:
Input: nums = [1,4,3,1]
Output: 1
Explanation: One way to minimize the length of the array is as follows:
Operation 1: Select indices 2 and 1, insert nums[2] % nums[1] at the end and it becomes [1,4,3,1,3], then delete elements at indices 2 and 1.
nums becomes [1,1,3].
Operation 2: Select indices 1 and 2, insert nums[1] % nums[2] at the end and it becomes [1,1,3,1], then delete elements at indices 1 and 2.
nums becomes [1,1].
Operation 3: Select indices 1 and 0, insert nums[1] % nums[0] at the end and it becomes [1,1,0], then delete elements at indices 1 and 0.
nums becomes [0].
The length of nums cannot be reduced further. Hence, the answer is 1.
It can be shown that 1 is the minimum achievable length. 
Example 2:
Input: nums = [5,5,5,10,5]
Output: 2
Explanation: One way to minimize the length of the array is as follows:
Operation 1: Select indices 0 and 3, insert nums[0] % nums[3] at the end and it becomes [5,5,5,10,5,5], then delete elements at indices 0 and 3.
nums becomes [5,5,5,5]. 
Operation 2: Select indices 2 and 3, insert nums[2] % nums[3] at the end and it becomes [5,5,5,5,0], then delete elements at indices 2 and 3. 
nums becomes [5,5,0]. 
Operation 3: Select indices 0 and 1, insert nums[0] % nums[1] at the end and it becomes [5,5,0,0], then delete elements at indices 0 and 1.
nums becomes [0,0].
The length of nums cannot be reduced further. Hence, the answer is 2.
It can be shown that 2 is the minimum achievable length. 
Example 3:
Input: nums = [2,3,4]
Output: 1
Explanation: One way to minimize the length of the array is as follows: 
Operation 1: Select indices 1 and 2, insert nums[1] % nums[2] at the end and it becomes [2,3,4,3], then delete elements at indices 1 and 2.
nums becomes [2,3].
Operation 2: Select indices 1 and 0, insert nums[1] % nums[0] at the end and it becomes [2,3,1], then delete elements at indices 1 and 0.
nums becomes [1].
The length of nums cannot be reduced further. Hence, the answer is 1.
It can be shown that 1 is the minimum achievable length.
","class Solution:
    def minimumArrayLength(self, nums: List[int]) -> int:
        nums.sort()
        
        cnt = 1
        for num in nums[1:]:
            if num == nums[0]: cnt += 1
            else: 
                if num % nums[0] != 0: return 1
        return (cnt+1)//2",True
Check if Bitwise OR Has Trailing Zeros,"You are given an array of positive integers nums.
You have to check if it is possible to select two or more elements in the array such that the bitwise OR of the selected elements has at least one trailing zero in its binary representation.
For example, the binary representation of 5, which is ""101"", does not have any trailing zeros, whereas the binary representation of 4, which is ""100"", has two trailing zeros.
Return true if it is possible to select two or more elements whose bitwise OR has trailing zeros, return false otherwise.
","Example 1:
Input: nums = [1,2,3,4,5]
Output: true
Explanation: If we select the elements 2 and 4, their bitwise OR is 6, which has the binary representation ""110"" with one trailing zero.
Example 2:
Input: nums = [2,4,8,16]
Output: true
Explanation: If we select the elements 2 and 4, their bitwise OR is 6, which has the binary representation ""110"" with one trailing zero.
Other possible ways to select elements to have trailing zeroes in the binary representation of their bitwise OR are: (2, 8), (2, 16), (4, 8), (4, 16), (8, 16), (2, 4, 8), (2, 4, 16), (2, 8, 16), (4, 8, 16), and (2, 4, 8, 16).
Example 3:
Input: nums = [1,3,5,7,9]
Output: false
Explanation: There is no possible way to select two or more elements to have trailing zeros in the binary representation of their bitwise OR.
","class Solution:
    def hasTrailingZeros(self, nums: List[int]) -> bool:
        even = 0
		
        for n in nums:
            if n%2 == 0: 
                even += 1
        
		return even>=2",True
Minimum Number of Operations to Make Array XOR Equal to K,"You are given a 0-indexed integer array nums and a positive integer k.
You can apply the following operation on the array any number of times:
Choose any element of the array and flip a bit in its binary representation. Flipping a bit means changing a 0 to 1 or vice versa.
Return the minimum number of operations required to make the bitwise XOR of all elements of the final array equal to k.
Note that you can flip leading zero bits in the binary representation of elements. For example, for the number (101)2 you can flip the fourth bit and obtain (1101)2.
","Example 1:
Input: nums = [2,1,3,4], k = 1
Output: 2
Explanation: We can do the following operations:
- Choose element 2 which is 3 == (011)2, we flip the first bit and we obtain (010)2 == 2. nums becomes [2,1,2,4].
- Choose element 0 which is 2 == (010)2, we flip the third bit and we obtain (110)2 = 6. nums becomes [6,1,2,4].
The XOR of elements of the final array is (6 XOR 1 XOR 2 XOR 4) == 1 == k.
It can be shown that we cannot make the XOR equal to k in less than 2 operations.
Example 2:
Input: nums = [2,0,2,0], k = 0
Output: 0
Explanation: The XOR of elements of the array is (2 XOR 0 XOR 2 XOR 0) == 0 == k. So no operation is needed.
","class Solution:
  def minOperations(self, nums: List[int], k: int) -> int:
    return functools.reduce(operator.xor, nums, k).bit_count()",True
Maximum Area of Longest Diagonal Rectangle,"You are given a 2D 0-indexed integer array dimensions.
For all indices i, 0 <= i < dimensions.length, dimensions[i][0] represents the length and dimensions[i][1] represents the width of the rectangle i.
Return the area of the rectangle having the longest diagonal. If there are multiple rectangles with the longest diagonal, return the area of the rectangle having the maximum area.
","Example 1:
Input: dimensions = [[9,3],[8,6]]
Output: 48
Explanation: 
For index = 0, length = 9 and width = 3. Diagonal length = sqrt(9 * 9 + 3 * 3) = sqrt(90) ≈ 9.487.
For index = 1, length = 8 and width = 6. Diagonal length = sqrt(8 * 8 + 6 * 6) = sqrt(100) = 10.
So, the rectangle at index 1 has a greater diagonal length therefore we return area = 8 * 6 = 48.
Example 2:
Input: dimensions = [[3,4],[4,3]]
Output: 12
Explanation: Length of diagonal is the same for both which is 5, so maximum area = 12.
",,False
Find Polygon With the Largest Perimeter,"You are given an array of positive integers nums of length n.
A polygon is a closed plane figure that has at least 3 sides. The longest side of a polygon is smaller than the sum of its other sides.
Conversely, if you have k (k >= 3) positive real numbers a1, a2, a3, ..., ak where a1 <= a2 <= a3 <= ... <= ak and a1 + a2 + a3 + ... + ak-1 > ak, then there always exists a polygon with k sides whose lengths are a1, a2, a3, ..., ak.
The perimeter of a polygon is the sum of lengths of its sides.
Return the largest possible perimeter of a polygon whose sides can be formed from nums, or -1 if it is not possible to create a polygon.
","Example 1:
Input: nums = [5,5,5]
Output: 15
Explanation: The only possible polygon that can be made from nums has 3 sides: 5, 5, and 5. The perimeter is 5 + 5 + 5 = 15.
Example 2:
Input: nums = [1,12,1,2,5,50,3]
Output: 12
Explanation: The polygon with the largest perimeter which can be made from nums has 5 sides: 1, 1, 2, 3, and 5. The perimeter is 1 + 1 + 2 + 3 + 5 = 12.
We cannot have a polygon with either 12 or 50 as the longest side because it is not possible to include 2 or more smaller sides that have a greater sum than either of them.
It can be shown that the largest possible perimeter is 12.
Example 3:
Input: nums = [5,5,50]
Output: -1
Explanation: There is no possible way to form a polygon from nums, as a polygon has at least 3 sides and 50 > 5 + 5.
","class Solution {
public:
    long long largestPerimeter(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        long long sum = 0;
        long long ans = -1;
        
        for(int i=0;i<nums.size();i++){
            if(nums[i]<sum)ans = nums[i] + sum;
            sum+=nums[i];
        }
        
        return ans;
    }
};




",False
Maximum Good Subarray Sum,"You are given an array nums of length n and a positive integer k.
A
subarray
of nums is called good if the absolute difference between its first and last element is exactly k, in other words, the subarray nums[i..j] is good if |nums[i] - nums[j]| == k.
Return the maximum sum of a good subarray of nums. If there are no good subarrays, return 0.
","Example 1:
Input: nums = [1,2,3,4,5,6], k = 1
Output: 11
Explanation: The absolute difference between the first and last element must be 1 for a good subarray. All the good subarrays are: [1,2], [2,3], [3,4], [4,5], and [5,6]. The maximum subarray sum is 11 for the subarray [5,6].
Example 2:
Input: nums = [-1,3,2,4,5], k = 3
Output: 11
Explanation: The absolute difference between the first and last element must be 3 for a good subarray. All the good subarrays are: [-1,3,2], and [2,4,5]. The maximum subarray sum is 11 for the subarray [2,4,5].
Example 3:
Input: nums = [-1,-2,-3,-4], k = 2
Output: -6
Explanation: The absolute difference between the first and last element must be 2 for a good subarray. All the good subarrays are: [-1,-2,-3], and [-2,-3,-4]. The maximum subarray sum is -6 for the subarray [-1,-2,-3].
","class Solution:
    def maximumSubarraySum(self, nums: List[int], k: int) -> int:
        prefix_left = defaultdict(lambda: inf)
        res = -inf
        cur = 0 

        for x in nums:
            prefix_left[x] = min(prefix_left[x], cur)
            cur += x

            if x-k in prefix_left:
                res = max(res, cur - prefix_left[x-k])
            if x+k in prefix_left:
                res = max(res, cur - prefix_left[x+k])

        return res if res!=-inf else 0
            ",True
Number of Subarrays That Match a Pattern I,"You are given a 0-indexed integer array nums of size n, and a 0-indexed integer array pattern of size m consisting of integers -1, 0, and 1.
A
subarray
nums[i..j] of size m + 1 is said to match the pattern if the following conditions hold for each element pattern[k]:
nums[i + k + 1] > nums[i + k] if pattern[k] == 1.
nums[i + k + 1] == nums[i + k] if pattern[k] == 0.
nums[i + k + 1] < nums[i + k] if pattern[k] == -1.
Return the count of subarrays in nums that match the pattern.
","Example 1:
Input: nums = [1,2,3,4,5,6], pattern = [1,1]
Output: 4
Explanation: The pattern [1,1] indicates that we are looking for strictly increasing subarrays of size 3. In the array nums, the subarrays [1,2,3], [2,3,4], [3,4,5], and [4,5,6] match this pattern.
Hence, there are 4 subarrays in nums that match the pattern.
Example 2:
Input: nums = [1,4,4,1,3,5,5,3], pattern = [1,0,-1]
Output: 2
Explanation: Here, the pattern [1,0,-1] indicates that we are looking for a sequence where the first number is smaller than the second, the second is equal to the third, and the third is greater than the fourth. In the array nums, the subarrays [1,4,4,1], and [3,5,5,3] match this pattern.
Hence, there are 2 subarrays in nums that match the pattern.
","class Solution {
    public int countMatchingSubarrays(int[] nums, int[] pattern) {
        int n = nums.length;  // Size of the input array nums
        int m = pattern.length;  // Size of the pattern array
        int count = 0;  // Initialize the count of matching subarrays

        // Iterate through all possible starting indices of the subarray
        for (int i = 0; i < n; i++) {
            // Iterate through all possible ending indices of the subarray
            for (int j = i; j < n; j++) {
                // Check if the size of the current subarray is equal to m + 1
                if (j - i + 1 == m + 1) {
                    int l = i;  // Initialize a variable for tracking the current index in the subarray
                    int flag = 0;  // Initialize a flag to track if the subarray matches the pattern

                    // Iterate through the pattern and compare it with the subarray elements
                    for (int k = 0; k < m; k++, l++) {
                        // Check for the matching conditions based on the pattern values
                        if (pattern[k] == 1 && nums[l + 1] > nums[l]) {
                            // If pattern[k] is 1, check for strictly increasing condition
                            continue;
                        } else if (pattern[k] == 0 && nums[l + 1] == nums[l]) {
                            // If pattern[k] is 0, check for equal condition
                            continue;
                        } else if (pattern[k] == -1 && nums[l + 1] < nums[l]) {
                            // If pattern[k] is -1, check for strictly decreasing condition
                            continue;
                        } else {
                            // If any condition fails, set the flag and break out of the loop
                            flag = 1;
                            break;
                        }
                    }

                    // If the flag is still 0, the subarray matches the pattern, so increment the count
                    if (flag == 0) {
                        count++;
                    }
                }
            }
        }

        // Return the final count of matching subarrays
        return count;
    }
}
",False
Find the Number of Ways to Place People I,"You are given a 2D array points of size n x 2 representing integer coordinates of some points on a 2D-plane, where points[i] = [xi, yi].
We define the right direction as positive x-axis (increasing x-coordinate) and the left direction as negative x-axis (decreasing x-coordinate). Similarly, we define the up direction as positive y-axis (increasing y-coordinate) and the down direction as negative y-axis (decreasing y-coordinate)
You have to place n people, including Alice and Bob, at these points such that there is exactly one person at every point. Alice wants to be alone with Bob, so Alice will build a rectangular fence with Alice's position as the upper left corner and Bob's position as the lower right corner of the fence (Note that the fence might not enclose any area, i.e. it can be a line). If any person other than Alice and Bob is either inside the fence or on the fence, Alice will be sad.
Return the number of pairs of points where you can place Alice and Bob, such that Alice does not become sad on building the fence.
Note that Alice can only build a fence with Alice's position as the upper left corner, and Bob's position as the lower right corner. For example, Alice cannot build either of the fences in the picture below with four corners (1, 1), (1, 3), (3, 1), and (3, 3), because:
With Alice at (3, 3) and Bob at (1, 1), Alice's position is not the upper left corner and Bob's position is not the lower right corner of the fence.
With Alice at (1, 3) and Bob at (1, 1), Bob's position is not the lower right corner of the fence.

","Example 1:

Input: points = [[1,1],[2,2],[3,3]]
Output: 0
Explanation: There is no way to place Alice and Bob such that Alice can build a fence with Alice's position as the upper left corner and Bob's position as the lower right corner. Hence we return 0. 
Example 2:

Input: points = [[6,2],[4,4],[2,6]]
Output: 2
Explanation: There are two ways to place Alice and Bob such that Alice will not be sad:
- Place Alice at (4, 4) and Bob at (6, 2).
- Place Alice at (2, 6) and Bob at (4, 4).
You cannot place Alice at (2, 6) and Bob at (6, 2) because the person at (4, 4) will be inside the fence.
Example 3:

Input: points = [[3,1],[1,3],[1,1]]
Output: 2
Explanation: There are two ways to place Alice and Bob such that Alice will not be sad:
- Place Alice at (1, 1) and Bob at (3, 1).
- Place Alice at (1, 3) and Bob at (1, 1).
You cannot place Alice at (1, 3) and Bob at (3, 1) because the person at (1, 1) will be on the fence.
Note that it does not matter if the fence encloses any area, the first and second fences in the image are valid.
","class Solution:
    def numberOfPairs(self, points: List[List[int]]) -> int:
        points.sort(key=lambda x: (x[0],-x[1]))
        cnt = 0
        for i in range(len(points)):
            y = -inf
            for j in range(i+1,len(points)):
                if  points[i][1] >= points[j][1] > y:
                    cnt += 1
                    y = points[j][1]
        return cnt",True
Find if Array Can Be Sorted,"You are given a 0-indexed array of positive integers nums.
In one operation, you can swap any two adjacent elements if they have the same number of
set bits
. You are allowed to do this operation any number of times (including zero).
Return true if you can sort the array, else return false.
","Example 1:
Input: nums = [8,4,2,30,15]
Output: true
Explanation: Let's look at the binary representation of every element. The numbers 2, 4, and 8 have one set bit each with binary representation ""10"", ""100"", and ""1000"" respectively. The numbers 15 and 30 have four set bits each with binary representation ""1111"" and ""11110"".
We can sort the array using 4 operations:
- Swap nums[0] with nums[1]. This operation is valid because 8 and 4 have one set bit each. The array becomes [4,8,2,30,15].
- Swap nums[1] with nums[2]. This operation is valid because 8 and 2 have one set bit each. The array becomes [4,2,8,30,15].
- Swap nums[0] with nums[1]. This operation is valid because 4 and 2 have one set bit each. The array becomes [2,4,8,30,15].
- Swap nums[3] with nums[4]. This operation is valid because 30 and 15 have four set bits each. The array becomes [2,4,8,15,30].
The array has become sorted, hence we return true.
Note that there may be other sequences of operations which also sort the array.
Example 2:
Input: nums = [1,2,3,4,5]
Output: true
Explanation: The array is already sorted, hence we return true.
Example 3:
Input: nums = [3,16,8,4,2]
Output: false
Explanation: It can be shown that it is not possible to sort the input array using any number of operations.
","class Solution:
    def canSortArray(self, nums: List[int]) -> bool:
        i = last = 0
        while i < len(nums):
            x = nums[i].bit_count()
            Min = Max = nums[i]
            j = i + 1
            while j < len(nums) and nums[j].bit_count() == x:
                Min = min(Min, nums[j])
                Max = max(Max, nums[j])
                j += 1
            if last > Min: return False
            i, last = j, Max
        return True",True
Earliest Second to Mark Indices I,"You are given two 1-indexed integer arrays, nums and, changeIndices, having lengths n and m, respectively.
Initially, all indices in nums are unmarked. Your task is to mark all indices in nums.
In each second, s, in order from 1 to m (inclusive), you can perform one of the following operations:
Choose an index i in the range [1, n] and decrement nums[i] by 1.
If nums[changeIndices[s]] is equal to 0, mark the index changeIndices[s].
Do nothing.
Return an integer denoting the earliest second in the range [1, m] when all indices in nums can be marked by choosing operations optimally, or -1 if it is impossible.
","Example 1:
Input: nums = [2,2,0], changeIndices = [2,2,2,2,3,2,2,1]
Output: 8
Explanation: In this example, we have 8 seconds. The following operations can be performed to mark all indices:
Second 1: Choose index 1 and decrement nums[1] by one. nums becomes [1,2,0].
Second 2: Choose index 1 and decrement nums[1] by one. nums becomes [0,2,0].
Second 3: Choose index 2 and decrement nums[2] by one. nums becomes [0,1,0].
Second 4: Choose index 2 and decrement nums[2] by one. nums becomes [0,0,0].
Second 5: Mark the index changeIndices[5], which is marking index 3, since nums[3] is equal to 0.
Second 6: Mark the index changeIndices[6], which is marking index 2, since nums[2] is equal to 0.
Second 7: Do nothing.
Second 8: Mark the index changeIndices[8], which is marking index 1, since nums[1] is equal to 0.
Now all indices have been marked.
It can be shown that it is not possible to mark all indices earlier than the 8th second.
Hence, the answer is 8.
Example 2:
Input: nums = [1,3], changeIndices = [1,1,1,2,1,1,1]
Output: 6
Explanation: In this example, we have 7 seconds. The following operations can be performed to mark all indices:
Second 1: Choose index 2 and decrement nums[2] by one. nums becomes [1,2].
Second 2: Choose index 2 and decrement nums[2] by one. nums becomes [1,1].
Second 3: Choose index 2 and decrement nums[2] by one. nums becomes [1,0].
Second 4: Mark the index changeIndices[4], which is marking index 2, since nums[2] is equal to 0.
Second 5: Choose index 1 and decrement nums[1] by one. nums becomes [0,0].
Second 6: Mark the index changeIndices[6], which is marking index 1, since nums[1] is equal to 0.
Now all indices have been marked.
It can be shown that it is not possible to mark all indices earlier than the 6th second.
Hence, the answer is 6.
Example 3:
Input: nums = [0,1], changeIndices = [2,2,2]
Output: -1
Explanation: In this example, it is impossible to mark all indices because index 1 isn't in changeIndices.
Hence, the answer is -1.
","class Solution:
    def earliestSecondToMarkIndices(self, nums: List[int], changeIndices: List[int]) -> int:
        n = len(nums)
        m = len(changeIndices)

        # decreased indices for convenience
        for i in range(m):
            changeIndices[i] -= 1
        
        def isGood(pos):
            used = [False]*n
            # points - how many points are reserved on the left side
            # for already used numbers
            points = 0
            for i in range(pos, -1, -1):
                if used[changeIndices[i]]:
                    points = max(0, points-1)
                    continue
                num = changeIndices[i]
                used[num] = True
                if nums[num] > (i-points):
                    return False
                points += nums[num]
            # all numbers should be marked
            return used.count(False) == 0
        
        # binary search
        lo = 0
        hi = m - 1
        
        best = -1
        while lo <= hi:
            mid = (lo+hi) // 2
            
            if isGood(mid):
                best = mid+1
                hi = mid-1
            else:
                lo = mid+1
        
        return best    ",True
Find the Maximum Number of Elements in Subset,"You are given an array of positive integers nums.
You need to select a
subset
of nums which satisfies the following condition:
You can place the selected elements in a 0-indexed array such that it follows the pattern: [x, x2, x4, ..., xk/2, xk, xk/2, ..., x4, x2, x] (Note that k can be be any non-negative power of 2). For example, [2, 4, 16, 4, 2] and [3, 9, 3] follow the pattern while [2, 4, 8, 4, 2] does not.
Return the maximum number of elements in a subset that satisfies these conditions.
","Example 1:
Input: nums = [5,4,1,2,2]
Output: 3
Explanation: We can select the subset {4,2,2}, which can be placed in the array as [2,4,2] which follows the pattern and 22 == 4. Hence the answer is 3.
Example 2:
Input: nums = [1,3,2,4]
Output: 1
Explanation: We can select the subset {1}, which can be placed in the array as [1] which follows the pattern. Hence the answer is 1. Note that we could have also selected the subsets {2}, {3}, or {4}, there may be multiple subsets which provide the same answer. 
","class Solution:
    def maximumLength(self, nums: List[int]) -> int:
        freq = defaultdict(int)
        for num in nums:
            freq[num]+=1
        @cache
        def build(n):
            up = n**2
            if up not in freq or freq[n]==1:
                return 1
            if up == n:
                return freq[n]-1 if freq[n]%2==0 else freq[n]
            if freq[up]==1:
                return 3
            return build(up)+2
        ret=1
        for num in freq.keys():
            ret=max(ret, build(num))
        return ret
            
'''
[1,1,1,1,1]
[5,4,1,2,2]
[1,3,2,4]
[1,1]
[14,14,196,196,38416,38416]
[1,1,1,1,1,1,1,1,1,1,2,4,8,16,32,64,128,256,512,1024]

'''",True
Mark Elements on Array by Performing Queries,"You are given a 0-indexed array nums of size n consisting of positive integers.
You are also given a 2D array queries of size m where queries[i] = [indexi, ki].
Initially all elements of the array are unmarked.
You need to apply m queries on the array in order, where on the ith query you do the following:
Mark the element at index indexi if it is not already marked.
Then mark ki unmarked elements in the array with the smallest values. If multiple such elements exist, mark the ones with the smallest indices. And if less than ki unmarked elements exist, then mark all of them.
Return an array answer of size m where answer[i] is the sum of unmarked elements in the array after the ith query.
","Example 1:
Input: nums = [1,2,2,1,2,3,1], queries = [[1,2],[3,3],[4,2]]
Output: [8,3,0]
Explanation:
We do the following queries on the array:
Mark the element at index 1, and 2 of the smallest unmarked elements with the smallest indices if they exist, the marked elements now are nums = [1,2,2,1,2,3,1]. The sum of unmarked elements is 2 + 2 + 3 + 1 = 8.
Mark the element at index 3, since it is already marked we skip it. Then we mark 3 of the smallest unmarked elements with the smallest indices, the marked elements now are nums = [1,2,2,1,2,3,1]. The sum of unmarked elements is 3.
Mark the element at index 4, since it is already marked we skip it. Then we mark 2 of the smallest unmarked elements with the smallest indices if they exist, the marked elements now are nums = [1,2,2,1,2,3,1]. The sum of unmarked elements is 0.
Example 2:
Input: nums = [1,4,2,3], queries = [[0,1]]
Output: [7]
Explanation: We do one query which is mark the element at index 0 and mark the smallest element among unmarked elements. The marked elements will be nums = [1,4,2,3], and the sum of unmarked elements is 4 + 3 = 7.
","class Solution:
    def unmarkedSumArray(self, nums: List[int], 
                               queries: List[List[int]]) -> List[int]:

        n, sm = len(nums), sum(nums)
        unmarked, ans = set(range(n)), []

        heap = list(zip(nums,range(len(nums))))
        heapify(heap)

        for idx, k in queries:

            if idx in unmarked:
                sm -= nums[idx]
                unmarked.discard(idx)

            while k and heap:

                num, idx = heappop(heap) 

                if idx in unmarked:               
                    unmarked.discard(idx)
                    k-= 1
                    sm-= num

            ans.append(sm)

        return ans",True
Apply Operations to Make String Empty,"You are given a string s.
Consider performing the following operation until s becomes empty:
For every alphabet character from 'a' to 'z', remove the first occurrence of that character in s (if it exists).
For example, let initially s = ""aabcbbca"". We do the following operations:
Remove the underlined characters s = ""aabcbbca"". The resulting string is s = ""abbca"".
Remove the underlined characters s = ""abbca"". The resulting string is s = ""ba"".
Remove the underlined characters s = ""ba"". The resulting string is s = """".
Return the value of the string s right before applying the last operation. In the example above, answer is ""ba"".
","Example 1:
Input: s = ""aabcbbca""
Output: ""ba""
Explanation: Explained in the statement.
Example 2:
Input: s = ""abcd""
Output: ""abcd""
Explanation: We do the following operation:
- Remove the underlined characters s = ""abcd"". The resulting string is s = """".
The string just before the last operation is ""abcd"".
",,False
Count Prefix and Suffix Pairs I,"You are given a 0-indexed string array words.
Let's define a boolean function isPrefixAndSuffix that takes two strings, str1 and str2:
isPrefixAndSuffix(str1, str2) returns true if str1 is both a
prefix
and a
suffix
of str2, and false otherwise.
For example, isPrefixAndSuffix(""aba"", ""ababa"") is true because ""aba"" is a prefix of ""ababa"" and also a suffix, but isPrefixAndSuffix(""abc"", ""abcd"") is false.
Return an integer denoting the number of index pairs (i, j) such that i < j, and isPrefixAndSuffix(words[i], words[j]) is true.
","Example 1:
Input: words = [""a"",""aba"",""ababa"",""aa""]
Output: 4
Explanation: In this example, the counted index pairs are:
i = 0 and j = 1 because isPrefixAndSuffix(""a"", ""aba"") is true.
i = 0 and j = 2 because isPrefixAndSuffix(""a"", ""ababa"") is true.
i = 0 and j = 3 because isPrefixAndSuffix(""a"", ""aa"") is true.
i = 1 and j = 2 because isPrefixAndSuffix(""aba"", ""ababa"") is true.
Therefore, the answer is 4.
Example 2:
Input: words = [""pa"",""papa"",""ma"",""mama""]
Output: 2
Explanation: In this example, the counted index pairs are:
i = 0 and j = 1 because isPrefixAndSuffix(""pa"", ""papa"") is true.
i = 2 and j = 3 because isPrefixAndSuffix(""ma"", ""mama"") is true.
Therefore, the answer is 2.  
Example 3:
Input: words = [""abab"",""ab""]
Output: 0
Explanation: In this example, the only valid index pair is i = 0 and j = 1, and isPrefixAndSuffix(""abab"", ""ab"") is false.
Therefore, the answer is 0.
","class Solution:
    def countPrefixSuffixPairs(self, w: List[str]) -> int:
        count = 0
        for i in range(len(w)):
            t = len(w[i])
            for j in range(i+1,len(w)):
                if len(w[j])>=t:
                    if w[j][:t]==w[i] and w[j][-t:]==w[i]:
                        count+=1
        return count
                
        ",True
Ant on the Boundary,"An ant is on a boundary. It sometimes goes left and sometimes right.
You are given an array of non-zero integers nums. The ant starts reading nums from the first element of it to its end. At each step, it moves according to the value of the current element:
If nums[i] < 0, it moves left by -nums[i] units.
If nums[i] > 0, it moves right by nums[i] units.
Return the number of times the ant returns to the boundary.
Notes:
There is an infinite space on both sides of the boundary.
We check whether the ant is on the boundary only after it has moved |nums[i]| units. In other words, if the ant crosses the boundary during its movement, it does not count.
","Example 1:
Input: nums = [2,3,-5]
Output: 1
Explanation: After the first step, the ant is 2 steps to the right of the boundary.
After the second step, the ant is 5 steps to the right of the boundary.
After the third step, the ant is on the boundary.
So the answer is 1.
Example 2:
Input: nums = [3,2,-3,-4]
Output: 0
Explanation: After the first step, the ant is 3 steps to the right of the boundary.
After the second step, the ant is 5 steps to the right of the boundary.
After the third step, the ant is 2 steps to the right of the boundary.
After the fourth step, the ant is 2 steps to the left of the boundary.
The ant never returned to the boundary, so the answer is 0.
","class Solution:
    def returnToBoundaryCount(self, nums: List[int]) -> int:
        answ,pos=0,0
        for num in nums:
            pos+=num
            answ+=pos==0
        return answ    ",True
Most Frequent Prime,"You are given a m x n 0-indexed 2D matrix mat. From every cell, you can create numbers in the following way:
There could be at most 8 paths from the cells namely: east, south-east, south, south-west, west, north-west, north, and north-east.
Select a path from them and append digits in this path to the number being formed by traveling in this direction.
Note that numbers are generated at every step, for example, if the digits along the path are 1, 9, 1, then there will be three numbers generated along the way: 1, 19, 191.
Return the most frequent
prime number
greater than 10 out of all the numbers created by traversing the matrix or -1 if no such prime number exists. If there are multiple prime numbers with the highest frequency, then return the largest among them.
Note: It is invalid to change the direction during the move.
","Example 1:

Input: mat = [[1,1],[9,9],[1,1]]
Output: 19
Explanation: 
From cell (0,0) there are 3 possible directions and the numbers greater than 10 which can be created in those directions are:
East: [11], South-East: [19], South: [19,191].
Numbers greater than 10 created from the cell (0,1) in all possible directions are: [19,191,19,11].
Numbers greater than 10 created from the cell (1,0) in all possible directions are: [99,91,91,91,91].
Numbers greater than 10 created from the cell (1,1) in all possible directions are: [91,91,99,91,91].
Numbers greater than 10 created from the cell (2,0) in all possible directions are: [11,19,191,19].
Numbers greater than 10 created from the cell (2,1) in all possible directions are: [11,19,19,191].
The most frequent prime number among all the created numbers is 19.
Example 2:
Input: mat = [[7]]
Output: -1
Explanation: The only number which can be formed is 7. It is a prime number however it is not greater than 10, so return -1.
Example 3:
Input: mat = [[9,7,8],[4,6,5],[2,8,6]]
Output: 97
Explanation: 
Numbers greater than 10 created from the cell (0,0) in all possible directions are: [97,978,96,966,94,942].
Numbers greater than 10 created from the cell (0,1) in all possible directions are: [78,75,76,768,74,79].
Numbers greater than 10 created from the cell (0,2) in all possible directions are: [85,856,86,862,87,879].
Numbers greater than 10 created from the cell (1,0) in all possible directions are: [46,465,48,42,49,47].
Numbers greater than 10 created from the cell (1,1) in all possible directions are: [65,66,68,62,64,69,67,68].
Numbers greater than 10 created from the cell (1,2) in all possible directions are: [56,58,56,564,57,58].
Numbers greater than 10 created from the cell (2,0) in all possible directions are: [28,286,24,249,26,268].
Numbers greater than 10 created from the cell (2,1) in all possible directions are: [86,82,84,86,867,85].
Numbers greater than 10 created from the cell (2,2) in all possible directions are: [68,682,66,669,65,658].
The most frequent prime number among all the created numbers is 97.
","class Solution:
    def mostFrequentPrime(self, mat: List[List[int]]) -> int:

        nums = []
        m,n, d = range(len(mat)),range(len(mat[0])), (-1,0,1)
        
        def isPrime(num):
            if num < 10 or num%2 == 0: return False
            for i in range(3, isqrt(num)+1, 2):
                if num %i == 0: return False
            return True
        
        for x, y, dx,dy in product(m,n, d,d):
                if dx == 0 == dy: continue
                X, Y, num = x+dx, y+dy, mat[x][y]

                while X in m and Y in n:
                    nums.append(num:= num*10 + mat[X][Y])
                    X+= dx
                    Y+= dy      
        
        return max(filter(isPrime, ctr:= Counter(nums)), 
                key = lambda x: (ctr[x], x), default = -1)",True
Maximum Palindromes After Operations,"You are given a 0-indexed string array words having length n and containing 0-indexed strings.
You are allowed to perform the following operation any number of times (including zero):
Choose integers i, j, x, and y such that 0 <= i, j < n, 0 <= x < words[i].length, 0 <= y < words[j].length, and swap the characters words[i][x] and words[j][y].
Return an integer denoting the maximum number of
palindromes
words can contain, after performing some operations.
Note: i and j may be equal during an operation.
","Example 1:
Input: words = [""abbb"",""ba"",""aa""]
Output: 3
Explanation: In this example, one way to get the maximum number of palindromes is:
Choose i = 0, j = 1, x = 0, y = 0, so we swap words[0][0] and words[1][0]. words becomes [""bbbb"",""aa"",""aa""].
All strings in words are now palindromes.
Hence, the maximum number of palindromes achievable is 3.
Example 2:
Input: words = [""abc"",""ab""]
Output: 2
Explanation: In this example, one way to get the maximum number of palindromes is: 
Choose i = 0, j = 1, x = 1, y = 0, so we swap words[0][1] and words[1][0]. words becomes [""aac"",""bb""].
Choose i = 0, j = 0, x = 1, y = 2, so we swap words[0][1] and words[0][2]. words becomes [""aca"",""bb""].
Both strings are now palindromes.
Hence, the maximum number of palindromes achievable is 2.
Example 3:
Input: words = [""cd"",""ef"",""a""]
Output: 1
Explanation: In this example, there is no need to perform any operation.
There is one palindrome in words ""a"".
It can be shown that it is not possible to get more than one palindrome after any number of operations.
Hence, the answer is 1.
",,False
Maximum Number of Operations With the Same Score II,"Given an array of integers called nums, you can perform any of the following operation while nums contains at least 2 elements:
Choose the first two elements of nums and delete them.
Choose the last two elements of nums and delete them.
Choose the first and the last elements of nums and delete them.
The score of the operation is the sum of the deleted elements.
Your task is to find the maximum number of operations that can be performed, such that all operations have the same score.
Return the maximum number of operations possible that satisfy the condition mentioned above.
","Example 1:
Input: nums = [3,2,1,2,3,4]
Output: 3
Explanation: We perform the following operations:
- Delete the first two elements, with score 3 + 2 = 5, nums = [1,2,3,4].
- Delete the first and the last elements, with score 1 + 4 = 5, nums = [2,3].
- Delete the first and the last elements, with score 2 + 3 = 5, nums = [].
We are unable to perform any more operations as nums is empty.
Example 2:
Input: nums = [3,2,6,1,4]
Output: 2
Explanation: We perform the following operations:
- Delete the first two elements, with score 3 + 2 = 5, nums = [6,1,4].
- Delete the last two elements, with score 1 + 4 = 5, nums = [6].
It can be proven that we can perform at most 2 operations.
","class Solution:
    def maxOperations(self, nums: List[int]) -> int:

        @cache
        def dfs(l, r, scr):
            if l >= r: return 0

            ans = 0
            left = nums[l] + nums[l+1]
            right = nums[r] + nums[r-1]
            mid = nums[l] + nums[r]

            if scr==0 or scr == left:
                ans = max(ans, 1 + dfs(l+2, r, max(scr, left)))
            if scr == 0 or scr == right:
                ans = max(ans, 1 + dfs(l, r-2, max(scr, right)))
            if scr == 0 or scr == mid:
                ans = max(ans, 1+ dfs(l+1, r-1, max(scr, mid)))
            return ans

        return dfs(0, len(nums) -1, 0)
        ",True
Type of Triangle,"You are given a 0-indexed integer array nums of size 3 which can form the sides of a triangle.
A triangle is called equilateral if it has all sides of equal length.
A triangle is called isosceles if it has exactly two sides of equal length.
A triangle is called scalene if all its sides are of different lengths.
Return a string representing the type of triangle that can be formed or ""none"" if it cannot form a triangle.
","Example 1:
Input: nums = [3,3,3]
Output: ""equilateral""
Explanation: Since all the sides are of equal length, therefore, it will form an equilateral triangle.
Example 2:
Input: nums = [3,4,5]
Output: ""scalene""
Explanation: 
nums[0] + nums[1] = 3 + 4 = 7, which is greater than nums[2] = 5.
nums[0] + nums[2] = 3 + 5 = 8, which is greater than nums[1] = 4.
nums[1] + nums[2] = 4 + 5 = 9, which is greater than nums[0] = 3. 
Since the sum of the two sides is greater than the third side for all three cases, therefore, it can form a triangle.
As all the sides are of different lengths, it will form a scalene triangle.
","class Solution:
    def triangleType(self, nums: List[int]) -> str:
        if nums[0]==nums[1]==nums[2]:
            return ""equilateral""
        elif (nums[0]+nums[1] > nums[2])  and (nums[0]+nums[2] > nums[1]) and (nums[1]+nums[2] > nums[0]):
            if nums[0]==nums[1] or nums[0]==nums[2] or nums[1]==nums[2]:
                return ""isosceles""
            else:
                return ""scalene""
        else:
            return ""none""",True
Find the Largest Area of Square Inside Two Rectangles,"There exist n rectangles in a 2D plane. You are given two 0-indexed 2D integer arrays bottomLeft and topRight, both of size n x 2, where bottomLeft[i] and topRight[i] represent the bottom-left and top-right coordinates of the ith rectangle respectively.
You can select a region formed from the intersection of two of the given rectangles. You need to find the largest area of a square that can fit inside this region if you select the region optimally.
Return the largest possible area of a square, or 0 if there do not exist any intersecting regions between the rectangles.
","Example 1:

Input: bottomLeft = [[1,1],[2,2],[3,1]], topRight = [[3,3],[4,4],[6,6]]
Output: 1
Explanation: A square with side length 1 can fit inside either the intersecting region of rectangle 0 and rectangle 1, or the intersecting region of rectangle 1 and rectangle 2. Hence the largest area is side * side which is 1 * 1 == 1.
It can be shown that a square with a greater side length can not fit inside any intersecting region.
Example 2:

Input: bottomLeft = [[1,1],[2,2],[1,2]], topRight = [[3,3],[4,4],[3,4]]
Output: 1
Explanation: A square with side length 1 can fit inside either the intersecting region of rectangle 0 and rectangle 1, the intersecting region of rectangle 1 and rectangle 2, or the intersection region of all 3 rectangles. Hence the largest area is side * side which is 1 * 1 == 1.
It can be shown that a square with a greater side length can not fit inside any intersecting region.
Note that the region can be formed by the intersection of more than 2 rectangles.
Example 3:

Input: bottomLeft = [[1,1],[3,3],[3,1]], topRight = [[2,2],[4,4],[4,2]]
Output: 0
Explanation: No pair of rectangles intersect, hence, we return 0.
","class Solution:
    def largestSquareArea(self, bottomLeft: List[List[int]], topRight: List[List[int]]) -> int:
        n = len(bottomLeft)
        res = 0
        for i in range(n):
            for j in range(i+1, n):
                w = max(0, min(topRight[i][0], topRight[j][0]) - max(bottomLeft[i][0], bottomLeft[j][0]))                
                h = max(0, min(topRight[i][1], topRight[j][1]) - max(bottomLeft[i][1], bottomLeft[j][1]))
                res = max(res, min(w, h)**2)
        return res
                    
        
        ",True
Find the Length of the Longest Common Prefix,"You are given two arrays with positive integers arr1 and arr2.
A prefix of a positive integer is an integer formed by one or more of its digits, starting from its leftmost digit. For example, 123 is a prefix of the integer 12345, while 234 is not.
A common prefix of two integers a and b is an integer c, such that c is a prefix of both a and b. For example, 5655359 and 56554 have a common prefix 565 while 1223 and 43456 do not have a common prefix.
You need to find the length of the longest common prefix between all pairs of integers (x, y) such that x belongs to arr1 and y belongs to arr2.
Return the length of the longest common prefix among all pairs. If no common prefix exists among them, return 0.
","Example 1:
Input: arr1 = [1,10,100], arr2 = [1000]
Output: 3
Explanation: There are 3 pairs (arr1[i], arr2[j]):
- The longest common prefix of (1, 1000) is 1.
- The longest common prefix of (10, 1000) is 10.
- The longest common prefix of (100, 1000) is 100.
The longest common prefix is 100 with a length of 3.
Example 2:
Input: arr1 = [1,2,3], arr2 = [4,4,4]
Output: 0
Explanation: There exists no common prefix for any pair (arr1[i], arr2[j]), hence we return 0.
Note that common prefixes between elements of the same array do not count.
","class Solution:
    def longestCommonPrefix(self, arr1, arr2):
        dict1, max_len = collections.defaultdict(int), 0

        for i in range(len(arr1)):
            str1 = """"
            for j in str(arr1[i]):
                str1 += j  
                dict1[str1] += 1 

        for i in range(len(arr2)):
            str2 = """"
            for j in str(arr2[i]):
                str2 += j 
                if str2 in dict1:
                    max_len = max(max_len,len(str2))


        return max_len   


        ",True
Modify the Matrix,"Given a 0-indexed m x n integer matrix matrix, create a new 0-indexed matrix called answer. Make answer equal to matrix, then replace each element with the value -1 with the maximum element in its respective column.
Return the matrix answer.
","Example 1:

Input: matrix = [[1,2,-1],[4,-1,6],[7,8,9]]
Output: [[1,2,9],[4,8,6],[7,8,9]]
Explanation: The diagram above shows the elements that are changed (in blue).
- We replace the value in the cell [1][1] with the maximum value in the column 1, that is 8.
- We replace the value in the cell [0][2] with the maximum value in the column 2, that is 9.
Example 2:

Input: matrix = [[3,-1],[5,2]]
Output: [[3,2],[5,2]]
Explanation: The diagram above shows the elements that are changed (in blue).
","class Solution:
	def modifiedMatrix(self, matrix: List[List[int]]) -> List[List[int]]:

		max_columns = []

		rows = len(matrix)

		cols = len(matrix[0])

		for j in range(cols):

			max_element = -1000

			for i in range(rows):

				max_element = max(max_element , matrix[i][j])

			max_columns.append(max_element)

		for i in range(rows):

			for j in range(cols):

				if matrix[i][j] == -1:

					matrix[i][j] = max_columns[j]

		return matrix
		
Time Complexity : O(R * C)
Space Complexity : O(C)",True
Minimum Operations to Exceed Threshold Value I,"You are given a 0-indexed integer array nums, and an integer k.
In one operation, you can remove one occurrence of the smallest element of nums.
Return the minimum number of operations needed so that all elements of the array are greater than or equal to k.
","Example 1:
Input: nums = [2,11,10,1,3], k = 10
Output: 3
Explanation: After one operation, nums becomes equal to [2, 11, 10, 3].
After two operations, nums becomes equal to [11, 10, 3].
After three operations, nums becomes equal to [11, 10].
At this stage, all the elements of nums are greater than or equal to 10 so we can stop.
It can be shown that 3 is the minimum number of operations needed so that all elements of the array are greater than or equal to 10.
Example 2:
Input: nums = [1,1,2,4,9], k = 1
Output: 0
Explanation: All elements of the array are greater than or equal to 1 so we do not need to apply any operations on nums.
Example 3:
Input: nums = [1,1,2,4,9], k = 9
Output: 4
Explanation: only a single element of nums is greater than or equal to 9 so we need to apply the operations 4 times on nums.
","class Solution:
    def minOperations(self, nums: List[int], k: int) -> int:
        return bisect_left(sorted(nums), k)",True
Minimum Operations to Exceed Threshold Value II,"You are given a 0-indexed integer array nums, and an integer k.
In one operation, you will:
Take the two smallest integers x and y in nums.
Remove x and y from nums.
Add min(x, y) * 2 + max(x, y) anywhere in the array.
Note that you can only apply the described operation if nums contains at least two elements.
Return the minimum number of operations needed so that all elements of the array are greater than or equal to k.
","Example 1:
Input: nums = [2,11,10,1,3], k = 10
Output: 2
Explanation: In the first operation, we remove elements 1 and 2, then add 1 * 2 + 2 to nums. nums becomes equal to [4, 11, 10, 3].
In the second operation, we remove elements 3 and 4, then add 3 * 2 + 4 to nums. nums becomes equal to [10, 11, 10].
At this stage, all the elements of nums are greater than or equal to 10 so we can stop.
It can be shown that 2 is the minimum number of operations needed so that all elements of the array are greater than or equal to 10.
Example 2:
Input: nums = [1,1,2,4,9], k = 20
Output: 4
Explanation: After one operation, nums becomes equal to [2, 4, 9, 3].
After two operations, nums becomes equal to [7, 4, 9].
After three operations, nums becomes equal to [15, 9].
After four operations, nums becomes equal to [33].
At this stage, all the elements of nums are greater than 20 so we can stop.
It can be shown that 4 is the minimum number of operations needed so that all elements of the array are greater than or equal to 20.
",,False
Apple Redistribution into Boxes,"You are given an array apple of size n and an array capacity of size m.
There are n packs where the ith pack contains apple[i] apples. There are m boxes as well, and the ith box has a capacity of capacity[i] apples.
Return the minimum number of boxes you need to select to redistribute these n packs of apples into boxes.
Note that, apples from the same pack can be distributed into different boxes.
","Example 1:
Input: apple = [1,3,2], capacity = [4,3,1,5,2]
Output: 2
Explanation: We will use boxes with capacities 4 and 5.
It is possible to distribute the apples as the total capacity is greater than or equal to the total number of apples.
Example 2:
Input: apple = [5,5,5], capacity = [2,4,2,7]
Output: 4
Explanation: We will need to use all the boxes.
","class Solution:
    def minimumBoxes(self, apple: List[int], capacity: List[int]) -> int:
        n = len(capacity)
        heapq.heapify(apple)
        capacity = [-c for c in capacity]
        heapq.heapify(capacity)
        s1 = s2 = 0
        while apple:
            s1 += heapq.heappop(apple)
            while s2 < s1:
                s2 -= heapq.heappop(capacity)
        return n - len(capacity)",True
Count Submatrices with Top-Left Element and Sum Less Than k,"You are given a 0-indexed integer matrix grid and an integer k.
Return the number of
submatrices
that contain the top-left element of the grid, and have a sum less than or equal to k.
","Example 1:

Input: grid = [[7,6,3],[6,6,1]], k = 18
Output: 4
Explanation: There are only 4 submatrices, shown in the image above, that contain the top-left element of grid, and have a sum less than or equal to 18.
Example 2:

Input: grid = [[7,2,9],[1,5,0],[2,6,6]], k = 20
Output: 6
Explanation: There are only 6 submatrices, shown in the image above, that contain the top-left element of grid, and have a sum less than or equal to 20.
","class Solution:
    def countSubmatrices(self, grid: List[List[int]], k: int) -> int:
        
        grid = map(accumulate, grid)
        grid = map(accumulate, zip(*grid))

        return sum(map(lambda x: x <= k, chain(*grid)))",True
Distribute Elements Into Two Arrays I,"You are given a 1-indexed array of distinct integers nums of length n.
You need to distribute all the elements of nums between two arrays arr1 and arr2 using n operations. In the first operation, append nums[1] to arr1. In the second operation, append nums[2] to arr2. Afterwards, in the ith operation:
If the last element of arr1 is greater than the last element of arr2, append nums[i] to arr1. Otherwise, append nums[i] to arr2.
The array result is formed by concatenating the arrays arr1 and arr2. For example, if arr1 == [1,2,3] and arr2 == [4,5,6], then result = [1,2,3,4,5,6].
Return the array result.
","Example 1:
Input: nums = [2,1,3]
Output: [2,3,1]
Explanation: After the first 2 operations, arr1 = [2] and arr2 = [1].
In the 3rd operation, as the last element of arr1 is greater than the last element of arr2 (2 > 1), append nums[3] to arr1.
After 3 operations, arr1 = [2,3] and arr2 = [1].
Hence, the array result formed by concatenation is [2,3,1].
Example 2:
Input: nums = [5,4,3,8]
Output: [5,3,4,8]
Explanation: After the first 2 operations, arr1 = [5] and arr2 = [4].
In the 3rd operation, as the last element of arr1 is greater than the last element of arr2 (5 > 4), append nums[3] to arr1, hence arr1 becomes [5,3].
In the 4th operation, as the last element of arr2 is greater than the last element of arr1 (4 > 3), append nums[4] to arr2, hence arr2 becomes [4,8].
After 4 operations, arr1 = [5,3] and arr2 = [4,8].
Hence, the array result formed by concatenation is [5,3,4,8].
","class Solution:
    def resultArray(self, num: List[int]) -> List[int]:
        arr1 = []
        arr2 = []
        if len(num)==0 or len(num) == 1:
            return num
        arr1.append(num[0])
        arr2.append(num[1])
        for i in num[2:]:
            if arr1[-1] > arr2[-1]:
                arr1.append(i)
            else:
                arr2.append(i)
        return arr1+arr2",True
Maximize Happiness of Selected Children,"You are given an array happiness of length n, and a positive integer k.
There are n children standing in a queue, where the ith child has happiness value happiness[i]. You want to select k children from these n children in k turns.
In each turn, when you select a child, the happiness value of all the children that have not been selected till now decreases by 1. Note that the happiness value cannot become negative and gets decremented only if it is positive.
Return the maximum sum of the happiness values of the selected children you can achieve by selecting k children.
","Example 1:
Input: happiness = [1,2,3], k = 2
Output: 4
Explanation: We can pick 2 children in the following way:
- Pick the child with the happiness value == 3. The happiness value of the remaining children becomes [0,1].
- Pick the child with the happiness value == 1. The happiness value of the remaining child becomes [0]. Note that the happiness value cannot become less than 0.
The sum of the happiness values of the selected children is 3 + 1 = 4.
Example 2:
Input: happiness = [1,1,1,1], k = 2
Output: 1
Explanation: We can pick 2 children in the following way:
- Pick any child with the happiness value == 1. The happiness value of the remaining children becomes [0,0,0].
- Pick the child with the happiness value == 0. The happiness value of the remaining child becomes [0,0].
The sum of the happiness values of the selected children is 1 + 0 = 1.
Example 3:
Input: happiness = [2,3,4,5], k = 1
Output: 5
Explanation: We can pick 1 child in the following way:
- Pick the child with the happiness value == 5. The happiness value of the remaining children becomes [1,2,3].
The sum of the happiness values of the selected children is 5.
","class Solution
{
public
    long maximumHappinessSum(int[] happiness, int k)
    {
        Arrays.sort(happiness); // Sort the happiness values in ascending order
        long totalHappiness = 0, happinessReduced = 0;
        int len = happiness.length;

        // Traverse the sorted happiness values in reverse order
        for (int i = len - 1; k > 0; i--, k--)
        {
            // If reducing the happiness value by the current track value makes it non-positive, return the total happiness
            if (happiness[i] - happinessReduced <= 0)
                return totalHappiness;
            totalHappiness += happiness[i] - happinessReduced; // Add the current maximum happiness value to the total
            happinessReduced++;                                // Increment the track value
        }

        return totalHappiness; // Return the total maximum happiness sum
    }
}",False
Minimum Levels to Gain More Points,"You are given a binary array possible of length n.
Alice and Bob are playing a game that consists of n levels. Some of the levels in the game are impossible to clear while others can always be cleared. In particular, if possible[i] == 0, then the ith level is impossible to clear for both the players. A player gains 1 point on clearing a level and loses 1 point if the player fails to clear it.
At the start of the game, Alice will play some levels in the given order starting from the 0th level, after which Bob will play for the rest of the levels.
Alice wants to know the minimum number of levels she should play to gain more points than Bob, if both players play optimally to maximize their points.
Return the minimum number of levels Alice should play to gain more points. If this is not possible, return -1.
Note that each player must play at least 1 level.
","Example 1:
Input: possible = [1,0,1,0]
Output: 1
Explanation:
Let's look at all the levels that Alice can play up to:
If Alice plays only level 0 and Bob plays the rest of the levels, Alice has 1 point, while Bob has -1 + 1 - 1 = -1 point.
If Alice plays till level 1 and Bob plays the rest of the levels, Alice has 1 - 1 = 0 points, while Bob has 1 - 1 = 0 points.
If Alice plays till level 2 and Bob plays the rest of the levels, Alice has 1 - 1 + 1 = 1 point, while Bob has -1 point.
Alice must play a minimum of 1 level to gain more points.
Example 2:
Input: possible = [1,1,1,1,1]
Output: 3
Explanation:
Let's look at all the levels that Alice can play up to:
If Alice plays only level 0 and Bob plays the rest of the levels, Alice has 1 point, while Bob has 4 points.
If Alice plays till level 1 and Bob plays the rest of the levels, Alice has 2 points, while Bob has 3 points.
If Alice plays till level 2 and Bob plays the rest of the levels, Alice has 3 points, while Bob has 2 points.
If Alice plays till level 3 and Bob plays the rest of the levels, Alice has 4 points, while Bob has 1 point.
Alice must play a minimum of 3 levels to gain more points.
Example 3:
Input: possible = [0,0]
Output: -1
Explanation:
The only possible way is for both players to play 1 level each. Alice plays level 0 and loses 1 point. Bob plays level 1 and loses 1 point. As both players have equal points, Alice can't gain more points than Bob.
","class Solution:
    def minimumLevels(self, possible: List[int]) -> int:
        ans=0
        left=[0]*(len(possible))
        right=[0]*(len(possible))
        acc=0
        for i in range(len(possible)):
            if possible[i]==1:
                acc+=possible[i]
            else:acc-=1
            left[i]=acc
        acc=0
        for i in range(len(possible)-1,-1,-1):
            if possible[i]==1:
                acc+=possible[i]
            else:acc-=1
            right[i]=acc
        f=0   
        for i in range(0,len(possible)-1):
            if left[i]-right[i+1]>0:
                return i+1
        

        return -1 
        
                  
        ",True
Shortest Uncommon Substring in an Array,"You are given an array arr of size n consisting of non-empty strings.
Find a string array answer of size n such that:
answer[i] is the shortest
substring
of arr[i] that does not occur as a substring in any other string in arr. If multiple such substrings exist, answer[i] should be the
lexicographically smallest
. And if no such substring exists, answer[i] should be an empty string.
Return the array answer.
","Example 1:
Input: arr = [""cab"",""ad"",""bad"",""c""]
Output: [""ab"","""",""ba"",""""]
Explanation: We have the following:
- For the string ""cab"", the shortest substring that does not occur in any other string is either ""ca"" or ""ab"", we choose the lexicographically smaller substring, which is ""ab"".
- For the string ""ad"", there is no substring that does not occur in any other string.
- For the string ""bad"", the shortest substring that does not occur in any other string is ""ba"".
- For the string ""c"", there is no substring that does not occur in any other string.
Example 2:
Input: arr = [""abc"",""bcd"",""abcd""]
Output: ["""","""",""abcd""]
Explanation: We have the following:
- For the string ""abc"", there is no substring that does not occur in any other string.
- For the string ""bcd"", there is no substring that does not occur in any other string.
- For the string ""abcd"", the shortest substring that does not occur in any other string is ""abcd"".
","class Solution:
    def shortestSubstrings(self, arr: List[str]) -> List[str]:
        res = ['']*len(arr)
        
        for index,s in enumerate(arr):
            substrings=sorted([s[i: j] for i in range(len(s)) for j in range(i + 1, len(s) + 1)],key=len)
            for i1,s1 in enumerate(arr):
                if index!=i1:
                    for k in range(len(substrings)):
                        if substrings[k] in s1:
                            substrings[k]=''
                            
            for l in substrings:
                if l!='' and res[index]=='':
                    res[index] = l
                    
                if res[index]!='' and len(res[index])==len(l) and l<res[index]:
                    res[index]=l
                        

        return res
                        
            

                ",True
Most Frequent IDs,"The problem involves tracking the frequency of IDs in a collection that changes over time. You have two integer arrays, nums and freq, of equal length n. Each element in nums represents an ID, and the corresponding element in freq indicates how many times that ID should be added to or removed from the collection at each step.
Addition of IDs: If freq[i] is positive, it means freq[i] IDs with the value nums[i] are added to the collection at step i.
Removal of IDs: If freq[i] is negative, it means -freq[i] IDs with the value nums[i] are removed from the collection at step i.
Return an array ans of length n, where ans[i] represents the count of the most frequent ID in the collection after the ith step. If the collection is empty at any step, ans[i] should be 0 for that step.
","Example 1:
Input: nums = [2,3,2,1], freq = [3,2,-3,1]
Output: [3,3,2,2]
Explanation:
After step 0, we have 3 IDs with the value of 2. So ans[0] = 3.
After step 1, we have 3 IDs with the value of 2 and 2 IDs with the value of 3. So ans[1] = 3.
After step 2, we have 2 IDs with the value of 3. So ans[2] = 2.
After step 3, we have 2 IDs with the value of 3 and 1 ID with the value of 1. So ans[3] = 2.
Example 2:
Input: nums = [5,5,3], freq = [2,-2,1]
Output: [2,0,1]
Explanation:
After step 0, we have 2 IDs with the value of 5. So ans[0] = 2.
After step 1, there are no IDs. So ans[1] = 0.
After step 2, we have 1 ID with the value of 3. So ans[2] = 1.
",,False
Find the Sum of Encrypted Integers,"You are given an integer array nums containing positive integers. We define a function encrypt such that encrypt(x) replaces every digit in x with the largest digit in x. For example, encrypt(523) = 555 and encrypt(213) = 333.
Return the sum of encrypted elements.
","Example 1:
Input: nums = [1,2,3]
Output: 6
Explanation: The encrypted elements are [1,2,3]. The sum of encrypted elements is 1 + 2 + 3 == 6.
Example 2:
Input: nums = [10,21,31]
Output: 66
Explanation: The encrypted elements are [11,22,33]. The sum of encrypted elements is 11 + 22 + 33 == 66.
","class Solution:
    def sumOfEncryptedInt(self, nums: List[int]) -> int:
        sum1=0
        for i in nums:
            if i>=10:
                i=str(i)
                i=list(i)
                d=max(i)
                c=d*len(i)
                sum1+=int(c)
            else:
                sum1+=i
        return sum1",True
Longest Strictly Increasing or Strictly Decreasing Subarray,"You are given an array of integers nums. Return the length of the longest
subarray
of nums which is either
strictly increasing
or
strictly decreasing
.
","Example 1:
Input: nums = [1,4,3,3,2]
Output: 2
Explanation:
The strictly increasing subarrays of nums are [1], [2], [3], [3], [4], and [1,4].
The strictly decreasing subarrays of nums are [1], [2], [3], [3], [4], [3,2], and [4,3].
Hence, we return 2.
Example 2:
Input: nums = [3,3,3,3]
Output: 1
Explanation:
The strictly increasing subarrays of nums are [3], [3], [3], and [3].
The strictly decreasing subarrays of nums are [3], [3], [3], and [3].
Hence, we return 1.
Example 3:
Input: nums = [3,2,1]
Output: 3
Explanation:
The strictly increasing subarrays of nums are [3], [2], and [1].
The strictly decreasing subarrays of nums are [3], [2], [1], [3,2], [2,1], and [3,2,1].
Hence, we return 3.
","class Solution {
    public int longestMonotonicSubarray(int[] nums) {
        int maxLength = 1;
        int incLength = 1;
        int decLength = 1;
        for(int i = 1; i < nums.length; i++) {
            if(nums[i] > nums[i - 1]) {
                incLength++;
                decLength = 1;
            } else if(nums[i] < nums[i - 1]) {
                decLength++;
                incLength = 1;
            } else {
                incLength = 1;
                decLength = 1;
            }
            maxLength = Math.max(maxLength, Math.max(incLength, decLength));
        }
        return maxLength;
    }
}",False
Maximum Prime Difference,"You are given an integer array nums.
Return an integer that is the maximum distance between the indices of two (not necessarily different) prime numbers in nums.
","Example 1:
Input: nums = [4,2,9,5,3]
Output: 3
Explanation: nums[1], nums[3], and nums[4] are prime. So the answer is |4 - 1| = 3.
Example 2:
Input: nums = [4,8,2,8]
Output: 0
Explanation: nums[2] is prime. Because there is just one prime number, the answer is |2 - 2| = 0.
","class Solution:
    
    def is_prime(self, num: int) -> bool:
        if num < 2:
            return False
        for i in range(2, int(num**0.5)+1):
            if(num%i == 0):
                return False
        return True
    
    def maximumPrimeDifference(self, nums: List[int]) -> int:
        prime = []
        for i, num in enumerate(nums):
            if self.is_prime(num):
                prime.append(i)
        
        if len(prime) < 2:
            return 0
        return prime[-1]-prime[0]",True
Count Alternating Subarrays,"You are given a
binary array
nums.
We call a
subarray
alternating if no two adjacent elements in the subarray have the same value.
Return the number of alternating subarrays in nums.
","Example 1:
Input: nums = [0,1,1,1]
Output: 5
Explanation:
The following subarrays are alternating: [0], [1], [1], [1], and [0,1].
Example 2:
Input: nums = [1,0,1,0]
Output: 10
Explanation:
Every subarray of the array is alternating. There are 10 possible subarrays that we can choose.
","class Solution:
    def countAlternatingSubarrays(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [1] * n
        
        for i in range(1, n):
            if nums[i-1] != nums[i]:
                dp[i] = dp[i - 1] + 1
        
        return sum(dp)",True
Shortest Subarray With OR at Least K I,"You are given an array nums of non-negative integers and an integer k.
An array is called special if the bitwise OR of all of its elements is at least k.
Return the length of the shortest special non-empty
subarray
of nums, or return -1 if no special subarray exists.
","Example 1:
Input: nums = [1,2,3], k = 2
Output: 1
Explanation:
The subarray [3] has OR value of 3. Hence, we return 1.
Example 2:
Input: nums = [2,1,8], k = 10
Output: 3
Explanation:
The subarray [2,1,8] has OR value of 11. Hence, we return 3.
Example 3:
Input: nums = [1,2], k = 0
Output: 1
Explanation:
The subarray [1] has OR value of 1. Hence, we return 1.
","class Solution:
    def minimumSubarrayLength(self, nums: List[int], k: int) -> int:

        acc = nums

        for i in range(1,len(nums)+1):

            if max(acc) >= k: return i
            acc = [x|y for x,y in zip(acc, nums[i:])]
 
        return -1 ",True
Taking Maximum Energy From the Mystic Dungeon,"In a mystic dungeon, n magicians are standing in a line. Each magician has an attribute that gives you energy. Some magicians can give you negative energy, which means taking energy from you.
You have been cursed in such a way that after absorbing energy from magician i, you will be instantly transported to magician (i + k). This process will be repeated until you reach the magician where (i + k) does not exist.
In other words, you will choose a starting point and then teleport with k jumps until you reach the end of the magicians' sequence, absorbing all the energy during the journey.
You are given an array energy and an integer k. Return the maximum possible energy you can gain.
","Example 1:
Input: energy = [5,2,-10,-5,1], k = 3
Output: 3
Explanation: We can gain a total energy of 3 by starting from magician 1 absorbing 2 + 1 = 3.
Example 2:
Input: energy = [-2,-3,-1], k = 2
Output: -1
Explanation: We can gain a total energy of -1 by starting from magician 2.
",,False
Minimum Operations to Make Median of Array Equal to K,"You are given an integer array nums and a non-negative integer k. In one operation, you can increase or decrease any element by 1.
Return the minimum number of operations needed to make the median of nums equal to k.
The median of an array is defined as the middle element of the array when it is sorted in non-decreasing order. If there are two choices for a median, the larger of the two values is taken.
","Example 1:
Input: nums = [2,5,6,8,5], k = 4
Output: 2
Explanation:
We can subtract one from nums[1] and nums[4] to obtain [2, 4, 6, 8, 4]. The median of the resulting array is equal to k.
Example 2:
Input: nums = [2,5,6,8,5], k = 7
Output: 3
Explanation:
We can add one to nums[1] twice and add one to nums[2] once to obtain [2, 7, 7, 8, 5].
Example 3:
Input: nums = [1,2,3,4,5,6], k = 4
Output: 0
Explanation:
The median of the array is already equal to k.
","class Solution:
    def minOperationsToMakeMedianK(self, nums: List[int], k: int) -> int:
        nums.sort()
        n = len(nums)
        median = nums[n//2]
        count = 0
        if median == k:
            return 0
        elif median > k:
            i = 0
            diff = median - k
            while i <= n//2:
                if nums[i]+diff > median:
                    count += abs(nums[i]-k)
                i += 1
        else:
            i = n-1
            diff = k - median
            while i >= n//2:
                if nums[i]-diff < median:
                    count += abs(nums[i]-k)
                i -= 1
        return count",True
Right Triangles,"You are given a 2D boolean matrix grid.
Return an integer that is the number of right triangles that can be made with the 3 elements of grid such that all of them have a value of 1.
Note:
A collection of 3 elements of grid is a right triangle if one of its elements is in the same row with another element and in the same column with the third element. The 3 elements do not have to be next to each other.
","Example 1:
0 1 0
0 1 1
0 1 0
0 1 0
0 1 1
0 1 0
Input: grid = [[0,1,0],[0,1,1],[0,1,0]]
Output: 2
Explanation:
There are two right triangles.
Example 2:
1 0 0 0
0 1 0 1
1 0 0 0
Input: grid = [[1,0,0,0],[0,1,0,1],[1,0,0,0]]
Output: 0
Explanation:
There are no right triangles.
Example 3:
1 0 1
1 0 0
1 0 0
1 0 1
1 0 0
1 0 0
Input: grid = [[1,0,1],[1,0,0],[1,0,0]]
Output: 2
Explanation:
There are two right triangles.
","class Solution:
    def numberOfRightTriangles(self, grid: List[List[int]]) -> int:
        totalTriangles = 0
        rows, cols = len(grid), len(grid[0])
        prefixColSum, prefixRowSum = [0] * cols, [0] * rows
        postfixColSum, postfixRowSum = [0] * cols, [0] * rows

        for index, row in enumerate(grid):
            postfixRowSum[index] = sum(row)

        for col in range(cols):
            currSum = 0
            for row in range(rows):
                currSum += grid[row][col]
            postfixColSum[col] = currSum
        
        for row in range(rows):
            for col in range(cols):
                if grid[row][col] == 1:
                    postfixRowSum[row] -= 1
                    postfixColSum[col] -= 1

                    totalTriangles += \
                        prefixRowSum[row] * prefixColSum[col]  +\
                        prefixRowSum[row] * postfixColSum[col] +\
                        postfixRowSum[row] * prefixColSum[col] +\
                        postfixRowSum[row] * postfixColSum[col]

                    prefixRowSum[row] += 1
                    prefixColSum[col] += 1
        
        return totalTriangles",True
Minimum Time to Visit Disappearing Nodes,"There is an undirected graph of n nodes. You are given a 2D array edges, where edges[i] = [ui, vi, lengthi] describes an edge between node ui and node vi with a traversal time of lengthi units.
Additionally, you are given an array disappear, where disappear[i] denotes the time when the node i disappears from the graph and you won't be able to visit it.
Notice that the graph might be disconnected and might contain multiple edges.
Return the array answer, with answer[i] denoting the minimum units of time required to reach node i from node 0. If node i is unreachable from node 0 then answer[i] is -1.
","Example 1:

Input: n = 3, edges = [[0,1,2],[1,2,1],[0,2,4]], disappear = [1,1,5]
Output: [0,-1,4]
Explanation:
We are starting our journey from node 0, and our goal is to find the minimum time required to reach each node before it disappears.
For node 0, we don't need any time as it is our starting point.
For node 1, we need at least 2 units of time to traverse edges[0]. Unfortunately, it disappears at that moment, so we won't be able to visit it.
For node 2, we need at least 4 units of time to traverse edges[2].
Example 2:

Input: n = 3, edges = [[0,1,2],[1,2,1],[0,2,4]], disappear = [1,3,5]
Output: [0,2,3]
Explanation:
We are starting our journey from node 0, and our goal is to find the minimum time required to reach each node before it disappears.
For node 0, we don't need any time as it is the starting point.
For node 1, we need at least 2 units of time to traverse edges[0].
For node 2, we need at least 3 units of time to traverse edges[0] and edges[1].
Example 3:
Input: n = 2, edges = [[0,1,1]], disappear = [1,1]
Output: [0,-1]
Explanation:
Exactly when we reach node 1, it disappears.
","class Solution:
    def buildAdjList(self, totalNodes, edges):
        adjList = [{} for _ in range(totalNodes)]

        for fromNode, toNode, dist in edges:
            # print(fromNode, toNode, dist)
            newDist = dist
            if toNode in adjList[fromNode]:
                newDist = min(adjList[fromNode][toNode], dist)
            adjList[fromNode][toNode] = newDist
            adjList[toNode][fromNode] = newDist
        
        return adjList
            
    def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:
        adjList = self.buildAdjList(n, edges)
        # print(adjList)
        
        pq = [[0, 0]] # [edge, steps]
        visited = set()

        result = [inf] * n
        
        while pq:
            steps, node = heapq.heappop(pq)
            
            if node in visited or steps > disappear[node]:
                continue
            
            result[node] = min(steps, result[node])
            

            visited.update((node,))
            for adjNode, dist in adjList[node].items():
                newSteps = steps + dist
                if adjNode in visited or newSteps >= disappear[adjNode]:
                    continue
                heapq.heappush(pq, [newSteps, adjNode])
            
        for i in range(n):
            if result[i] == inf:
                result[i] = -1
        return result",True
Minimum Rectangles to Cover Points,"You are given a 2D integer array points, where points[i] = [xi, yi]. You are also given an integer w. Your task is to cover all the given points with rectangles.
Each rectangle has its lower end at some point (x1, 0) and its upper end at some point (x2, y2), where x1 <= x2, y2 >= 0, and the condition x2 - x1 <= w must be satisfied for each rectangle.
A point is considered covered by a rectangle if it lies within or on the boundary of the rectangle.
Return an integer denoting the minimum number of rectangles needed so that each point is covered by at least one rectangle.
Note: A point may be covered by more than one rectangle.
","Example 1:

Input: points = [[2,1],[1,0],[1,4],[1,8],[3,5],[4,6]], w = 1
Output: 2
Explanation:
The image above shows one possible placement of rectangles to cover the points:
A rectangle with a lower end at (1, 0) and its upper end at (2, 8)
A rectangle with a lower end at (3, 0) and its upper end at (4, 8)
Example 2:

Input: points = [[0,0],[1,1],[2,2],[3,3],[4,4],[5,5],[6,6]], w = 2
Output: 3
Explanation:
The image above shows one possible placement of rectangles to cover the points:
A rectangle with a lower end at (0, 0) and its upper end at (2, 2)
A rectangle with a lower end at (3, 0) and its upper end at (5, 5)
A rectangle with a lower end at (6, 0) and its upper end at (6, 6)
Example 3:

Input: points = [[2,3],[1,2]], w = 0
Output: 2
Explanation:
The image above shows one possible placement of rectangles to cover the points:
A rectangle with a lower end at (1, 0) and its upper end at (1, 2)
A rectangle with a lower end at (2, 0) and its upper end at (2, 3)
",,False
Maximum Difference Score in a Grid,"You are given an m x n matrix grid consisting of positive integers. You can move from a cell in the matrix to any other cell that is either to the bottom or to the right (not necessarily adjacent). The score of a move from a cell with the value c1 to a cell with the value c2 is c2 - c1.
You can start at any cell, and you have to make at least one move.
Return the maximum total score you can achieve.
","Example 1:

Input: grid = [[9,5,7,3],[8,9,6,1],[6,7,14,3],[2,5,3,1]]
Output: 9
Explanation: We start at the cell (0, 1), and we perform the following moves:
- Move from the cell (0, 1) to (2, 1) with a score of 7 - 5 = 2.
- Move from the cell (2, 1) to (2, 2) with a score of 14 - 7 = 7.
The total score is 2 + 7 = 9.
Example 2:

Input: grid = [[4,3,2],[3,2,1]]
Output: -1
Explanation: We start at the cell (0, 0), and we perform one move: (0, 0) to (0, 1). The score is 3 - 4 = -1.
",,False
Find the Integer Added to Array I,"You are given two arrays of equal length, nums1 and nums2.
Each element in nums1 has been increased (or decreased in the case of negative) by an integer, represented by the variable x.
As a result, nums1 becomes equal to nums2. Two arrays are considered equal when they contain the same integers with the same frequencies.
Return the integer x.
","Example 1:
Input: nums1 = [2,6,4], nums2 = [9,7,5]
Output: 3
Explanation:
The integer added to each element of nums1 is 3.
Example 2:
Input: nums1 = [10], nums2 = [5]
Output: -5
Explanation:
The integer added to each element of nums1 is -5.
Example 3:
Input: nums1 = [1,1,1,1], nums2 = [1,1,1,1]
Output: 0
Explanation:
The integer added to each element of nums1 is 0.
","class Solution:
    def addedInteger(self, nums1: List[int], nums2: List[int]) -> int:
        nums1.sort()
        nums2.sort()
        return nums2[0] - nums1[0]",True
Make a Square with the Same Color,"You are given a 2D matrix grid of size 3 x 3 consisting only of characters 'B' and 'W'. Character 'W' represents the white color, and character 'B' represents the black color.
Your task is to change the color of at most one cell so that the matrix has a 2 x 2 square where all cells are of the same color.
Return true if it is possible to create a 2 x 2 square of the same color, otherwise, return false.
","

Example 1:
                 
Input: grid = [[""B"",""W"",""B""],[""B"",""W"",""W""],[""B"",""W"",""B""]]
Output: true
Explanation:
It can be done by changing the color of the grid[0][2].
Example 2:
                 
Input: grid = [[""B"",""W"",""B""],[""W"",""B"",""W""],[""B"",""W"",""B""]]
Output: false
Explanation:
It cannot be done by changing at most one cell.
Example 3:
                 
Input: grid = [[""B"",""W"",""B""],[""B"",""W"",""W""],[""B"",""W"",""W""]]
Output: true
Explanation:
The grid already contains a 2 x 2 square of the same color.
","class Solution:
    def canMakeSquare(self, grid: List[List[str]]) -> bool:
        for i in range(2):
            for j in range(2):
                submatrix = (
                    grid[i][j],
                    grid[i + 1][j],
                    grid[i][j + 1],
                    grid[i + 1][j + 1],
                )
                if sum([cell == ""B"" for cell in submatrix]) != 2:
                    return True

        return False
",True
Find the Integer Added to Array II,"You are given two integer arrays nums1 and nums2.
From nums1 two elements have been removed, and all other elements have been increased (or decreased in the case of negative) by an integer, represented by the variable x.
As a result, nums1 becomes equal to nums2. Two arrays are considered equal when they contain the same integers with the same frequencies.
Return the minimum possible integer x that achieves this equivalence.
","Example 1:
Input: nums1 = [4,20,16,12,8], nums2 = [14,18,10]
Output: -2
Explanation:
After removing elements at indices [0,4] and adding -2, nums1 becomes [18,14,10].
Example 2:
Input: nums1 = [3,5,5,3], nums2 = [7,7]
Output: 2
Explanation:
After removing elements at indices [0,3] and adding 2, nums1 becomes [7,7].
","class Solution:
    def minimumAddedInteger(self, nums1: List[int], nums2: List[int]) -> int:
        min2 = min(nums2)
        c, b, a = [min2 - val for val in heapq.nsmallest(3, nums1)]
        nums2 = Counter(nums2)
        for x in (a, b, c):
            if nums2 <= Counter(val + x for val in nums1):
                return x",True
Check if Grid Satisfies Conditions,"You are given a 2D matrix grid of size m x n. You need to check if each cell grid[i][j] is:
Equal to the cell below it, i.e. grid[i][j] == grid[i + 1][j] (if it exists).
Different from the cell to its right, i.e. grid[i][j] != grid[i][j + 1] (if it exists).
Return true if all the cells satisfy these conditions, otherwise, return false.
","Example 1:
Input: grid = [[1,0,2],[1,0,2]]
Output: true
Explanation:
All the cells in the grid satisfy the conditions.
Example 2:
Input: grid = [[1,1,1],[0,0,0]]
Output: false
Explanation:
All cells in the first row are equal.
Example 3:
Input: grid = [[1],[2],[3]]
Output: false
Explanation:
Cells in the first column have different values.
","class Solution:
    def satisfiesConditions(self, grid: List[List[int]]) -> bool:
        m = len(grid)
        n = len(grid[0])

        for y in range(m - 1):
            if grid[y][0] != grid[y + 1][0]:
                return False

            for x in range(n - 1):
                if grid[y][x] == grid[y][x + 1]:
                    return False

        
        y = m - 1
        for x in range(n - 1):
            if grid[y][x] == grid[y][x + 1]:
                return False
        return True
",True
Sum of Digit Differences of All Pairs,"You are given an array nums consisting of positive integers where all integers have the same number of digits.
The digit difference between two integers is the count of different digits that are in the same position in the two integers.
Return the sum of the digit differences between all pairs of integers in nums.
","Example 1:
Input: nums = [13,23,12]
Output: 4
Explanation:
We have the following:
- The digit difference between 13 and 23 is 1.
- The digit difference between 13 and 12 is 1.
- The digit difference between 23 and 12 is 2.
So the total sum of digit differences between all pairs of integers is 1 + 1 + 2 = 4.
Example 2:
Input: nums = [10,10,10,10]
Output: 0
Explanation:
All the integers in the array are the same. So the total sum of digit differences between all pairs of integers will be 0.
",,False
Maximum Points Inside the Square,"You are given a 2D array points and a string s where, points[i] represents the coordinates of point i, and s[i] represents the tag of point i.
A valid square is a square centered at the origin (0, 0), has edges parallel to the axes, and does not contain two points with the same tag.
Return the maximum number of points contained in a valid square.
Note:
A point is considered to be inside the square if it lies on or within the square's boundaries.
The side length of the square can be zero.
","Example 1:

Input: points = [[2,2],[-1,-2],[-4,4],[-3,1],[3,-3]], s = ""abdca""
Output: 2
Explanation:
The square of side length 4 covers two points points[0] and points[1].
Example 2:

Input: points = [[1,1],[-2,-2],[-2,2]], s = ""abb""
Output: 1
Explanation:
The square of side length 2 covers one point, which is points[0].
Example 3:
Input: points = [[1,1],[-1,-1],[2,-2]], s = ""ccd""
Output: 0
Explanation:
It's impossible to make any valid squares centered at the origin such that it covers only one point among points[0] and points[1].
","class Solution:
    def maxPointsInsideSquare(self, points: List[List[int]], s: str) -> int:
        d = {}
        for i in range(len(points)):
            x = [abs(x) for x in points[i]]
            x = max(x)
            y = s[i]
            if x in d:
                d[x] = d[x] + y
            else:
                d[x] = y
        d = dict(sorted(d.items()))
        result = 0
        string = """"
        for i in d:
            for y in d[i]:
                if y not in string:
                    string += y
                else:
                    return result
            result += len(d[i])
        return result

            


            


        
        ",True
Find Occurrences of an Element in an Array,"You are given an integer array nums, an integer array queries, and an integer x.
For each queries[i], you need to find the index of the queries[i]th occurrence of x in the nums array. If there are fewer than queries[i] occurrences of x, the answer should be -1 for that query.
Return an integer array answer containing the answers to all queries.
","Example 1:
Input: nums = [1,3,1,7], queries = [1,3,2,4], x = 1
Output: [0,-1,2,-1]
Explanation:
For the 1st query, the first occurrence of 1 is at index 0.
For the 2nd query, there are only two occurrences of 1 in nums, so the answer is -1.
For the 3rd query, the second occurrence of 1 is at index 2.
For the 4th query, there are only two occurrences of 1 in nums, so the answer is -1.
Example 2:
Input: nums = [1,2,3], queries = [10], x = 5
Output: [-1]
Explanation:
For the 1st query, 5 doesn't exist in nums, so the answer is -1.
",,False
Special Array II,"An array is considered special if every pair of its adjacent elements contains two numbers with different parity.
You are given an array of integer nums and a 2D integer matrix queries, where for queries[i] = [fromi, toi] your task is to check that
subarray
nums[fromi..toi] is special or not.
Return an array of booleans answer such that answer[i] is true if nums[fromi..toi] is special.
","Example 1:
Input: nums = [3,4,1,2,6], queries = [[0,4]]
Output: [false]
Explanation:
The subarray is [3,4,1,2,6]. 2 and 6 are both even.
Example 2:
Input: nums = [4,3,1,6], queries = [[0,2],[2,3]]
Output: [false,true]
Explanation:
The subarray is [4,3,1]. 3 and 1 are both odd. So the answer to this query is false.
The subarray is [1,6]. There is only one pair: (1,6) and it contains numbers with different parity. So the answer to this query is true.
","class Solution:
    def isArraySpecial(self, nums: List[int], queries: List[List[int]]) -> List[bool]:
        n = len(nums)
    
        if n == 1:
            return [True] * len(queries)  # Single element arrays are always special

        # Step 1: Create the special array
        special = [0] * (n - 1)
        for i in range(n - 1):
            if nums[i] % 2 == nums[i + 1] % 2:
                special[i] = 1

        # Step 2: Create the prefix_special array
        prefix_special = [0] * n
        for i in range(1, n):
            prefix_special[i] = prefix_special[i - 1] + special[i - 1]

        # Step 3: Evaluate each query using the prefix_special array
        result = []
        for fromi, toi in queries:
            if prefix_special[toi] - prefix_special[fromi] > 0:
                result.append(False)
            else:
                result.append(True)

        return result
    ",True
Special Array I,"An array is considered special if every pair of its adjacent elements contains two numbers with different parity.
You are given an array of integers nums. Return true if nums is a special array, otherwise, return false.
","Example 1:
Input: nums = [1]
Output: true
Explanation:
There is only one element. So the answer is true.
Example 2:
Input: nums = [2,1,4]
Output: true
Explanation:
There is only two pairs: (2,1) and (1,4), and both of them contain numbers with different parity. So the answer is true.
Example 3:
Input: nums = [4,3,1,6]
Output: false
Explanation:
nums[1] and nums[2] are both odd. So the answer is false.
",,False
Find the Number of Distinct Colors Among the Balls,"You are given an integer limit and a 2D array queries of size n x 2.
There are limit + 1 balls with distinct labels in the range [0, limit]. Initially, all balls are uncolored. For every query in queries that is of the form [x, y], you mark ball x with the color y. After each query, you need to find the number of distinct colors among the balls.
Return an array result of length n, where result[i] denotes the number of distinct colors after ith query.
Note that when answering a query, lack of a color will not be considered as a color.
","Example 1:
Input: limit = 4, queries = [[1,4],[2,5],[1,3],[3,4]]
Output: [1,2,2,3]
Explanation:
After query 0, ball 1 has color 4.
After query 1, ball 1 has color 4, and ball 2 has color 5.
After query 2, ball 1 has color 3, and ball 2 has color 5.
After query 3, ball 1 has color 3, ball 2 has color 5, and ball 3 has color 4.
Example 2:
Input: limit = 4, queries = [[0,1],[1,2],[2,2],[3,4],[4,5]]
Output: [1,2,2,3,4]
Explanation:
After query 0, ball 0 has color 1.
After query 1, ball 0 has color 1, and ball 1 has color 2.
After query 2, ball 0 has color 1, and balls 1 and 2 have color 2.
After query 3, ball 0 has color 1, balls 1 and 2 have color 2, and ball 3 has color 4.
After query 4, ball 0 has color 1, balls 1 and 2 have color 2, ball 3 has color 4, and ball 4 has color 5.
",,False
Find the Number of Good Pairs II,"You are given 2 integer arrays nums1 and nums2 of lengths n and m respectively. You are also given a positive integer k.
A pair (i, j) is called good if nums1[i] is divisible by nums2[j] * k (0 <= i <= n - 1, 0 <= j <= m - 1).
Return the total number of good pairs.
","Example 1:
Input: nums1 = [1,3,4], nums2 = [1,3,4], k = 1
Output: 5
Explanation:
The 5 good pairs are (0, 0), (1, 0), (1, 1), (2, 0), and (2, 2).
Example 2:
Input: nums1 = [1,2,4,12], nums2 = [2,4], k = 3
Output: 2
Explanation:
The 2 good pairs are (3, 0) and (3, 1).
","class Solution {
public:
    long long numberOfPairs(vector<int>& nums1, vector<int>& nums2, int k) {
        unordered_map<int, int> map;
        for(auto& num : nums2)
            map[num * k]++;
        
        long long ans = 0;
        for(auto& num : nums1){
            vector<int> help;
            int b = num;
            for(int i = 1; i * i <= b; i++){
                if(b % i == 0){
                    ans += map[i];
                    if(i * i != b)
                        ans += map[b / i];
                }
            }
        }
        return ans;
    }
};",False
Find the Number of Good Pairs I,"You are given 2 integer arrays nums1 and nums2 of lengths n and m respectively. You are also given a positive integer k.
A pair (i, j) is called good if nums1[i] is divisible by nums2[j] * k (0 <= i <= n - 1, 0 <= j <= m - 1).
Return the total number of good pairs.
","Example 1:
Input: nums1 = [1,3,4], nums2 = [1,3,4], k = 1
Output: 5
Explanation:
The 5 good pairs are (0, 0), (1, 0), (1, 1), (2, 0), and (2, 2).
Example 2:
Input: nums1 = [1,2,4,12], nums2 = [2,4], k = 3
Output: 2
Explanation:
The 2 good pairs are (3, 0) and (3, 1).
","class Solution {
public:
    int numberOfPairs(vector<int>& nums1, vector<int>& nums2, int k) {
        int n = nums1.size(),m = nums2.size(), cnt=0;
        for (int i=0; i<n; ++i) {
            for (int j=0; j<m; ++j) {
                int x=nums2[j]*k;
                if(nums1[i]%x == 0) cnt++;
            }
        }
        return cnt;
    }
};",False
